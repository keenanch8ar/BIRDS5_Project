#include <BIRDS5_OBC.h>

#INT_rda                                                                         //PC Interrupt, RS232 receive data available in buffer 1
void UART1_RXD(void)
{
   CMD_FROM_PC[PC_DATA] = fgetc(PC);                                             //loads the CMD_FROM_PC [] array with the data sent by PC (carga el array CMD_FROM_PC[] con los datos enviados por PC)
   PC_DATA = ((PC_DATA + 1) % 8);                                                //when the data is obtained in position 6, PC_DATA = 0 (cuando se obtenga el dato en la posicion 6, PC_DATA=0)
   //fputc(fgetc(PC),PC);
}


#INT_rda2 HIGH                                                                   //COM Interrupt, RS232 receive data available in buffer 2
void UART2_RXD(void)
{
   //SerialDataReceive();  //get 32 byte
   //COM_ONEBYTE_COMMAND = fgetc(COM);
   in_bffr_main[COM_DATA] = fgetc(COM);                                          //load the array in_bffr_main [] with the data sent by COM PIC (carga el array in_bffr_main[] con los datos enviados por COM PIC)
   COM_DATA = ((COM_DATA + 1) % 16);                                             //when the data is obtained in position 16, COM_DATA = 0 (cuando se obtenga el dato en la posicion 16, COM_DATA=0)
} 


#INT_rda3                                                                        //FAB Interrupt, RS232 receive data available in buffer 3
void UART3_RXD(void)
{
   //collect_HK_from_FAB();
   in_HK[FAB_DATA] = fgetc(FAB);                                                 //load the array in_HK [] with the data sent by the FAB PIC (carga el array in_HK[] con los datos enviados por el FAB PIC)
   FAB_DATA = ((FAB_DATA + 1) % FAB_SENSOR_size);                                //when the data is obtained in position 45 FAB_DATA = 0 (cuando se obtenga el dato en la posicion 45 FAB_DATA=0)
} 


#INT_rda4                                                                        //Reset PIC Interrupt, RS232 receive data available in buffer 4
void UART4_RXD(void)
{
   reset_bffr[RESET_DATA] = fgetc(reset);                                        //loads the reset_bffr array with the data sent by the Reset PIC (carga el array reset_bffr con los datos enviados por el Reset PIC)
   RESET_DATA = ((RESET_DATA + 1) % RESET_size);                                 //when the data is obtained in position 11 RESET_DATA = 0 (cuando se obtenga el dato en la posicion 11 RESET_DATA=0)
   //fputc(fgetc(reset),PC);
   if(reset_bffr[0] == 0xaa)                                                     //get ready for reset satellite
   {
      reset_flag = 1;                                                            //raise flag to reset (pone a alto bandera para reseteo)
      RESET_DATA = 0;                                                            //position indicator within reset_data vector (indicador de posicion dentro del vector reset_data)
   }
   
}

void settings()
{
   set_tris_b(0b11010000);                                                       // Port b configuration (Configuracion del puerto b)
   enable_interrupts(global);                                                    // Enabling global interrupts (Habilitacion de interrupciones globales)      
   enable_interrupts(INT_rda);                                                   // Main to PC
   enable_interrupts(INT_rda2);                                                  // Main to COM PIC
   enable_interrupts(INT_rda3);                                                  // Main to FAB PIC   
   enable_interrupts(INT_rda4);                                                  // Main to RESET PIC

   return;                                                                       
  
}


void main()
{
   //settings();
   fprintf(PC,"Start Operating\r\n");
   output_high(PIN_A5);  //MUX MISSION SIDE
   
   while(TRUE)
   {
      //fprintf(PC,"\r\nHello World\r\n");
      //output_high(PIN_G2);
      //Turn_On_CAM();
      //delay_ms(10000);
      fprintf(PC,"Operating\r\n");
      //output_low(PIN_G2);
      //delay_ms(10000);
   }

}
