CCS PCH C Compiler, Version 5.050, 5967               30-Jun-21 18:20

               Filename:   C:\Users\keena\Dropbox\BIRDS5_Project\BIRDS5_OBC.lst

               ROM used:   5908 bytes (5%)
                           Largest free fragment is 65520
               RAM used:   515 (14%) at main() level
                           551 (15%) worst case
               Stack used: 0 locations
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   149A
*
00008:  NOP   
0000A:  NOP   
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  FF8,18
00058:  MOVFF  FFB,19
0005C:  MOVFF  00,0E
00060:  MOVFF  01,0F
00064:  MOVFF  02,10
00068:  MOVFF  03,11
0006C:  BTFSS  F61.7
0006E:  GOTO   0078
00072:  BTFSC  FA6.7
00074:  GOTO   06DE
00078:  MOVFF  0E,00
0007C:  MOVFF  0F,01
00080:  MOVFF  10,02
00084:  MOVFF  11,03
00088:  MOVFF  0C,FE9
0008C:  MOVFF  07,FEA
00090:  BSF    07.7
00092:  MOVFF  08,FE1
00096:  MOVFF  09,FE2
0009A:  MOVFF  0A,FD9
0009E:  MOVFF  0B,FDA
000A2:  MOVFF  12,FF3
000A6:  MOVFF  13,FF4
000AA:  MOVFF  14,FFA
000AE:  MOVFF  15,FF5
000B2:  MOVFF  16,FF6
000B6:  MOVFF  17,FF7
000BA:  MOVFF  18,FF8
000BE:  MOVFF  19,FFB
000C2:  MOVF   04,W
000C4:  MOVFF  06,FE0
000C8:  MOVFF  05,FD8
000CC:  RETFIE 0
.................... #include <BIRDS5_OBC.h> 
.................... #include <18F67J94.h> 
.................... //////////// Standard Header file for the PIC18F67J94 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F67J94 
000CE:  DATA 0D,0A
000D0:  DATA 50,41
000D2:  DATA 53,53
000D4:  DATA 45,44
000D6:  DATA 20,44
000D8:  DATA 41,59
000DA:  DATA 53,3A
000DC:  DATA 25,78
000DE:  DATA 0D,0A
000E0:  DATA 00,00
000E2:  DATA 52,45
000E4:  DATA 53,45
000E6:  DATA 52,56
000E8:  DATA 45,20
000EA:  DATA 43,48
000EC:  DATA 45,43
000EE:  DATA 4B,3A
000F0:  DATA 25,78
000F2:  DATA 0D,0A
000F4:  DATA 00,00
000F6:  DATA 4B,69
000F8:  DATA 6C,6C
000FA:  DATA 20,46
000FC:  DATA 4C,41
000FE:  DATA 47,20
00100:  DATA 4D,41
00102:  DATA 49,4E
00104:  DATA 3A,25
00106:  DATA 78,0D
00108:  DATA 0A,00
0010A:  DATA 4B,69
0010C:  DATA 6C,6C
0010E:  DATA 20,46
00110:  DATA 4C,41
00112:  DATA 47,20
00114:  DATA 46,41
00116:  DATA 42,3A
00118:  DATA 25,78
0011A:  DATA 0D,0A
0011C:  DATA 00,00
0011E:  DATA 41,55
00120:  DATA 54,4F
00122:  DATA 20,48
00124:  DATA 49,47
00126:  DATA 48,20
00128:  DATA 53,41
0012A:  DATA 4D,50
0012C:  DATA 4C,49
0012E:  DATA 4E,47
00130:  DATA 3A,25
00132:  DATA 78,0D
00134:  DATA 0A,00
00136:  DATA 41,55
00138:  DATA 54,4F
0013A:  DATA 20,43
0013C:  DATA 41,4D
0013E:  DATA 3A,25
00140:  DATA 78,0D
00142:  DATA 0A,00
00144:  DATA 41,55
00146:  DATA 54,4F
00148:  DATA 20,4D
0014A:  DATA 42,50
0014C:  DATA 3A,25
0014E:  DATA 78,0D
00150:  DATA 0A,00
00152:  DATA 41,55
00154:  DATA 54,4F
00156:  DATA 20,41
00158:  DATA 44,43
0015A:  DATA 53,3A
0015C:  DATA 25,78
0015E:  DATA 0D,0A
00160:  DATA 00,00
00162:  DATA 41,4E
00164:  DATA 54,45
00166:  DATA 4E,4E
00168:  DATA 41,20
0016A:  DATA 44,45
0016C:  DATA 50,4C
0016E:  DATA 4F,59
00170:  DATA 3A,25
00172:  DATA 78,0D
00174:  DATA 0A,00
00176:  DATA 41,4E
00178:  DATA 54,45
0017A:  DATA 4E,4E
0017C:  DATA 41,20
0017E:  DATA 44,45
00180:  DATA 50,4C
00182:  DATA 4F,59
00184:  DATA 20,41
00186:  DATA 54,54
00188:  DATA 45,4D
0018A:  DATA 50,54
0018C:  DATA 3A,25
0018E:  DATA 78,0D
00190:  DATA 0A,00
00192:  DATA 55,50
00194:  DATA 4C,49
00196:  DATA 4E,4B
00198:  DATA 20,53
0019A:  DATA 55,43
0019C:  DATA 43,45
0019E:  DATA 53,53
001A0:  DATA 3A,25
001A2:  DATA 78,0D
001A4:  DATA 0A,0D
001A6:  DATA 0A,00
001A8:  DATA 0D,0A
001AA:  DATA 41,44
001AC:  DATA 44,20
001AE:  DATA 49,4E
001B0:  DATA 46,4F
001B2:  DATA 20,41
001B4:  DATA 44,44
001B6:  DATA 52,45
001B8:  DATA 53,53
001BA:  DATA 3A,25
001BC:  DATA 6C,78
001BE:  DATA 0D,0A
001C0:  DATA 0D,0A
001C2:  DATA 00,00
001C4:  DATA 46,4C
001C6:  DATA 41,47
001C8:  DATA 20,44
001CA:  DATA 41,54
001CC:  DATA 41,20
001CE:  DATA 41,44
001D0:  DATA 44,52
001D2:  DATA 45,53
001D4:  DATA 53,3A
001D6:  DATA 25,78
001D8:  DATA 25,78
001DA:  DATA 25,78
001DC:  DATA 25,78
001DE:  DATA 0D,0A
001E0:  DATA 00,00
001E2:  DATA 52,45
001E4:  DATA 53,45
001E6:  DATA 52,56
001E8:  DATA 41,54
001EA:  DATA 49,4F
001EC:  DATA 4E,20
001EE:  DATA 54,41
001F0:  DATA 42,4C
001F2:  DATA 45,20
001F4:  DATA 41,44
001F6:  DATA 44,52
001F8:  DATA 45,53
001FA:  DATA 53,3A
001FC:  DATA 25,78
001FE:  DATA 25,78
00200:  DATA 25,78
00202:  DATA 25,78
00204:  DATA 0D,0A
00206:  DATA 00,00
00208:  DATA 53,41
0020A:  DATA 54,45
0020C:  DATA 4C,4C
0020E:  DATA 49,54
00210:  DATA 45,20
00212:  DATA 4C,4F
00214:  DATA 47,20
00216:  DATA 41,44
00218:  DATA 44,52
0021A:  DATA 45,53
0021C:  DATA 53,3A
0021E:  DATA 25,78
00220:  DATA 25,78
00222:  DATA 25,78
00224:  DATA 25,78
00226:  DATA 0D,0A
00228:  DATA 00,00
0022A:  DATA 43,41
0022C:  DATA 4D,20
0022E:  DATA 41,44
00230:  DATA 44,52
00232:  DATA 45,53
00234:  DATA 53,3A
00236:  DATA 25,78
00238:  DATA 25,78
0023A:  DATA 25,78
0023C:  DATA 25,78
0023E:  DATA 0D,0A
00240:  DATA 00,00
00242:  DATA 46,41
00244:  DATA 42,20
00246:  DATA 48,4B
00248:  DATA 20,41
0024A:  DATA 44,44
0024C:  DATA 52,45
0024E:  DATA 53,53
00250:  DATA 3A,25
00252:  DATA 78,25
00254:  DATA 78,25
00256:  DATA 78,25
00258:  DATA 78,0D
0025A:  DATA 0A,00
0025C:  DATA 46,41
0025E:  DATA 42,20
00260:  DATA 43,57
00262:  DATA 20,41
00264:  DATA 44,44
00266:  DATA 52,45
00268:  DATA 53,53
0026A:  DATA 3A,25
0026C:  DATA 78,25
0026E:  DATA 78,25
00270:  DATA 78,25
00272:  DATA 78,0D
00274:  DATA 0A,00
00276:  DATA 41,44
00278:  DATA 43,53
0027A:  DATA 20,53
0027C:  DATA 45,4E
0027E:  DATA 53,4F
00280:  DATA 52,20
00282:  DATA 41,44
00284:  DATA 44,52
00286:  DATA 45,53
00288:  DATA 53,3A
0028A:  DATA 25,78
0028C:  DATA 25,78
0028E:  DATA 25,78
00290:  DATA 25,78
00292:  DATA 0D,0A
00294:  DATA 00,00
00296:  DATA 41,44
00298:  DATA 43,53
0029A:  DATA 20,54
0029C:  DATA 4C,45
0029E:  DATA 20,41
002A0:  DATA 44,44
002A2:  DATA 52,45
002A4:  DATA 53,53
002A6:  DATA 3A,25
002A8:  DATA 78,25
002AA:  DATA 78,25
002AC:  DATA 78,25
002AE:  DATA 78,0D
002B0:  DATA 0A,00
002B2:  DATA 4D,49
002B4:  DATA 53,53
002B6:  DATA 49,4F
002B8:  DATA 4E,20
002BA:  DATA 42,4F
002BC:  DATA 53,53
002BE:  DATA 20,41
002C0:  DATA 44,44
002C2:  DATA 52,45
002C4:  DATA 53,53
002C6:  DATA 3A,25
002C8:  DATA 78,25
002CA:  DATA 78,25
002CC:  DATA 78,25
002CE:  DATA 78,0D
002D0:  DATA 0A,00
002D2:  DATA 48,49
002D4:  DATA 47,48
002D6:  DATA 20,53
002D8:  DATA 41,4D
002DA:  DATA 50,20
002DC:  DATA 48,4B
002DE:  DATA 20,41
002E0:  DATA 44,44
002E2:  DATA 52,45
002E4:  DATA 53,53
002E6:  DATA 3A,25
002E8:  DATA 78,25
002EA:  DATA 78,25
002EC:  DATA 78,25
002EE:  DATA 78,0D
002F0:  DATA 0A,00
002F2:  DATA 57,52
002F4:  DATA 49,54
002F6:  DATA 45,20
002F8:  DATA 25,6C
002FA:  DATA 78,20
002FC:  DATA 54,49
002FE:  DATA 4D,45
00300:  DATA 53,0D
00302:  DATA 0A,00
00304:  DATA 0D,0A
00306:  DATA 50,41
00308:  DATA 53,53
0030A:  DATA 45,44
0030C:  DATA 20,44
0030E:  DATA 41,59
00310:  DATA 53,3A
00312:  DATA 25,6C
00314:  DATA 78,0D
00316:  DATA 0A,00
00318:  DATA 52,45
0031A:  DATA 53,45
0031C:  DATA 52,56
0031E:  DATA 45,20
00320:  DATA 43,48
00322:  DATA 45,43
00324:  DATA 4B,3A
00326:  DATA 25,78
00328:  DATA 0D,0A
0032A:  DATA 00,00
0032C:  DATA 4B,69
0032E:  DATA 6C,6C
00330:  DATA 20,46
00332:  DATA 4C,41
00334:  DATA 47,20
00336:  DATA 4D,41
00338:  DATA 49,4E
0033A:  DATA 3A,25
0033C:  DATA 78,0D
0033E:  DATA 0A,00
00340:  DATA 4B,69
00342:  DATA 6C,6C
00344:  DATA 20,46
00346:  DATA 4C,41
00348:  DATA 47,20
0034A:  DATA 46,41
0034C:  DATA 42,3A
0034E:  DATA 25,78
00350:  DATA 0D,0A
00352:  DATA 00,00
00354:  DATA 41,55
00356:  DATA 54,4F
00358:  DATA 20,48
0035A:  DATA 49,47
0035C:  DATA 48,20
0035E:  DATA 53,41
00360:  DATA 4D,50
00362:  DATA 4C,49
00364:  DATA 4E,47
00366:  DATA 3A,25
00368:  DATA 78,0D
0036A:  DATA 0A,00
0036C:  DATA 41,55
0036E:  DATA 54,4F
00370:  DATA 20,43
00372:  DATA 41,4D
00374:  DATA 3A,25
00376:  DATA 78,0D
00378:  DATA 0A,00
0037A:  DATA 41,55
0037C:  DATA 54,4F
0037E:  DATA 20,4D
00380:  DATA 42,50
00382:  DATA 3A,25
00384:  DATA 78,0D
00386:  DATA 0A,00
00388:  DATA 41,55
0038A:  DATA 54,4F
0038C:  DATA 20,41
0038E:  DATA 44,43
00390:  DATA 53,3A
00392:  DATA 25,78
00394:  DATA 0D,0A
00396:  DATA 00,00
00398:  DATA 41,4E
0039A:  DATA 54,45
0039C:  DATA 4E,4E
0039E:  DATA 41,20
003A0:  DATA 44,45
003A2:  DATA 50,4C
003A4:  DATA 4F,59
003A6:  DATA 3A,25
003A8:  DATA 78,0D
003AA:  DATA 0A,00
003AC:  DATA 55,50
003AE:  DATA 4C,49
003B0:  DATA 4E,4B
003B2:  DATA 20,53
003B4:  DATA 55,43
003B6:  DATA 43,45
003B8:  DATA 53,53
003BA:  DATA 3A,25
003BC:  DATA 78,0D
003BE:  DATA 0A,0D
003C0:  DATA 0A,00
003C2:  DATA 46,4C
003C4:  DATA 41,47
003C6:  DATA 20,49
003C8:  DATA 4E,46
003CA:  DATA 4F,20
003CC:  DATA 53,54
003CE:  DATA 4F,52
003D0:  DATA 45,44
003D2:  DATA 20,49
003D4:  DATA 4E,20
003D6:  DATA 46,4C
003D8:  DATA 41,53
003DA:  DATA 48,0D
003DC:  DATA 0A,00
003DE:  DATA 0D,0A
003E0:  DATA 61,64
003E2:  DATA 64,72
003E4:  DATA 65,73
003E6:  DATA 73,20
003E8:  DATA 69,6E
003EA:  DATA 66,6F
003EC:  DATA 20,6C
003EE:  DATA 6F,63
003F0:  DATA 61,74
003F2:  DATA 69,6F
003F4:  DATA 6E,3A
003F6:  DATA 25,6C
003F8:  DATA 78,0D
003FA:  DATA 0A,00
003FC:  DATA 41,44
003FE:  DATA 20,43
00400:  DATA 4F,55
00402:  DATA 4E,54
00404:  DATA 45,52
00406:  DATA 3A,25
00408:  DATA 6C,78
0040A:  DATA 0D,0A
0040C:  DATA 00,00
0040E:  DATA 43,48
00410:  DATA 41,4E
00412:  DATA 47,45
00414:  DATA 44,20
00416:  DATA 4D,45
00418:  DATA 4D,4F
0041A:  DATA 52,59
0041C:  DATA 20,41
0041E:  DATA 44,44
00420:  DATA 52,45
00422:  DATA 53,53
00424:  DATA 3A,00
00426:  DATA 0D,0A
00428:  DATA 53,74
0042A:  DATA 6F,72
0042C:  DATA 65,69
0042E:  DATA 6E,67
00430:  DATA 20,41
00432:  DATA 64,64
00434:  DATA 72,65
00436:  DATA 73,73
00438:  DATA 20,44
0043A:  DATA 61,74
0043C:  DATA 61,20
0043E:  DATA 69,6E
00440:  DATA 20,46
00442:  DATA 6C,61
00444:  DATA 73,68
00446:  DATA 0D,0A
00448:  DATA 00,00
0044A:  DATA 41,44
0044C:  DATA 44,52
0044E:  DATA 45,53
00450:  DATA 53,20
00452:  DATA 44,41
00454:  DATA 54,41
00456:  DATA 20,53
00458:  DATA 54,4F
0045A:  DATA 52,45
0045C:  DATA 20,44
0045E:  DATA 4F,4E
00460:  DATA 45,3A
00462:  DATA 25,6C
00464:  DATA 78,0D
00466:  DATA 0A,00
00468:  DATA 46,4C
0046A:  DATA 41,53
0046C:  DATA 48,20
0046E:  DATA 4D,45
00470:  DATA 4D,4F
00472:  DATA 52,59
00474:  DATA 20,45
00476:  DATA 52,41
00478:  DATA 53,45
0047A:  DATA 20,53
0047C:  DATA 54,41
0047E:  DATA 52,54
00480:  DATA 0D,0A
00482:  DATA 00,00
00484:  DATA 46,4C
00486:  DATA 41,53
00488:  DATA 48,20
0048A:  DATA 4D,45
0048C:  DATA 4D,4F
0048E:  DATA 52,59
00490:  DATA 20,45
00492:  DATA 52,41
00494:  DATA 53,45
00496:  DATA 20,44
00498:  DATA 4F,4E
0049A:  DATA 45,0D
0049C:  DATA 0A,00
0049E:  DATA 52,65
004A0:  DATA 6D,61
004A2:  DATA 69,6E
004A4:  DATA 69,6E
004A6:  DATA 67,20
004A8:  DATA 74,69
004AA:  DATA 6D,65
004AC:  DATA 3A,20
004AE:  DATA 25,64
004B0:  DATA 20,20
004B2:  DATA 0D,00
004B4:  DATA 65,72
004B6:  DATA 61,73
004B8:  DATA 69,6E
004BA:  DATA 67,20
004BC:  DATA 6E,65
004BE:  DATA 78,74
004C0:  DATA 20,73
004C2:  DATA 65,63
004C4:  DATA 74,6F
004C6:  DATA 72,0D
004C8:  DATA 0A,00
004CA:  DATA 65,72
004CC:  DATA 61,73
004CE:  DATA 69,6E
004D0:  DATA 67,20
004D2:  DATA 6E,65
004D4:  DATA 78,74
004D6:  DATA 20,73
004D8:  DATA 65,63
004DA:  DATA 74,6F
004DC:  DATA 72,0D
004DE:  DATA 0A,00
004E0:  DATA 65,72
004E2:  DATA 61,73
004E4:  DATA 69,6E
004E6:  DATA 67,20
004E8:  DATA 6E,65
004EA:  DATA 78,74
004EC:  DATA 20,73
004EE:  DATA 65,63
004F0:  DATA 74,6F
004F2:  DATA 72,0D
004F4:  DATA 0A,00
004F6:  DATA 65,72
004F8:  DATA 61,73
004FA:  DATA 69,6E
004FC:  DATA 67,20
004FE:  DATA 6E,65
00500:  DATA 78,74
00502:  DATA 20,73
00504:  DATA 65,63
00506:  DATA 74,6F
00508:  DATA 72,0D
0050A:  DATA 0A,00
0050C:  DATA 65,72
0050E:  DATA 61,73
00510:  DATA 69,6E
00512:  DATA 67,20
00514:  DATA 6E,65
00516:  DATA 78,74
00518:  DATA 20,73
0051A:  DATA 65,63
0051C:  DATA 74,6F
0051E:  DATA 72,0D
00520:  DATA 0A,00
00522:  DATA 47,65
00524:  DATA 74,20
00526:  DATA 63,6F
00528:  DATA 6D,6D
0052A:  DATA 61,6E
0052C:  DATA 64,0D
0052E:  DATA 0A,00
00530:  DATA 53,74
00532:  DATA 61,72
00534:  DATA 74,20
00536:  DATA 30,78
00538:  DATA 31,33
0053A:  DATA 0D,0A
0053C:  DATA 00,00
0053E:  DATA 46,69
00540:  DATA 6E,69
00542:  DATA 73,68
00544:  DATA 20,30
00546:  DATA 78,31
00548:  DATA 33,0D
0054A:  DATA 0A,00
0054C:  DATA 53,74
0054E:  DATA 61,72
00550:  DATA 74,20
00552:  DATA 30,78
00554:  DATA 31,34
00556:  DATA 0D,0A
00558:  DATA 00,00
0055A:  DATA 46,69
0055C:  DATA 6E,69
0055E:  DATA 73,68
00560:  DATA 20,30
00562:  DATA 78,31
00564:  DATA 34,0D
00566:  DATA 0A,00
00568:  DATA 53,74
0056A:  DATA 61,72
0056C:  DATA 74,20
0056E:  DATA 30,78
00570:  DATA 31,36
00572:  DATA 0D,0A
00574:  DATA 00,00
00576:  DATA 45,72
00578:  DATA 61,73
0057A:  DATA 65,64
0057C:  DATA 20,34
0057E:  DATA 6B,62
00580:  DATA 0D,0A
00582:  DATA 00,00
00584:  DATA 45,72
00586:  DATA 61,73
00588:  DATA 65,64
0058A:  DATA 20,33
0058C:  DATA 32,6B
0058E:  DATA 62,0D
00590:  DATA 0A,00
00592:  DATA 45,72
00594:  DATA 61,73
00596:  DATA 65,64
00598:  DATA 20,36
0059A:  DATA 34,6B
0059C:  DATA 62,0D
0059E:  DATA 0A,00
005A0:  DATA 46,69
005A2:  DATA 6E,69
005A4:  DATA 73,68
005A6:  DATA 20,30
005A8:  DATA 78,31
005AA:  DATA 36,0D
005AC:  DATA 0A,00
005AE:  DATA 53,74
005B0:  DATA 61,72
005B2:  DATA 74,20
005B4:  DATA 30,78
005B6:  DATA 39,31
005B8:  DATA 0D,0A
005BA:  DATA 00,00
005BC:  DATA 46,69
005BE:  DATA 6E,69
005C0:  DATA 73,68
005C2:  DATA 20,30
005C4:  DATA 78,39
005C6:  DATA 31,0D
005C8:  DATA 0A,00
005CA:  DATA 53,74
005CC:  DATA 61,72
005CE:  DATA 74,20
005D0:  DATA 30,78
005D2:  DATA 39,32
005D4:  DATA 0D,0A
005D6:  DATA 00,00
005D8:  DATA 46,69
005DA:  DATA 6E,69
005DC:  DATA 73,68
005DE:  DATA 20,30
005E0:  DATA 78,39
005E2:  DATA 32,0D
005E4:  DATA 0A,00
005E6:  DATA 53,74
005E8:  DATA 61,72
005EA:  DATA 74,20
005EC:  DATA 30,78
005EE:  DATA 39,33
005F0:  DATA 0D,0A
005F2:  DATA 00,00
005F4:  DATA 46,69
005F6:  DATA 6E,69
005F8:  DATA 73,68
005FA:  DATA 20,30
005FC:  DATA 78,39
005FE:  DATA 33,0D
00600:  DATA 0A,00
00602:  DATA 53,74
00604:  DATA 61,72
00606:  DATA 74,20
00608:  DATA 30,78
0060A:  DATA 39,34
0060C:  DATA 0D,0A
0060E:  DATA 00,00
00610:  DATA 46,69
00612:  DATA 6E,69
00614:  DATA 73,68
00616:  DATA 20,30
00618:  DATA 78,39
0061A:  DATA 34,0D
0061C:  DATA 0A,00
0061E:  DATA 53,74
00620:  DATA 61,72
00622:  DATA 74,20
00624:  DATA 30,78
00626:  DATA 39,42
00628:  DATA 0D,0A
0062A:  DATA 00,00
0062C:  DATA 46,69
0062E:  DATA 6E,69
00630:  DATA 73,68
00632:  DATA 20,30
00634:  DATA 78,39
00636:  DATA 42,0D
00638:  DATA 0A,00
0063A:  DATA 53,74
0063C:  DATA 61,72
0063E:  DATA 74,20
00640:  DATA 30,78
00642:  DATA 39,46
00644:  DATA 0D,0A
00646:  DATA 00,00
00648:  DATA 46,69
0064A:  DATA 6E,69
0064C:  DATA 73,68
0064E:  DATA 20,30
00650:  DATA 78,39
00652:  DATA 46,0D
00654:  DATA 0A,00
00656:  DATA 0D,0A
00658:  DATA 52,45
0065A:  DATA 53,45
0065C:  DATA 54,20
0065E:  DATA 44,41
00660:  DATA 54,41
00662:  DATA 20,4E
00664:  DATA 4F,54
00666:  DATA 20,4F
00668:  DATA 42,54
0066A:  DATA 41,49
0066C:  DATA 4E,45
0066E:  DATA 44,0D
00670:  DATA 0A,00
00672:  DATA 52,65
00674:  DATA 61,64
00676:  DATA 79,20
00678:  DATA 66,6F
0067A:  DATA 72,20
0067C:  DATA 72,65
0067E:  DATA 73,65
00680:  DATA 74,00
00682:  DATA 4C,4F
00684:  DATA 47,20
00686:  DATA 73,61
00688:  DATA 76,69
0068A:  DATA 6E,67
0068C:  DATA 20,64
0068E:  DATA 6F,6E
00690:  DATA 65,0D
00692:  DATA 0A,00
*
006B0:  MOVLB  2
006B2:  MOVF   x25,W
006B4:  CLRF   01
006B6:  SUBWF  x24,W
006B8:  BC    06C0
006BA:  MOVFF  224,00
006BE:  BRA    06D8
006C0:  CLRF   00
006C2:  MOVLW  08
006C4:  MOVWF  x26
006C6:  RLCF   x24,F
006C8:  RLCF   00,F
006CA:  MOVF   x25,W
006CC:  SUBWF  00,W
006CE:  BTFSC  FD8.0
006D0:  MOVWF  00
006D2:  RLCF   01,F
006D4:  DECFSZ x26,F
006D6:  BRA    06C6
006D8:  MOVLB  0
006DA:  GOTO   0714 (RETURN)
*
0072A:  DATA 53,74
0072C:  DATA 61,72
0072E:  DATA 74,20
00730:  DATA 4F,70
00732:  DATA 65,72
00734:  DATA 61,74
00736:  DATA 69,6E
00738:  DATA 67,0D
0073A:  DATA 0A,00
0073C:  DATA 0D,0A
0073E:  DATA 48,65
00740:  DATA 6C,6C
00742:  DATA 6F,20
00744:  DATA 57,6F
00746:  DATA 72,6C
00748:  DATA 64,0D
0074A:  DATA 0A,00
0074C:  DATA 4F,70
0074E:  DATA 65,72
00750:  DATA 61,74
00752:  DATA 69,6E
00754:  DATA 67,0D
00756:  DATA 0A,00
00758:  TBLRD*+
0075A:  MOVF   FF5,F
0075C:  BZ    0780
0075E:  MOVFF  FF6,202
00762:  MOVFF  FF7,203
00766:  MOVFF  FF8,204
0076A:  MOVF   FF5,W
0076C:  BTFSS  F9E.4
0076E:  BRA    076C
00770:  MOVWF  FAD
00772:  MOVFF  202,FF6
00776:  MOVFF  203,FF7
0077A:  MOVFF  204,FF8
0077E:  BRA    0758
00780:  RETURN 0
*
007AC:  TBLRD*+
007AE:  MOVF   FF5,F
007B0:  BZ    07D8
007B2:  MOVFF  FF6,20F
007B6:  MOVFF  FF7,210
007BA:  MOVFF  FF8,211
007BE:  MOVF   FF5,W
007C0:  BTFSS  FA6.4
007C2:  BRA    07C0
007C4:  MOVLB  F
007C6:  MOVWF  x29
007C8:  MOVFF  20F,FF6
007CC:  MOVFF  210,FF7
007D0:  MOVFF  211,FF8
007D4:  MOVLB  0
007D6:  BRA    07AC
007D8:  RETURN 0
....................  
.................... #list 
....................  
.................... #FUSES NOWDT, NOBROWNOUT, NOPROTECT 
.................... #use delay(crystal=16Mhz, clock=16Mhz) 
*
00782:  MOVLW  02
00784:  MOVWF  FEA
00786:  MOVLW  10
00788:  MOVWF  FE9
0078A:  MOVF   FEF,W
0078C:  BZ    07AA
0078E:  MOVLW  05
00790:  MOVWF  01
00792:  CLRF   00
00794:  DECFSZ 00,F
00796:  BRA    0794
00798:  DECFSZ 01,F
0079A:  BRA    0792
0079C:  MOVLW  2E
0079E:  MOVWF  00
007A0:  DECFSZ 00,F
007A2:  BRA    07A0
007A4:  BRA    07A6
007A6:  DECFSZ FEF,F
007A8:  BRA    078E
007AA:  RETURN 0
.................... #include<PIC18F67J94_registers.h> 
.................... #byte ADCBUF0H = 0xFC3 
.................... #byte ADCBUF0L = 0xFC2 
.................... #byte ADCON1H = 0xFC1 
.................... #bit    FORM0 = ADCON1H.0 
.................... #bit    FORM1 = ADCON1H.1 
.................... #bit    MODE12 = ADCON1H.2 
.................... #bit    DMAEN = ADCON1H.3 
.................... #bit    DMABM = ADCON1H.4 
.................... #bit    ADSIDL = ADCON1H.5 
.................... #bit    ADFRZ = ADCON1H.6 
.................... #bit    ADON = ADCON1H.7 
.................... #byte ADCON1L = 0xFC0 
.................... #bit    DONE = ADCON1L.0 
.................... #bit    SAMP = ADCON1L.1 
.................... #bit    ASAM = ADCON1L.2 
.................... #bit    SIMSAM = ADCON1L.3 
.................... #bit    SSRC0 = ADCON1L.4 
.................... #bit    SSRC1 = ADCON1L.5 
.................... #bit    SSRC2 = ADCON1L.6 
.................... #bit    SSRC3 = ADCON1L.7 
.................... #byte TRISG = 0xF98 
.................... #byte TRISF = 0xF97 
.................... #byte TRISE = 0xF96 
.................... #byte TRISD = 0xF95 
.................... #byte TRISC = 0xF94 
.................... #byte TRISB = 0xF93 
....................  
.................... #byte TRISA = 0xF92 
.................... #bit    TRISA0 = TRISA.0 
.................... #bit    TRISA1 = TRISA.1 
.................... #bit    TRISA2 = TRISA.2 
....................  
....................  
.................... #byte LATG = 0xF8F 
.................... #byte LATF = 0xF8E 
.................... #byte LATE = 0xF8D 
.................... #byte LATD = 0xF8C 
.................... #byte LATC = 0xF8B 
.................... #byte LATB = 0xF8A 
....................  
.................... #byte LATA = 0xF89 
.................... #bit    LATA0 = LATA.0 
.................... #bit    LATA1 = LATA.1 
.................... #bit    LATA2 = LATA.2 
.................... #bit    LATA3 = LATA.3 
....................  
.................... #byte PORTG = 0xF86 
.................... #bit    RG0 = PORTG.0 
.................... #bit    RG1 = PORTG.1 
.................... #bit    RG2 = PORTG.2 
.................... #bit    RG3 = PORTG.3 
.................... #bit    RG4 = PORTG.4 
.................... #bit    RG6 = PORTG.6 
.................... #bit    RG7 = PORTG.7 
.................... #byte PORTF = 0xF85 
.................... #bit    RF2 = PORTF.2 
.................... #bit    RF3 = PORTF.3 
.................... #bit    RF4 = PORTF.4 
.................... #bit    RF5 = PORTF.5 
.................... #bit    RF6 = PORTF.6 
.................... #bit    RF7 = PORTF.7 
.................... #byte PORTE = 0xF84 
.................... #byte PORTD = 0xF83 
.................... #byte PORTC = 0xF82 
.................... #bit    RC0 = PORTC.0 
.................... #bit    RC1 = PORTC.1 
.................... #bit    RC2 = PORTC.2 
.................... #bit    RC3 = PORTC.3 
.................... #bit    RC4 = PORTC.4 
.................... #bit    RC5 = PORTC.5 
.................... #bit    RC6 = PORTC.6 
.................... #bit    RC7 = PORTC.7 
.................... #byte PORTB = 0xF81 
.................... #byte PORTA = 0xF80 
.................... #bit    RA0 = PORTA.0 
.................... #bit    RA1 = PORTA.1 
.................... #bit    RA2 = PORTA.2 
.................... #bit    RA3 = PORTA.3 
.................... #bit    RA4 = PORTA.4 
.................... #bit    RA5 = PORTA.5 
.................... #bit    RA6 = PORTA.6 
.................... #bit    RA7 = PORTA.7 
.................... #byte TRISVP = 0xF73 
.................... #byte LATVP = 0xF72 
.................... #byte PORTVP = 0xF71 
.................... #byte WPUB = 0xF62 
.................... #byte ALRMVALH = 0xF59 
.................... #byte ALRMVALL = 0xF58 
.................... #byte ANCFG = 0xF01 
.................... #bit    VBGEN = ANCFG.0 
.................... #bit    VBG2EN = ANCFG.1 
.................... #bit    VBG6EN = ANCFG.2 
.................... #byte ODCON1 = 0xEEB 
.................... #bit    SSP1OD = ODCON1.0 
.................... #bit    SSP2OD = ODCON1.1 
.................... #bit    USART1OD = ODCON1.2 
.................... #bit    USART2OD = ODCON1.3 
.................... #bit    USART3OD = ODCON1.4 
.................... #bit    USART4OD = ODCON1.5 
.................... #bit    ECCP1OD = ODCON1.6 
.................... #bit    ECCP2OD = ODCON1.7 
.................... #byte ODCON2 = 0xEEA 
.................... #bit    ECCP3OD = ODCON2.0 
.................... #bit    CCP4OD = ODCON2.1 
.................... #bit    CCP5OD = ODCON2.2 
.................... #bit    CCP6OD = ODCON2.3 
.................... #bit    CCP7OD = ODCON2.4 
.................... #bit    CCP8OD = ODCON2.5 
.................... #bit    CCP9OD = ODCON2.6 
.................... #bit    CCP10OD = ODCON2.7 
.................... #byte ADCON2H = 0xE8D 
.................... #bit    CHPS0 = ADCON2H.0 
.................... #bit    CHPS1 = ADCON2H.1 
.................... #bit    CSCNA = ADCON2H.2 
.................... #bit    BUFREGEN = ADCON2H.3 
.................... #bit    OFFCAL = ADCON2H.4 
.................... #bit    NVCFG0 = ADCON2H.5 
.................... #bit    PVCFG0 = ADCON2H.6 
.................... #bit    PVCFG1 = ADCON2H.7 
.................... #byte ADCON2L = 0xE8C 
.................... #bit    ALTS = ADCON2L.0 
.................... #bit    BUFM = ADCON2L.1 
.................... #bit    SMPI0 = ADCON2L.2 
.................... #bit    SMPI1 = ADCON2L.3 
.................... #bit    SMPI2 = ADCON2L.4 
.................... #bit    SMPI3 = ADCON2L.5 
.................... #bit    SMPI4 = ADCON2L.6 
.................... #bit    BUFS = ADCON2L.7 
.................... #byte ADCON3H = 0xE8B 
.................... #bit    SAMC0 = ADCON3H.0 
.................... #bit    SAMC1 = ADCON3H.1 
.................... #bit    SAMC2 = ADCON3H.2 
.................... #bit    SAMC3 = ADCON3H.3 
.................... #bit    SAMC4 = ADCON3H.4 
.................... #bit    PUMPEN = ADCON3H.5 
.................... #bit    EXTSAM = ADCON3H.6 
.................... #bit    ADRC = ADCON3H.7 
.................... #byte ADCON3L = 0xE8A 
.................... #byte ADCON5H = 0xE89 
.................... #bit    ASINTMD0 = ADCON5H.0 
.................... #bit    ASINTMD1 = ADCON5H.1 
.................... #bit    VREGSREQ = ADCON5H.3 
.................... #bit    BGREQ = ADCON5H.4 
.................... #bit    CTMUREQ = ADCON5H.5 
.................... #bit    LPENA = ADCON5H.6 
.................... #bit    ASENA = ADCON5H.7 
.................... #byte ADCON5L = 0xE88 
.................... #bit    CM0 = ADCON5L.0 
.................... #bit    CM1 = ADCON5L.1 
.................... #bit    WM0 = ADCON5L.2 
.................... #bit    WM1 = ADCON5L.3 
.................... #byte ADCHS0H = 0xE87 
.................... #bit    CH0SB0 = ADCHS0H.0 
.................... #bit    CH0SB1 = ADCHS0H.1 
.................... #bit    CH0SB2 = ADCHS0H.2 
.................... #bit    CH0SB3 = ADCHS0H.3 
.................... #bit    CH0SB4 = ADCHS0H.4 
.................... #bit    CH0NB0 = ADCHS0H.5 
.................... #bit    CH0NB1 = ADCHS0H.6 
.................... #bit    CH0NB2 = ADCHS0H.7 
.................... #byte ADCHS0L = 0xE86 
.................... #bit    CH0SA0 = ADCHS0L.0 
.................... #bit    CH0SA1 = ADCHS0L.1 
.................... #bit    CH0SA2 = ADCHS0L.2 
.................... #bit    CH0SA3 = ADCHS0L.3 
.................... #bit    CH0SA4 = ADCHS0L.4 
.................... #bit    CH0NA0 = ADCHS0L.5 
.................... #bit    CH0NA1 = ADCHS0L.6 
.................... #bit    CH0NA2 = ADCHS0L.7 
.................... #byte ADCSS1H = 0xE85 
.................... #bit    CSS24 = ADCSS1H.0 
.................... #bit    CSS25 = ADCSS1H.1 
.................... #bit    CSS26 = ADCSS1H.2 
.................... #bit    CSS27 = ADCSS1H.3 
.................... #bit    CSS28 = ADCSS1H.4 
.................... #bit    CSS29 = ADCSS1H.5 
.................... #bit    CSS30 = ADCSS1H.6 
.................... #bit    CSS31 = ADCSS1H.7 
.................... #byte ADCSS1L = 0xE84 
.................... #bit    CSS16 = ADCSS1L.0 
.................... #bit    CSS17 = ADCSS1L.1 
.................... #bit    CSS18 = ADCSS1L.2 
.................... #bit    CSS19 = ADCSS1L.3 
.................... #bit    CSS20 = ADCSS1L.4 
.................... #bit    CSS21 = ADCSS1L.5 
.................... #bit    CSS22 = ADCSS1L.6 
.................... #bit    CSS23 = ADCSS1L.7 
.................... #byte ADCSS0H = 0xE83 
.................... #bit    CSS8 = ADCSS0H.0 
.................... #bit    CSS9 = ADCSS0H.1 
.................... #bit    CSS10 = ADCSS0H.2 
.................... #bit    CSS11 = ADCSS0H.3 
.................... #bit    CSS12 = ADCSS0H.4 
.................... #bit    CSS13 = ADCSS0H.5 
.................... #bit    CSS14 = ADCSS0H.6 
.................... #bit    CSS15 = ADCSS0H.7 
.................... #byte ADCSS0L = 0xE82 
.................... #byte ADCHIT1H = 0xE81 
.................... #bit    CHH24 = ADCHIT1H.0 
.................... #bit    CHH25 = ADCHIT1H.1 
.................... #bit    CHH26 = ADCHIT1H.2 
.................... #bit    CHH27 = ADCHIT1H.3 
.................... #bit    CHH28 = ADCHIT1H.4 
.................... #bit    CHH29 = ADCHIT1H.5 
.................... #bit    CHH30 = ADCHIT1H.6 
.................... #bit    CHH31 = ADCHIT1H.7 
.................... #byte ADCHIT1L = 0xE80 
.................... #bit    CHH16 = ADCHIT1L.0 
.................... #bit    CHH17 = ADCHIT1L.1 
.................... #bit    CHH18 = ADCHIT1L.2 
.................... #bit    CHH19 = ADCHIT1L.3 
.................... #bit    CHH20 = ADCHIT1L.4 
.................... #bit    CHH21 = ADCHIT1L.5 
.................... #bit    CHH22 = ADCHIT1L.6 
.................... #bit    CHH23 = ADCHIT1L.7 
.................... #byte ADCHIT0H = 0xE7F 
.................... #bit    CHH8 = ADCHIT0H.0 
.................... #bit    CHH9 = ADCHIT0H.1 
.................... #bit    CHH10 = ADCHIT0H.2 
.................... #bit    CHH11 = ADCHIT0H.3 
.................... #bit    CHH12 = ADCHIT0H.4 
.................... #bit    CHH13 = ADCHIT0H.5 
.................... #bit    CHH14 = ADCHIT0H.6 
.................... #bit    CHH15 = ADCHIT0H.7 
.................... #byte ADCHIT0L = 0xE7E 
.................... #byte ADCTMUEN1H = 0xE7D 
.................... #bit    CTUMEN24 = ADCTMUEN1H.0 
.................... #bit    CTUMEN25 = ADCTMUEN1H.1 
.................... #bit    CTUMEN26 = ADCTMUEN1H.2 
.................... #bit    CTUMEN27 = ADCTMUEN1H.3 
.................... #bit    CTUMEN28 = ADCTMUEN1H.4 
.................... #bit    CTUMEN29 = ADCTMUEN1H.5 
.................... #bit    CTMUEN30 = ADCTMUEN1H.6 
.................... #bit    CTMUEN31 = ADCTMUEN1H.7 
.................... #byte ADCTMUEN1L = 0xE7C 
.................... #bit    CTUMEN16 = ADCTMUEN1L.0 
.................... #bit    CTUMEN17 = ADCTMUEN1L.1 
.................... #bit    CTUMEN18 = ADCTMUEN1L.2 
.................... #bit    CTUMEN19 = ADCTMUEN1L.3 
.................... #bit    CTMUEN20 = ADCTMUEN1L.4 
.................... #bit    CTMUEN21 = ADCTMUEN1L.5 
.................... #bit    CTMUEN22 = ADCTMUEN1L.6 
.................... #bit    CTMUEN23 = ADCTMUEN1L.7 
.................... #byte ADCTMUEN0H = 0xE7B 
.................... #bit    CTMUEN8 = ADCTMUEN0H.0 
.................... #bit    CTMUEN9 = ADCTMUEN0H.1 
.................... #bit    CTMUEN10 = ADCTMUEN0H.2 
.................... #bit    CTMUEN11 = ADCTMUEN0H.3 
.................... #bit    CTMUEN12 = ADCTMUEN0H.4 
.................... #bit    CTMUEN13 = ADCTMUEN0H.5 
.................... #bit    CTMUEN14 = ADCTMUEN0H.6 
.................... #bit    CTMUEN15 = ADCTMUEN0H.7 
.................... #byte ADCTMUEN0L = 0xE7A 
.................... #byte ADCBUF25H = 0xE79 
.................... #byte ADCBUF25L = 0xE78 
.................... #byte ADCBUF24H = 0xE77 
.................... #byte ADCBUF24L = 0xE76 
.................... #byte ADCBUF23H = 0xE75 
.................... #byte ADCBUF23L = 0xE74 
.................... #byte ADCBUF22H = 0xE73 
.................... #byte ADCBUF22L = 0xE72 
.................... #byte ADCBUF21H = 0xE71 
.................... #byte ADCBUF21L = 0xE70 
.................... #byte ADCBUF20H = 0xE6F 
.................... #byte ADCBUF20L = 0xE6E 
.................... #byte ADCBUF19H = 0xE6D 
.................... #byte ADCBUF19L = 0xE6C 
.................... #byte ADCBUF18H = 0xE6B 
.................... #byte ADCBUF18L = 0xE6A 
.................... #byte ADCBUF17H = 0xE69 
.................... #byte ADCBUF17L = 0xE68 
.................... #byte ADCBUF16H = 0xE67 
.................... #byte ADCBUF16L = 0xE66 
.................... #byte ADCBUF15H = 0xE65 
.................... #byte ADCBUF15L = 0xE64 
.................... #byte ADCBUF14H = 0xE63 
.................... #byte ADCBUF14L = 0xE62 
.................... #byte ADCBUF13H = 0xE61 
.................... #byte ADCBUF13L = 0xE60 
.................... #byte ADCBUF12H = 0xE5F 
.................... #byte ADCBUF12L = 0xE5E 
.................... #byte ADCBUF11H = 0xE5D 
.................... #byte ADCBUF11L = 0xE5C 
.................... #byte ADCBUF10H = 0xE5B 
.................... #byte ADCBUF10L = 0xE5A 
.................... #byte ADCBUF9H = 0xE59 
.................... #byte ADCBUF9L = 0xE58 
.................... #byte ADCBUF8H = 0xE57 
.................... #byte ADCBUF8L = 0xE56 
.................... #byte ADCBUF7H = 0xE55 
.................... #byte ADCBUF7L = 0xE54 
.................... #byte ADCBUF6H = 0xE53 
.................... #byte ADCBUF6L = 0xE52 
.................... #byte ADCBUF5H = 0xE51 
.................... #byte ADCBUF5L = 0xE50 
.................... #byte ADCBUF4H = 0xE4F 
.................... #byte ADCBUF4L = 0xE4E 
.................... #byte ADCBUF3H = 0xE4D 
.................... #byte ADCBUF3L = 0xE4C 
.................... #byte ADCBUF2H = 0xE4B 
.................... #byte ADCBUF2L = 0xE4A 
.................... #byte ADCBUF1H = 0xE49 
.................... #byte ADCBUF1L = 0xE48 
.................... #byte ANCON1 = 0xE47 
.................... #byte ANCON2 = 0xE46 
.................... #bit    ANSEL8 = ANCON2.0 
.................... #bit    ANSEL9 = ANCON2.1 
.................... #bit    ANSEL10 = ANCON2.2 
.................... #bit    ANSEL11 = ANCON2.3 
.................... #bit    ANSEL12 = ANCON2.4 
.................... #bit    ANSEL13 = ANCON2.5 
.................... #bit    ANSEL14 = ANCON2.6 
.................... #bit    ANSEL15 = ANCON2.7 
.................... #byte ANCON3 = 0xE45 
.................... #bit    ANSEL16 = ANCON3.0 
.................... #bit    ANSEL17 = ANCON3.1 
.................... #bit    ANSEL18 = ANCON3.2 
.................... #bit    ANSEL19 = ANCON3.3 
.................... #bit    ANSEL20 = ANCON3.4 
.................... #bit    ANSEL21 = ANCON3.5 
.................... #bit    ANSEL22 = ANCON3.6 
.................... #bit    ANSEL23 = ANCON3.7 
....................  
....................  
.................... #device HIGH_INTS=TRUE 
....................  
.................... //-------------UART and SPI Setting-------------------------------------------------------------------------------------- 
....................  
.................... #pin_select TX1=PIN_C6                                                           //TX PIN EXT +/- 6v 
.................... #pin_select RX1=PIN_C7                                                           //RX PIN EXT +/- 6V 
.................... #use rs232(baud=115200,parity=N,UART1,bits=8,stream=pc)                      // MAIN to Ext +/- 6v 
....................  
.................... #pin_select TX2=PIN_D3 
.................... #pin_select RX2=PIN_D2 
.................... #use rs232(baud=9600,parity=N,UART2,bits=8,stream=com,ERRORS)                           //UART Main to COM PIC 
....................  
.................... #pin_select TX4=PIN_E3   
.................... #pin_select RX4=PIN_F2 
.................... #use rs232(baud=9600,parity=N,UART4,bits=8,stream=reset,ERRORS)                         //UART MAIN to RESET PIC 
*
00694:  BTFSS  FA6.7
00696:  BRA    0694
00698:  MOVLB  E
0069A:  MOVFF  EFF,1B
0069E:  MOVFF  EFA,01
006A2:  BTFSS  1B.1
006A4:  BRA    06AA
006A6:  BCF    xFF.4
006A8:  BSF    xFF.4
006AA:  MOVLB  0
006AC:  GOTO   06F6 (RETURN)
*
00C24:  BTFSS  FA6.6
00C26:  BRA    0C24
00C28:  MOVLB  E
00C2A:  MOVWF  xF9
00C2C:  MOVLB  0
00C2E:  GOTO   0C86 (RETURN)
....................  
.................... #pin_select TX3=PIN_E5   
.................... #pin_select RX3=PIN_E4 
.................... #use rs232(baud=9600,parity=N,UART3,bits=8,stream=fab,ERRORS)                           //UART MAIN to FAB PIC 
*
007DA:  BTFSS  FA6.5
007DC:  BRA    07DA
007DE:  MOVLB  F
007E0:  MOVFF  F2F,1B
007E4:  MOVFF  F2A,01
007E8:  BTFSS  1B.1
007EA:  BRA    07F0
007EC:  BCF    x2F.4
007EE:  BSF    x2F.4
007F0:  MOVLB  0
007F2:  GOTO   0E28 (RETURN)
*
008B0:  BTFSS  FA6.4
008B2:  BRA    08B0
008B4:  MOVLB  F
008B6:  MOVWF  x29
008B8:  MOVLB  0
008BA:  RETURN 0
....................  
....................  
.................... #use rs232(baud=9600,parity=N,xmit=pin_G2,rcv=pin_G3,bits=8,stream=IMGCLS,ERRORS)       //UART MAIN to IMGCLS 
.................... #use rs232(baud=9600,parity=N,xmit=pin_G0,rcv=pin_G1,bits=8,stream=DC,ERRORS)           //UART MAIN to MB DCM 
*
00B6E:  BCF    F98.0
00B70:  BCF    F8F.0
00B72:  MOVLW  08
00B74:  MOVWF  01
00B76:  BRA    0B78
00B78:  NOP   
00B7A:  BSF    01.7
00B7C:  BRA    0B9E
00B7E:  BCF    01.7
00B80:  MOVLB  2
00B82:  RRCF   x10,F
00B84:  MOVLB  0
00B86:  BTFSC  FD8.0
00B88:  BSF    F8F.0
00B8A:  BTFSS  FD8.0
00B8C:  BCF    F8F.0
00B8E:  BSF    01.6
00B90:  BRA    0B9E
00B92:  BCF    01.6
00B94:  DECFSZ 01,F
00B96:  BRA    0B80
00B98:  BRA    0B9A
00B9A:  NOP   
00B9C:  BSF    F8F.0
00B9E:  MOVLW  84
00BA0:  MOVWF  FE9
00BA2:  DECFSZ FE9,F
00BA4:  BRA    0BA2
00BA6:  BRA    0BA8
00BA8:  NOP   
00BAA:  BTFSC  01.7
00BAC:  BRA    0B7E
00BAE:  BTFSC  01.6
00BB0:  BRA    0B92
00BB2:  RETURN 0
00BB4:  BSF    F98.1
00BB6:  BTFSC  F86.1
00BB8:  BRA    0BB6
00BBA:  MOVLW  08
00BBC:  MOVWF  00
00BBE:  MOVLB  2
00BC0:  CLRF   x0B
00BC2:  BSF    00.7
00BC4:  BRA    0BE2
00BC6:  BCF    00.7
00BC8:  BRA    0BE2
00BCA:  BCF    FD8.0
00BCC:  BTFSC  F86.1
00BCE:  BSF    FD8.0
00BD0:  RRCF   x0B,F
00BD2:  BSF    00.6
00BD4:  BRA    0BE2
00BD6:  BCF    00.6
00BD8:  DECFSZ 00,F
00BDA:  BRA    0BCA
00BDC:  MOVFF  20B,01
00BE0:  BRA    0BFA
00BE2:  MOVLW  84
00BE4:  BTFSC  00.7
00BE6:  MOVLW  24
00BE8:  MOVWF  01
00BEA:  DECFSZ 01,F
00BEC:  BRA    0BEA
00BEE:  BRA    0BF0
00BF0:  BTFSC  00.7
00BF2:  BRA    0BC6
00BF4:  BTFSC  00.6
00BF6:  BRA    0BD6
00BF8:  BRA    0BCA
00BFA:  MOVLB  0
00BFC:  GOTO   1374 (RETURN)
....................  
....................  
.................... #use spi(MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6,  BAUD=1000000, BITS=8, STREAM=MAIN_FM, MODE=0)        //MAIN flash memory port 
.................... #use spi(MASTER, CLK=PIN_B2, DI=PIN_B5, DO=PIN_B4,  BAUD=1000000, BITS=8, STREAM=COM_FM, MODE=0)         //COM flash memory port 
.................... #use spi(MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1,  BAUD=1000000, BITS=8, STREAM=MISSION_FM, MODE=0)     //MISSION flash memory port 
*
007F6:  MOVLB  2
007F8:  MOVF   x1E,W
007FA:  SUBLW  08
007FC:  BZ    0806
007FE:  MOVWF  x1F
00800:  RLCF   x1D,F
00802:  DECFSZ x1F,F
00804:  BRA    0800
00806:  BSF    F92.0
00808:  BCF    F92.1
0080A:  BCF    F92.3
0080C:  BCF    F89.3
0080E:  MOVFF  21E,21F
00812:  BTFSS  x1D.7
00814:  BCF    F89.1
00816:  BTFSC  x1D.7
00818:  BSF    F89.1
0081A:  RLCF   x1D,F
0081C:  BSF    F89.3
0081E:  RLCF   01,F
00820:  BTFSS  F80.0
00822:  BCF    01.0
00824:  BTFSC  F80.0
00826:  BSF    01.0
00828:  BCF    F89.3
0082A:  DECFSZ x1F,F
0082C:  BRA    0812
0082E:  MOVLB  0
00830:  RETURN 0
....................  
.................... //--------------Pin Assignment--------------------------------------------------------------------------------------------- 
.................... #define sel PIN_D6 
.................... #define hvs PIN_D7 
.................... #define PINO_POWER PIN_D5 
....................  
....................  
.................... //-------------mainpic_function.c----------------------------------------------------------------------------------------- 
....................  
.................... void Check_UART(); 
.................... void waiting(int32 counterval); 
....................  
.................... /////////////CAM MISSION///////////// 
.................... void Turn_On_CAM(); 
.................... void Turn_Off_CAM(); 
....................  
.................... /////////////RESET SENSOR collection///////////// 
.................... void COLLECT_RESET_DATA(); 
....................  
.................... /////////////Testing Stuff///////////// 
.................... void Flash_Memory_Access(); 
.................... void PINO_test(); 
.................... void GET_RESET_DATA(); 
....................  
....................  
.................... #include <mainpic_function.h> 
.................... #include<flash_ memory_ MT25QL01GBBB_OF.c> //all flash memory 
.................... #define SPIPORT MAIN_FM 
.................... #define SPIPORT_2 COM_FM 
.................... #define SPIPORT_3 MISSION_FM 
....................  
.................... #define CS_PIN PIN_E2 
.................... #define CS_PIN_2 PIN_B3 
.................... #define CS_PIN_3 PIN_A2 
....................  
.................... #define READ_ID              0x9F 
.................... #define READ_STATUS_REG      0x05  
.................... #define READ_DATA_BYTES      0x13  //0x03 for byte 
.................... #define ENABLE_WRITE         0x06 
.................... #define WRITE_PAGE           0x12  //0x02 for 3byte 
.................... #define ERASE_SECTOR         0xDC  //0xD8 for 3byte 
.................... #define ERASE_4KB_SUBSECTOR  0x21 
.................... #define ERASE_32KB_SUBSECTOR 0x5C 
.................... #define DIE_ERASE            0xC4 
....................  
....................  
....................  
.................... void WRITE_ENABLE_OF(){ 
....................  output_low(CS_PIN); 
....................   
....................  ///////////////////////////////////////////////////////////// 
....................  //delay_ms(2); 
....................  spi_xfer(SPIPORT,ENABLE_WRITE);                //Send 0x06 
....................  ///////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN);   
....................  return; 
.................... } 
....................  
....................  
.................... void WRITE_ENABLE_SCF(){ 
....................  output_low(CS_PIN_2); 
....................   
....................  ///////////////////////////////////////////////////////////// 
....................  //delay_ms(2); 
....................  spi_xfer(SPIPORT_2,ENABLE_WRITE);                //Send 0x06 
....................  ///////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_2);   
....................  return; 
.................... } 
....................  
....................  
.................... void WRITE_ENABLE_SMF(){ 
....................  output_low(CS_PIN_3); 
*
0092E:  BCF    F92.2
00930:  BCF    F89.2
....................   
....................  ///////////////////////////////////////////////////////////// 
....................  //delay_ms(2); 
....................  spi_xfer(SPIPORT_3,ENABLE_WRITE);                //Send 0x06 
00932:  MOVLW  06
00934:  MOVLB  2
00936:  MOVWF  x1D
00938:  MOVLW  08
0093A:  MOVWF  x1E
0093C:  MOVLB  0
0093E:  RCALL  07F6
....................  ///////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_3);   
00940:  BCF    F92.2
00942:  BSF    F89.2
....................  return; 
00944:  RETURN 0
.................... } 
....................  
....................  
.................... void sector_erase_OF(unsigned int32 sector_address)                              //borra un sector de la flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_OF(); 
....................    output_low(CS_PIN);                                                           //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT,ERASE_SECTOR);                                               //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT,adsress[0]);    
....................    spi_xfer(SPIPORT,adsress[1]);     
....................    spi_xfer(SPIPORT,adsress[2]);     
....................    spi_xfer(SPIPORT,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN);                                                          //take CS PIN higher back 
....................    //delay_ms(1000); 
....................    delay_ms(750); 
....................     
....................    return; 
.................... } 
....................  
....................  
.................... void sector_erase_SCF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_SCF(); 
....................    output_low(CS_PIN_2);                                                         //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_2,ERASE_SECTOR);                                             //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT_2,adsress[0]);    
....................    spi_xfer(SPIPORT_2,adsress[1]);     
....................    spi_xfer(SPIPORT_2,adsress[2]);     
....................    spi_xfer(SPIPORT_2,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN_2);                                                        //take CS PIN higher back 
....................    //delay_ms(1000); 
....................    delay_ms(750); 
....................     
....................    return; 
.................... } 
....................  
....................  
.................... void sector_erase_SMF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
00946:  MOVLB  2
00948:  MOVFF  20A,20B
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
0094C:  MOVFF  209,20C
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
00950:  MOVFF  208,20D
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);       // 0x 00 00 00 _ _ 
00954:  MOVFF  207,20E
....................     
....................     
....................    WRITE_ENABLE_SMF(); 
00958:  MOVLB  0
0095A:  RCALL  092E
....................    output_low(CS_PIN_3);             //lower the CS PIN 
0095C:  BCF    F92.2
0095E:  BCF    F89.2
....................    delay_us(2); 
00960:  MOVLW  02
00962:  MOVWF  00
00964:  DECFSZ 00,F
00966:  BRA    0964
00968:  NOP   
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,ERASE_SECTOR); //SECTOR ERASE COMAND   (0xDC) 
0096A:  MOVLW  DC
0096C:  MOVLB  2
0096E:  MOVWF  x1D
00970:  MOVLW  08
00972:  MOVWF  x1E
00974:  MOVLB  0
00976:  RCALL  07F6
....................     
....................    spi_xfer(SPIPORT_3,adsress[0]);    
00978:  MOVFF  20B,21D
0097C:  MOVLW  08
0097E:  MOVLB  2
00980:  MOVWF  x1E
00982:  MOVLB  0
00984:  RCALL  07F6
....................    spi_xfer(SPIPORT_3,adsress[1]);     
00986:  MOVFF  20C,21D
0098A:  MOVLW  08
0098C:  MOVLB  2
0098E:  MOVWF  x1E
00990:  MOVLB  0
00992:  RCALL  07F6
....................    spi_xfer(SPIPORT_3,adsress[2]);     
00994:  MOVFF  20D,21D
00998:  MOVLW  08
0099A:  MOVLB  2
0099C:  MOVWF  x1E
0099E:  MOVLB  0
009A0:  RCALL  07F6
....................    spi_xfer(SPIPORT_3,adsress[3]); 
009A2:  MOVFF  20E,21D
009A6:  MOVLW  08
009A8:  MOVLB  2
009AA:  MOVWF  x1E
009AC:  MOVLB  0
009AE:  RCALL  07F6
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
009B0:  MOVLW  02
009B2:  MOVWF  00
009B4:  DECFSZ 00,F
009B6:  BRA    09B4
009B8:  NOP   
....................    output_high(CS_PIN_3);           //take CS PIN higher back 
009BA:  BCF    F92.2
009BC:  BSF    F89.2
....................    //delay_ms(1000);   
....................    delay_ms(750); 
009BE:  MOVLW  03
009C0:  MOVLB  2
009C2:  MOVWF  x0F
009C4:  MOVLW  FA
009C6:  MOVWF  x10
009C8:  MOVLB  0
009CA:  RCALL  0782
009CC:  MOVLB  2
009CE:  DECFSZ x0F,F
009D0:  BRA    09C4
....................    return; 
009D2:  MOVLB  0
009D4:  RETURN 0
.................... } 
....................  
....................  
.................... void SUBSECTOR_4KB_ERASE_OF(unsigned int32 sector_address)                       //Funcion que borra un sector de 4KB de la Main Flash 
.................... {                                                                                //Recibe la direccion del sector que se quiere borrar 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_OF();                                                            //Funcion que habilita escritura en Own Flash 
....................    output_low(CS_PIN);                                                           //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT,ERASE_4KB_SUBSECTOR);                                        //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT,adsress[0]);                                                 //Se le pasa la direccion del sector a borrar 
....................    spi_xfer(SPIPORT,adsress[1]);     
....................    spi_xfer(SPIPORT,adsress[2]);     
....................    spi_xfer(SPIPORT,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN);                                                          //take CS PIN higher back 
....................    delay_ms(100);   
....................     
....................    return; 
.................... } 
....................  
....................  
.................... void SUBSECTOR_4KB_ERASE_SCF(unsigned int32 sector_address)                      //Funcion que borra un sector de 4KB de la COM Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_SCF();                                                           //Funcion que habilita escritura en COM Flash 
....................    output_low(CS_PIN_2);                                                         //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_2,ERASE_4KB_SUBSECTOR); //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT_2,adsress[0]);    
....................    spi_xfer(SPIPORT_2,adsress[1]);     
....................    spi_xfer(SPIPORT_2,adsress[2]);     
....................    spi_xfer(SPIPORT_2,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN_2);                                                        //take CS PIN higher back 
....................    delay_ms(10);   
....................     
....................    return; 
.................... } 
....................  
....................  
.................... void SUBSECTOR_4KB_ERASE_SMF(unsigned int32 sector_address)                      //Funcion que borra un sector de 4KB de la Mission Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
*
00A4A:  MOVLB  2
00A4C:  MOVFF  20A,20B
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
00A50:  MOVFF  209,20C
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
00A54:  MOVFF  208,20D
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
00A58:  MOVFF  207,20E
....................     
....................     
....................    WRITE_ENABLE_SMF();                                                           //Funcion que habilita escritura en Mission Flash 
00A5C:  MOVLB  0
00A5E:  RCALL  092E
....................    output_low(CS_PIN_3);                                                         //lower the CS PIN 
00A60:  BCF    F92.2
00A62:  BCF    F89.2
....................    delay_us(2); 
00A64:  MOVLW  02
00A66:  MOVWF  00
00A68:  DECFSZ 00,F
00A6A:  BRA    0A68
00A6C:  NOP   
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,ERASE_4KB_SUBSECTOR);                                      //SECTOR ERASE COMAND   (0xDC) 
00A6E:  MOVLW  21
00A70:  MOVLB  2
00A72:  MOVWF  x1D
00A74:  MOVLW  08
00A76:  MOVWF  x1E
00A78:  MOVLB  0
00A7A:  RCALL  07F6
....................     
....................    spi_xfer(SPIPORT_3,adsress[0]);    
00A7C:  MOVFF  20B,21D
00A80:  MOVLW  08
00A82:  MOVLB  2
00A84:  MOVWF  x1E
00A86:  MOVLB  0
00A88:  RCALL  07F6
....................    spi_xfer(SPIPORT_3,adsress[1]);     
00A8A:  MOVFF  20C,21D
00A8E:  MOVLW  08
00A90:  MOVLB  2
00A92:  MOVWF  x1E
00A94:  MOVLB  0
00A96:  RCALL  07F6
....................    spi_xfer(SPIPORT_3,adsress[2]);     
00A98:  MOVFF  20D,21D
00A9C:  MOVLW  08
00A9E:  MOVLB  2
00AA0:  MOVWF  x1E
00AA2:  MOVLB  0
00AA4:  RCALL  07F6
....................    spi_xfer(SPIPORT_3,adsress[3]); 
00AA6:  MOVFF  20E,21D
00AAA:  MOVLW  08
00AAC:  MOVLB  2
00AAE:  MOVWF  x1E
00AB0:  MOVLB  0
00AB2:  RCALL  07F6
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
00AB4:  MOVLW  02
00AB6:  MOVWF  00
00AB8:  DECFSZ 00,F
00ABA:  BRA    0AB8
00ABC:  NOP   
....................    output_high(CS_PIN_3);                                                        //take CS PIN higher back 
00ABE:  BCF    F92.2
00AC0:  BSF    F89.2
....................    delay_ms(1000);   
00AC2:  MOVLW  04
00AC4:  MOVLB  2
00AC6:  MOVWF  x0F
00AC8:  MOVLW  FA
00ACA:  MOVWF  x10
00ACC:  MOVLB  0
00ACE:  RCALL  0782
00AD0:  MOVLB  2
00AD2:  DECFSZ x0F,F
00AD4:  BRA    0AC8
....................     
....................    return; 
00AD6:  MOVLB  0
00AD8:  GOTO   11DE (RETURN)
.................... } 
....................  
....................  
.................... void SUBSECTOR_32KB_ERASE_OF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_OF(); 
....................    output_low(CS_PIN);             //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT,ERASE_32KB_SUBSECTOR); //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT,adsress[0]);    
....................    spi_xfer(SPIPORT,adsress[1]);     
....................    spi_xfer(SPIPORT,adsress[2]);     
....................    spi_xfer(SPIPORT,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN);           //take CS PIN higher back 
....................    delay_ms(1000);   
....................     
....................    return; 
.................... } 
....................  
....................  
.................... void SUBSECTOR_32KB_ERASE_SCF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_SCF(); 
....................    output_low(CS_PIN_2);             //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_2,ERASE_32KB_SUBSECTOR); //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT_2,adsress[0]);    
....................    spi_xfer(SPIPORT_2,adsress[1]);     
....................    spi_xfer(SPIPORT_2,adsress[2]);     
....................    spi_xfer(SPIPORT_2,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN_2);           //take CS PIN higher back 
....................    delay_ms(1000);   
....................     
....................    return; 
.................... } 
....................  
....................  
.................... void SUBSECTOR_32KB_ERASE_SMF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
00ADC:  MOVLB  2
00ADE:  MOVFF  20A,20B
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
00AE2:  MOVFF  209,20C
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
00AE6:  MOVFF  208,20D
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);       // 0x 00 00 00 _ _ 
00AEA:  MOVFF  207,20E
....................     
....................     
....................    WRITE_ENABLE_SMF(); 
00AEE:  MOVLB  0
00AF0:  RCALL  092E
....................    output_low(CS_PIN_3);             //lower the CS PIN 
00AF2:  BCF    F92.2
00AF4:  BCF    F89.2
....................    delay_us(2); 
00AF6:  MOVLW  02
00AF8:  MOVWF  00
00AFA:  DECFSZ 00,F
00AFC:  BRA    0AFA
00AFE:  NOP   
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,ERASE_32KB_SUBSECTOR); //SECTOR ERASE COMAND   (0xDC) 
00B00:  MOVLW  5C
00B02:  MOVLB  2
00B04:  MOVWF  x1D
00B06:  MOVLW  08
00B08:  MOVWF  x1E
00B0A:  MOVLB  0
00B0C:  RCALL  07F6
....................     
....................    spi_xfer(SPIPORT_3,adsress[0]);    
00B0E:  MOVFF  20B,21D
00B12:  MOVLW  08
00B14:  MOVLB  2
00B16:  MOVWF  x1E
00B18:  MOVLB  0
00B1A:  RCALL  07F6
....................    spi_xfer(SPIPORT_3,adsress[1]);     
00B1C:  MOVFF  20C,21D
00B20:  MOVLW  08
00B22:  MOVLB  2
00B24:  MOVWF  x1E
00B26:  MOVLB  0
00B28:  RCALL  07F6
....................    spi_xfer(SPIPORT_3,adsress[2]);     
00B2A:  MOVFF  20D,21D
00B2E:  MOVLW  08
00B30:  MOVLB  2
00B32:  MOVWF  x1E
00B34:  MOVLB  0
00B36:  RCALL  07F6
....................    spi_xfer(SPIPORT_3,adsress[3]); 
00B38:  MOVFF  20E,21D
00B3C:  MOVLW  08
00B3E:  MOVLB  2
00B40:  MOVWF  x1E
00B42:  MOVLB  0
00B44:  RCALL  07F6
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
00B46:  MOVLW  02
00B48:  MOVWF  00
00B4A:  DECFSZ 00,F
00B4C:  BRA    0B4A
00B4E:  NOP   
....................    output_high(CS_PIN_3);           //take CS PIN higher back 
00B50:  BCF    F92.2
00B52:  BSF    F89.2
....................    delay_ms(1000);   
00B54:  MOVLW  04
00B56:  MOVLB  2
00B58:  MOVWF  x0F
00B5A:  MOVLW  FA
00B5C:  MOVWF  x10
00B5E:  MOVLB  0
00B60:  RCALL  0782
00B62:  MOVLB  2
00B64:  DECFSZ x0F,F
00B66:  BRA    0B5A
....................     
....................    return; 
00B68:  MOVLB  0
00B6A:  GOTO   1202 (RETURN)
.................... } 
....................  
....................  
.................... void ALL_SECTOR_ERASE_OF() 
.................... { 
....................    int32 ADDRESS = 0; 
....................    for(int16 i = 0; i < 2048; i++) 
....................    { 
....................       sector_erase_OF(ADDRESS); 
....................       ADDRESS = ADDRESS + 65536; 
....................    } 
.................... } 
....................  
....................  
.................... void ALL_SECTOR_ERASE_SCF() 
.................... { 
....................    int32 ADRESS = 0; 
....................    for(int16 i = 0; i < 2048; i++) 
....................    { 
....................       sector_erase_SCF(ADRESS); 
....................       ADRESS = ADRESS + 65536; 
....................    } 
.................... } 
....................  
....................  
.................... void ALL_SECTOR_ERASE_SMF() 
.................... { 
....................    int32 ADRESS = 0; 
....................    for(int16 i = 0; i < 2048; i++) 
....................    { 
....................       sector_erase_SMF(ADRESS); 
....................       ADRESS = ADRESS + 65536; 
....................    } 
.................... } 
....................  
....................  
.................... void WRITE_DATA_BYTE_OF(unsigned int32 page_address, int8 data)                  //Funcion que escribe un Byte en la Main Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((page_address>>24) & 0xFF);                     // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((page_address>>16) & 0xFF);                     // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((page_address>>8) & 0xFF);                      // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((page_address) & 0xFF);                         // 0x 00 00 00 _ _ 
....................     
....................    WRITE_ENABLE_OF(); 
....................    output_low(CS_PIN);                                                           //lower the CS PIN 
....................    //delay_us(2); 
....................     
....................    //////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT,WRITE_PAGE);                                                 //PAGE WRITE COMAND  (0x12) 
....................    
....................    spi_xfer(SPIPORT,adsress[0]);     
....................    spi_xfer(SPIPORT,adsress[1]);     
....................    spi_xfer(SPIPORT,adsress[2]);     
....................    spi_xfer(SPIPORT,adsress[3]); 
....................     
....................    spi_xfer(SPIPORT,data);  
....................    //////////////////////////////////////////////////////////////// 
....................     
....................    output_high(CS_PIN);                                                          //take CS PIN higher back 
....................  
....................    //delay_us(5);   
....................     
....................    return; 
.................... } 
....................  
....................  
.................... void WRITE_DATA_BYTE_SCF(unsigned int32 page_address, int8 data)                 //Funcion que escribe un Byte en la COM Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((page_address>>24) & 0xFF);                     // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((page_address>>16) & 0xFF);                     // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((page_address>>8) & 0xFF);                      // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((page_address) & 0xFF);                         // 0x 00 00 00 _ _ 
....................     
....................    WRITE_ENABLE_SCF(); 
....................    output_low(CS_PIN_2);                                                         //lower the CS PIN 
....................    //delay_us(2); 
....................     
....................    //////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_2,WRITE_PAGE);                                               //PAGE WRITE COMAND  (0x12) 
....................    
....................    spi_xfer(SPIPORT_2,adsress[0]);     
....................    spi_xfer(SPIPORT_2,adsress[1]);     
....................    spi_xfer(SPIPORT_2,adsress[2]);     
....................    spi_xfer(SPIPORT_2,adsress[3]); 
....................     
....................    spi_xfer(SPIPORT_2,data);  
....................    //////////////////////////////////////////////////////////////// 
....................     
....................    output_high(CS_PIN_2);                                                        //take CS PIN higher back 
....................  
....................    //delay_us(5);   
....................     
....................    return; 
.................... } 
....................  
....................  
.................... void WRITE_DATA_BYTE_SMF(unsigned int32 page_address, int8 data)                 //Funcion que escribe un Byte en la Mission Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((page_address>>24) & 0xFF);                     // 0x _ _ 00 00 00 
*
009D6:  MOVLB  2
009D8:  MOVFF  20E,210
....................    adsress[1]  = (unsigned int8)((page_address>>16) & 0xFF);                     // 0x 00 _ _ 00 00 
009DC:  MOVFF  20D,211
....................    adsress[2]  = (unsigned int8)((page_address>>8) & 0xFF);                      // 0x 00 00 _ _ 00 
009E0:  MOVFF  20C,212
....................    adsress[3]  = (unsigned int8)((page_address) & 0xFF);                         // 0x 00 00 00 _ _ 
009E4:  MOVFF  20B,213
....................     
....................    WRITE_ENABLE_SMF(); 
009E8:  MOVLB  0
009EA:  RCALL  092E
....................    output_low(CS_PIN_3);                                                         //lower the CS PIN 
009EC:  BCF    F92.2
009EE:  BCF    F89.2
....................    //delay_us(2); 
....................     
....................    //////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,WRITE_PAGE);                                               //PAGE WRITE COMAND  (0x12) 
009F0:  MOVLW  12
009F2:  MOVLB  2
009F4:  MOVWF  x1D
009F6:  MOVLW  08
009F8:  MOVWF  x1E
009FA:  MOVLB  0
009FC:  RCALL  07F6
....................    
....................    spi_xfer(SPIPORT_3,adsress[0]);     
009FE:  MOVFF  210,21D
00A02:  MOVLW  08
00A04:  MOVLB  2
00A06:  MOVWF  x1E
00A08:  MOVLB  0
00A0A:  RCALL  07F6
....................    spi_xfer(SPIPORT_3,adsress[1]);     
00A0C:  MOVFF  211,21D
00A10:  MOVLW  08
00A12:  MOVLB  2
00A14:  MOVWF  x1E
00A16:  MOVLB  0
00A18:  RCALL  07F6
....................    spi_xfer(SPIPORT_3,adsress[2]);     
00A1A:  MOVFF  212,21D
00A1E:  MOVLW  08
00A20:  MOVLB  2
00A22:  MOVWF  x1E
00A24:  MOVLB  0
00A26:  RCALL  07F6
....................    spi_xfer(SPIPORT_3,adsress[3]); 
00A28:  MOVFF  213,21D
00A2C:  MOVLW  08
00A2E:  MOVLB  2
00A30:  MOVWF  x1E
00A32:  MOVLB  0
00A34:  RCALL  07F6
....................     
....................    spi_xfer(SPIPORT_3,data);  
00A36:  MOVFF  20F,21D
00A3A:  MOVLW  08
00A3C:  MOVLB  2
00A3E:  MOVWF  x1E
00A40:  MOVLB  0
00A42:  RCALL  07F6
....................    //////////////////////////////////////////////////////////////// 
....................     
....................    output_high(CS_PIN_3);                                                        //take CS PIN higher back 
00A44:  BCF    F92.2
00A46:  BSF    F89.2
....................  
....................    //delay_us(10);   
....................     
....................    return; 
00A48:  RETURN 0
.................... } 
....................  
....................  
.................... int8 READ_CHIP_ID_OF() 
.................... { 
....................  output_low(CS_PIN);           //lower the CS PIN 
....................   
....................  //////////////////////////////////////////////////////////////// 
....................  int8 chip_id; 
....................  spi_xfer(SPIPORT,READ_ID);    //READ ID COMAND   (0x9F) 
....................  chip_id = spi_xfer(SPIPORT); 
....................  //////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN);         //take CS PIN higher back 
....................  return chip_id; 
.................... } 
....................  
....................  
.................... int8 READ_CHIP_ID_SCF() 
.................... { 
....................  output_low(CS_PIN_2);           //lower the CS PIN 
....................   
....................  //////////////////////////////////////////////////////////////// 
....................  int8 chip_id; 
....................  spi_xfer(SPIPORT_2,READ_ID);    //READ ID COMAND   (0x9F) 
....................  chip_id = spi_xfer(SPIPORT_2); 
....................  //////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_2);         //take CS PIN higher back 
....................  return chip_id; 
.................... } 
....................  
....................  
.................... int8 READ_CHIP_ID_SMF() 
.................... { 
....................  output_low(CS_PIN_3);           //lower the CS PIN 
....................   
....................  //////////////////////////////////////////////////////////////// 
....................  int8 chip_id; 
....................  spi_xfer(SPIPORT_3,READ_ID);    //READ ID COMAND   (0x9F) 
....................  chip_id = spi_xfer(SPIPORT_3); 
....................  //////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_3);         //take CS PIN higher back 
....................  return chip_id; 
.................... } 
....................  
....................  
.................... int8 READ_STATUS_REGISTER_OF() 
.................... { 
....................  output_low(CS_PIN);           //lower the CS PIN 
....................   
....................  ///////////////////////////////////////////////////////////////// 
....................  int8 status_reg; 
....................  spi_xfer(SPIPORT,READ_STATUS_REG); //READ STATUS REGISTER COMAND  (0x05) 
....................  status_reg = spi_xfer(SPIPORT); 
....................  ///////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN);         //take CS PIN higher back 
....................  return status_reg; 
.................... } 
....................  
....................  
.................... int8 READ_STATUS_REGISTER_SCF() 
.................... { 
....................  output_low(CS_PIN_2);           //lower the CS PIN 
....................   
....................  ///////////////////////////////////////////////////////////////// 
....................  int8 status_reg; 
....................  spi_xfer(SPIPORT_2,READ_STATUS_REG); //READ STATUS REGISTER COMAND  (0x05) 
....................  status_reg = spi_xfer(SPIPORT_2); 
....................  ///////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_2);         //take CS PIN higher back 
....................  return status_reg; 
.................... } 
.................... int8 READ_STATUS_REGISTER_SMF() 
.................... { 
....................  output_low(CS_PIN_3);           //lower the CS PIN 
....................   
....................  ///////////////////////////////////////////////////////////////// 
....................  int8 status_reg; 
....................  spi_xfer(SPIPORT_3,READ_STATUS_REG); //READ STATUS REGISTER COMAND  (0x05) 
....................  status_reg = spi_xfer(SPIPORT_3); 
....................  ///////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_3);         //take CS PIN higher back 
....................  return status_reg; 
.................... } 
....................  
....................  
.................... int8 READ_DATA_BYTE_OF(unsigned INT32 ADDRESS) 
.................... { 
....................  
....................  unsigned int8 address_OF[4]; 
....................    //Byte extraction 
....................    address_OF[0]  = (unsigned int8)((ADDRESS>>24) & 0xFF);                          // 0x _ _ 00 00 00 
....................    address_OF[1]  = (unsigned int8)((ADDRESS>>16) & 0xFF);                          // 0x 00 _ _ 00 00 
....................    address_OF[2]  = (unsigned int8)((ADDRESS>>8) & 0xFF);                           // 0x 00 00 _ _ 00 
....................    address_OF[3]  = (unsigned int8)((ADDRESS) & 0xFF);                              // 0x 00 00 00 _ _ 
....................     
....................  output_low(CS_PIN);                                                             //lower the CS PIN 
....................   
....................  ////////////////////////////////////////////////////////////////// 
....................  int8 data; 
....................  spi_xfer(SPIPORT,READ_DATA_BYTES);                                              //READ DATA COMAND   (0x13) 
....................   
....................  spi_xfer(SPIPORT,address_OF[0]); 
....................  spi_xfer(SPIPORT,address_OF[1]); 
....................  spi_xfer(SPIPORT,address_OF[2]); 
....................  spi_xfer(SPIPORT,address_OF[3]); 
....................  data = spi_xfer(SPIPORT); 
....................  ////////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN);                                                            //take CS PIN higher back 
....................  return data; 
....................   
.................... } 
....................  
....................  
.................... int8 READ_DATA_BYTE_SCF(unsigned INT32 ADDRESS) 
.................... { 
....................  
....................  unsigned int8 adsress[4]; 
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((ADDRESS>>24) & 0xFF);                          // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((ADDRESS>>16) & 0xFF);                          // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((ADDRESS>>8) & 0xFF);                           // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((ADDRESS) & 0xFF);                              // 0x 00 00 00 _ _ 
....................     
....................  output_low(CS_PIN_2);                                                           //lower the CS PIN 
....................   
....................  ////////////////////////////////////////////////////////////////// 
....................  int8 data; 
....................  spi_xfer(SPIPORT_2,READ_DATA_BYTES);                                            //READ DATA COMAND   (0x13) 
....................   
....................  spi_xfer(SPIPORT_2,adsress[0]); 
....................  spi_xfer(SPIPORT_2,adsress[1]); 
....................  spi_xfer(SPIPORT_2,adsress[2]); 
....................  spi_xfer(SPIPORT_2,adsress[3]); 
....................  data = spi_xfer(SPIPORT_2); 
....................  ////////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_2);                                                          //take CS PIN higher back 
....................  return data; 
....................   
.................... } 
....................  
....................  
.................... int8 READ_DATA_BYTE_SMF(unsigned INT32 ADDRESS) 
.................... { 
....................  
....................  unsigned int8 adsress[4]; 
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((ADDRESS>>24) & 0xFF);                          // 0x _ _ 00 00 00 
*
00832:  MOVLB  2
00834:  MOVFF  217,218
....................    adsress[1]  = (unsigned int8)((ADDRESS>>16) & 0xFF);                          // 0x 00 _ _ 00 00 
00838:  MOVFF  216,219
....................    adsress[2]  = (unsigned int8)((ADDRESS>>8) & 0xFF);                           // 0x 00 00 _ _ 00 
0083C:  MOVFF  215,21A
....................    adsress[3]  = (unsigned int8)((ADDRESS) & 0xFF);                              // 0x 00 00 00 _ _ 
00840:  MOVFF  214,21B
....................     
....................  output_low(CS_PIN_3);                                                           //lower the CS PIN 
00844:  BCF    F92.2
00846:  BCF    F89.2
....................   
....................  ////////////////////////////////////////////////////////////////// 
....................  int8 data; 
....................  spi_xfer(SPIPORT_3,READ_DATA_BYTES);                                            //READ DATA COMAND   (0x13) 
00848:  MOVLW  13
0084A:  MOVWF  x1D
0084C:  MOVLW  08
0084E:  MOVWF  x1E
00850:  MOVLB  0
00852:  RCALL  07F6
....................   
....................  spi_xfer(SPIPORT_3,adsress[0]); 
00854:  MOVFF  218,21D
00858:  MOVLW  08
0085A:  MOVLB  2
0085C:  MOVWF  x1E
0085E:  MOVLB  0
00860:  RCALL  07F6
....................  spi_xfer(SPIPORT_3,adsress[1]); 
00862:  MOVFF  219,21D
00866:  MOVLW  08
00868:  MOVLB  2
0086A:  MOVWF  x1E
0086C:  MOVLB  0
0086E:  RCALL  07F6
....................  spi_xfer(SPIPORT_3,adsress[2]); 
00870:  MOVFF  21A,21D
00874:  MOVLW  08
00876:  MOVLB  2
00878:  MOVWF  x1E
0087A:  MOVLB  0
0087C:  RCALL  07F6
....................  spi_xfer(SPIPORT_3,adsress[3]); 
0087E:  MOVFF  21B,21D
00882:  MOVLW  08
00884:  MOVLB  2
00886:  MOVWF  x1E
00888:  MOVLB  0
0088A:  RCALL  07F6
....................  data = spi_xfer(SPIPORT_3); 
0088C:  MOVLW  03
0088E:  MOVLB  2
00890:  MOVWF  x1D
00892:  MOVLW  08
00894:  MOVWF  x1E
00896:  MOVLB  0
00898:  RCALL  07F6
0089A:  MOVF   01,W
0089C:  MOVFF  01,21C
....................  ////////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_3);                                                          //take CS PIN higher back 
008A0:  BCF    F92.2
008A2:  BSF    F89.2
....................  return data; 
008A4:  MOVLB  2
008A6:  MOVFF  21C,01
008AA:  MOVLB  0
008AC:  GOTO   08F8 (RETURN)
....................   
.................... } 
....................  
....................  
.................... /* 
.................... void TRANSFER_DATA_256byte_OF(unsigned INT32 ADRESS, int PORT_NUM) //read and send the specified data 
.................... { 
....................    unsigned long int i; 
....................     
....................    switch(PORT_NUM) 
....................    { 
....................       case 1: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_OF(ADRESS),PC); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................       case 2: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_OF(ADRESS),reset); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................       case 3: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_OF(ADRESS),com); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................    } 
....................    return;  
.................... } 
.................... void TRANSFER_DATA_256byte_SCF(unsigned INT32 ADRESS, int PORT_NUM) //read and send the specified data 
.................... { 
....................    unsigned long int i; 
....................     
....................    switch(PORT_NUM) 
....................    { 
....................       case 1: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_SCF(ADRESS),PC); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................       case 2: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_SCF(ADRESS),reset); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................       case 3: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_SCF(ADRESS),com); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................    } 
....................     return;   
.................... } 
.................... void TRANSFER_DATA_256byte_SMF(unsigned INT32 ADRESS, int PORT_NUM) //read and send the specified data 
.................... { 
....................    unsigned long int i; 
....................     
....................    switch(PORT_NUM) 
....................    { 
....................       case 1: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_SMF(ADRESS),PC); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................       case 2: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_SMF(ADRESS),reset); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................       case 3: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_SMF(ADRESS),com); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................    } 
....................     return;   
.................... } 
....................  
.................... void WRITE_DATA_NBYTE_OF(unsigned INT32 ADDRES,int32 data_byte) //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(ADDRES,0x77); 
....................       ADDRES++; 
....................    } 
....................    return; 
.................... } 
.................... void WRITE_DATA_NBYTE_SCF(unsigned INT32 ADDRES,int32 data_byte) //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(ADDRES,0x69); 
....................       ADDRES++; 
....................    } 
....................    return; 
.................... } 
.................... void WRITE_DATA_NBYTE_SMF(unsigned INT32 ADDRES,int32 data_byte) //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(ADDRES,0x55); 
....................       ADDRES++; 
....................    } 
....................    return; 
.................... } 
.................... */ 
....................  
....................  
.................... void TRANSFER_DATA_NBYTE_TOPC_OF(unsigned INT32 ADDRESS,int32 data_byte)          //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       fputc(READ_DATA_BYTE_OF(ADDRESS),PC); 
....................       ADDRESS++; 
....................    } 
....................    return; 
.................... } 
....................  
....................  
.................... void TRANSFER_DATA_NBYTE_TOPC_SCF(unsigned INT32 ADRESS,int32 data_byte)         //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       fprintf(PC,"%x",READ_DATA_BYTE_SCF(ADRESS)); 
....................       ADRESS++; 
....................    } 
....................    return; 
.................... } 
....................  
....................  
.................... void TRANSFER_DATA_NBYTE_TOPC_SMF(unsigned INT32 ADRESS,int32 data_byte)         //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       fputc(READ_DATA_BYTE_SMF(ADRESS),PC); 
....................       ADRESS++; 
....................    } 
....................    return; 
.................... } 
....................  
.................... void TRANSFER_DATA_NBYTE_TOFAB_SMF(unsigned INT32 ADRESS,int32 data_byte)         //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
*
008BC:  MOVLB  2
008BE:  CLRF   x13
008C0:  CLRF   x12
008C2:  CLRF   x11
008C4:  CLRF   x10
008C6:  MOVF   x13,W
008C8:  SUBWF  x0F,W
008CA:  BNC   0928
008CC:  BNZ   08E4
008CE:  MOVF   x12,W
008D0:  SUBWF  x0E,W
008D2:  BNC   0928
008D4:  BNZ   08E4
008D6:  MOVF   x11,W
008D8:  SUBWF  x0D,W
008DA:  BNC   0928
008DC:  BNZ   08E4
008DE:  MOVF   x0C,W
008E0:  SUBWF  x10,W
008E2:  BC    0928
....................    { 
....................       fputc(READ_DATA_BYTE_SMF(ADRESS),fab); 
008E4:  MOVFF  20B,217
008E8:  MOVFF  20A,216
008EC:  MOVFF  209,215
008F0:  MOVFF  208,214
008F4:  MOVLB  0
008F6:  BRA    0832
008F8:  MOVFF  01,214
008FC:  MOVLB  2
008FE:  MOVF   x14,W
00900:  MOVLB  0
00902:  RCALL  08B0
....................       ADRESS++; 
00904:  MOVLW  01
00906:  MOVLB  2
00908:  ADDWF  x08,F
0090A:  BTFSC  FD8.0
0090C:  INCF   x09,F
0090E:  BTFSC  FD8.2
00910:  INCF   x0A,F
00912:  BTFSC  FD8.2
00914:  INCF   x0B,F
00916:  MOVLW  01
00918:  ADDWF  x10,F
0091A:  BTFSC  FD8.0
0091C:  INCF   x11,F
0091E:  BTFSC  FD8.2
00920:  INCF   x12,F
00922:  BTFSC  FD8.2
00924:  INCF   x13,F
00926:  BRA    08C6
....................    } 
....................    return; 
00928:  MOVLB  0
0092A:  GOTO   0F5A (RETURN)
.................... } 
....................  
....................  
.................... /* 
.................... void TRANSFER_DATA_NBYTE_OFtoSCF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from MAIN FLASH to COM FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(TO_ADRESS,READ_DATA_BYTE_OF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... } 
.................... void TRANSFER_DATA_NBYTE_SCFtoOF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from COM FLASH to MAIN FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(TO_ADRESS,READ_DATA_BYTE_SCF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... } 
.................... void TRANSFER_DATA_NBYTE_OFtoSMF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from MAIN FLASH to MISSION FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(TO_ADRESS,READ_DATA_BYTE_OF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... }*/ 
....................  
....................  
.................... void TRANSFER_DATA_NBYTE_SMFtoOF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from MISSION FLASH to MAIN FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(TO_ADRESS,READ_DATA_BYTE_SMF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... } 
....................  
....................  
.................... void TRANSFER_DATA_NBYTE_SMFtoSCF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from MISSION FLASH to COM FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(TO_ADRESS,READ_DATA_BYTE_SMF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... }/* 
.................... void TRANSFER_DATA_NBYTE_SCFtoSMF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from COM FLASH to MISSION FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(TO_ADRESS,READ_DATA_BYTE_SCF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... } 
.................... void TRANSFER_DATA_NBYTE_SCF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(TO_ADRESS,READ_DATA_BYTE_SCF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... } 
.................... */ 
....................  
....................  
....................  
.................... #include<MEMORY_OPERATION.c> 
.................... //-------------------------ADDRESS (PREVIOUS)---------------------------------- 
.................... //!/////////////////previous////////////////////////////// 
.................... //!Static int32 ADCS_SENSOR_ADDRESS = 65536*500; 
.................... //!Static int32 FAB_HK_ADDRESS = 65536 * 200; 
.................... //!Static int32 FAB_CW_ADDRESS = 65536 * 50; 
.................... //!Static int32 FAB_CW_ADDRESS_FOR_MF = 65536; //sector1 
.................... //!Static int32 HIGH_SAMP_HK_ADDRESS = 65536 * 1800; 
.................... //!Static int32 CAM_ADDRESS = 65536; 
.................... //!Static int32 DC_STATUS_ADDRESS = 65536*300; 
.................... //!/////////////////////////////////////////////////////// 
.................... #define SECT 65536                                                               //1 Sector = 65536 Bytes 
....................  
.................... Static int32 ADD_INFO_ADDRESS = 4096;                                            //for keeping the address data to flash memory 
.................... Static int32 ADDRESS_WRITING_COUNTER = 0;                                        //if address writing more than 30000 times, change the store address 
....................  
.................... Static int32 FLAG_DATA_ADDRESS = SECT*4;                                         //1sector 
.................... Static int32 RSV_DATA_ADDRESS=SECT*5;                                            //1sector 
.................... Static int32 SAT_LOG = SECT*6;                                                   //2sector 
.................... Static int32 CAM_ADDRESS = SECT*8;                                               //90sector 
.................... Static int32 FAB_HK_ADDRESS = SECT*98;                                           //1000sector 
.................... Static int32 FAB_CW_ADDRESS = SECT*1098;                                         //40sector 
.................... Static int32 ADCS_SENSOR_ADDRESS = SECT*1138;                                    //500sector 
.................... Static int32 ADCS_TLE_ADDRESS = SECT*1637;                                       //1sector (el ultimo no utilizado por ADCS data) 
.................... Static int32 DC_STATUS_ADDRESS = SECT*1638;                                      //1sector 
.................... Static int32 HIGH_SAMP_HK_ADDRESS = SECT*1639;                                   //409sector 
.................... Static int32 FLAG_ADDRESS_EEPROM = 0x18000;                                      //from 75 percent of the programming memory 
.................... Static int32 FLASH_AD_ADDRESS_EEPROM = 0x18000 + 28;                             //after flag info 
....................                                                                                  //Definicion de direcciones de espacio de memoria (fin) 
.................... #define FLAG_DATA_ADDRESS_END  SECT*5-26                                         //considera la longitud de cada dato para determinar la direccion de finalizacion 
.................... #define RSV_DATA_ADDRESS_END  SECT*6-160 
.................... #define SAT_LOG_END  SECT*8-22 
.................... #define CAM_ADDRESS_END  SECT*98-SECT*2 
.................... #define FAB_HK_ADDRESS_END  SECT*1098-SECT-248 
.................... #define FAB_CW_ADDRESS_END  SECT*1138-10 
.................... #define FAB_CW_ADDRESS_FOR_MF_END FAB_CW_ADDRESS_END 
.................... #define ADCS_SENSOR_ADDRESS_END  SECT*1638-408000                                //408000 is for 2 hour data(85*3600*2/1.5) 
.................... #define ADCS_TLE_ADDRESS_END  SECT*1638-TLE_size 
.................... #define DC_STATUS_ADDRESS_END SECT*1639-415 
.................... #define HIGH_SAMP_HK_ADDRESS_END  SECT*2047-178560                               //178560 is for 2 hour data(124*3600*2/5) 
....................                                                                                  //Flags definition 
.................... int8 BC_ATTEMPT_FLAG = 0; 
.................... int16 PASSED_DAYS = 0; 
.................... int8 RESERVE_CHECK = 0; 
.................... int8 RESERVE_MIN_FLAG = 0; 
.................... int8 RESERVE_TARGET_FLAG = 0; 
.................... int8 MISSION_CONTENTS = 0; 
.................... int8 MISSION_DETAIL = 0; 
.................... int8 RESERVE_ADDRESS_1 = 0; 
.................... int8 RESERVE_ADDRESS_2 = 0; 
.................... int8 RESERVE_ADDRESS_3 = 0; 
.................... int8 RESERVE_ADDRESS_4 = 0; 
.................... int8 RESERVE_PACKET_NUM = 0; 
.................... int8 Kill_FLAG_MAIN = 0; 
.................... int8 Kill_FLAG_FAB = 0; 
.................... int8 FIRST_HSSC_DONE = 0; 
.................... int8 AUTO_CAM_DONE = 0; 
.................... int8 AUTO_MBP_DONE = 0; 
.................... int8 AUTO_ADCS_DONE = 0; 
.................... int8 ANT_DEP_STATUS = 0; 
.................... int8 UPLINK_SUCCESS = 0; 
....................  
.................... int8 RESERVE_SEC_FLAG = 0; 
....................  
.................... //--------MAIN PIC Buffer------------------------------------------------------ 
.................... int8 CMD_FROM_PC[8] = {}; 
.................... unsigned int8 in_bffr_main[16] = {}; 
.................... int8 COM_DATA= 0; 
.................... static int8 CW_IDENTIFIER = 0; 
.................... int8 OPERATION_MODE = 0x00; 
.................... int8 PC_DATA = 0;                                   
.................... int8 COM_ONEBYTE_COMMAND = 0;                                                    //for GS testing 
....................  
.................... #define buffer_from_com  (in_bffr_main[0]==0xAA) && (in_bffr_main[15]==0xBB) 
.................... #define buffer_flash  (in_bffr_main[7]==0x73) 
.................... #define START_ADCS_MISSION  (in_bffr_main[1]==0x73) 
.................... #define ADCS_SENSOR_SIZE 100                                                      //for testing additional 6byte for checking duty 
....................  
....................  
.................... int8 ADCS_SENSOR_DATA[ADCS_SENSOR_SIZE] = {}; 
.................... int8 ADCS_ACK = 0; 
.................... int8 ADCS_ACK_COMMING = 0;                                                       //for Checking ACK from ADCS 
.................... #define ATTEMPT_TIME 8 
....................  
....................  
.................... #define EX_PANEL_THRESHHOLD 0x14 
.................... #define HIGH_SAMP_TIMES 12                                                       //for 2 hours 
....................  
.................... //----------RESET-------------------------------------------------------------- 
.................... #define Reset_size 11                                                            //1byte ack, 4byte time, 10byte sensor 
.................... int8 RESET_DATA = 0; 
.................... int8 reset_bffr[Reset_size] = {}; 
.................... int8 reset_flag = 0; 
....................  
.................... //---------OTHER FUNCTION------------------------------------------------------ 
.................... #define FLASH_ADD_SIZE 41                                                        //10 kinds of address(40byte), 1 flag(1byte), 1 WRITING COUNTER(2byte) 
.................... #define FLAG_INFO_SIZE 16 
.................... unsigned int8 sec_add_bfr[FLASH_ADD_SIZE] = {};                                  //vector utilizado para almacenar las direcciones leidas de la flash 
.................... unsigned int8 flag_info_bffr[FLAG_INFO_SIZE] = {}; 
....................  
.................... void CURRENT_FLAG_STATUS()                                                      //Print on PC port current flag status 
.................... { 
....................    fprintf(PC,"\r\nPASSED DAYS:%x\r\n",PASSED_DAYS); 
....................    fprintf(PC,"RESERVE CHECK:%x\r\n",RESERVE_CHECK); 
....................    fprintf(PC,"Kill FLAG MAIN:%x\r\n",Kill_FLAG_MAIN); 
....................    fprintf(PC,"Kill FLAG FAB:%x\r\n",Kill_FLAG_FAB); 
....................    fprintf(PC,"AUTO HIGH SAMPLING:%x\r\n",FIRST_HSSC_DONE); 
....................    fprintf(PC,"AUTO CAM:%x\r\n",AUTO_CAM_DONE); 
....................    fprintf(PC,"AUTO MBP:%x\r\n",AUTO_MBP_DONE); 
....................    fprintf(PC,"AUTO ADCS:%x\r\n",AUTO_ADCS_DONE); 
....................    fprintf(PC,"ANTENNA DEPLOY:%x\r\n",ANT_DEP_STATUS); 
....................    fprintf(PC,"ANTENNA DEPLOY ATTEMPT:%x\r\n",BC_ATTEMPT_FLAG); 
....................    fprintf(PC,"UPLINK SUCCESS:%x\r\n\r\n",UPLINK_SUCCESS); 
....................    return; 
.................... } 
....................  
....................  
.................... void CURRENT_ADDRESS_OF_FLASH()                                                  //imprime la asignacion de direcciones de la Flash memory 
.................... {   
....................    fprintf(PC,"\r\nADD INFO ADDRESS:%lx\r\n\r\n",ADD_INFO_ADDRESS); 
....................    fprintf(PC,"FLAG DATA ADDRESS:%x%x%x%x\r\n",FLAG_DATA_ADDRESS>>24,FLAG_DATA_ADDRESS>>16,FLAG_DATA_ADDRESS>>8,FLAG_DATA_ADDRESS); 
....................    fprintf(PC,"RESERVATION TABLE ADDRESS:%x%x%x%x\r\n",RSV_DATA_ADDRESS>>24,RSV_DATA_ADDRESS>>16,RSV_DATA_ADDRESS>>8,RSV_DATA_ADDRESS); 
....................    fprintf(PC,"SATELLITE LOG ADDRESS:%x%x%x%x\r\n",SAT_LOG>>24,SAT_LOG>>16,SAT_LOG>>8,SAT_LOG); 
....................    fprintf(PC,"CAM ADDRESS:%x%x%x%x\r\n",CAM_ADDRESS>>24,CAM_ADDRESS>>16,CAM_ADDRESS>>8,CAM_ADDRESS); 
....................    fprintf(PC,"FAB HK ADDRESS:%x%x%x%x\r\n",FAB_HK_ADDRESS>>24,FAB_HK_ADDRESS>>16,FAB_HK_ADDRESS>>8,FAB_HK_ADDRESS); 
....................    fprintf(PC,"FAB CW ADDRESS:%x%x%x%x\r\n",FAB_CW_ADDRESS>>24,FAB_CW_ADDRESS>>16,FAB_CW_ADDRESS>>8,FAB_CW_ADDRESS); 
....................    fprintf(PC,"ADCS SENSOR ADDRESS:%x%x%x%x\r\n",ADCS_SENSOR_ADDRESS>>24,ADCS_SENSOR_ADDRESS>>16,ADCS_SENSOR_ADDRESS>>8,ADCS_SENSOR_ADDRESS); 
....................    fprintf(PC,"ADCS TLE ADDRESS:%x%x%x%x\r\n",ADCS_TLE_ADDRESS>>24,ADCS_TLE_ADDRESS>>16,ADCS_TLE_ADDRESS>>8,ADCS_TLE_ADDRESS); 
....................    fprintf(PC,"MISSION BOSS ADDRESS:%x%x%x%x\r\n",DC_STATUS_ADDRESS>>24,DC_STATUS_ADDRESS>>16,DC_STATUS_ADDRESS>>8,DC_STATUS_ADDRESS); 
....................    fprintf(PC,"HIGH SAMP HK ADDRESS:%x%x%x%x\r\n",HIGH_SAMP_HK_ADDRESS>>24,HIGH_SAMP_HK_ADDRESS>>16,HIGH_SAMP_HK_ADDRESS>>8,HIGH_SAMP_HK_ADDRESS); 
....................    fprintf(PC,"WRITE %lx TIMES\r\n",ADDRESS_WRITING_COUNTER); 
....................    return; 
.................... } 
....................  
.................... void ERASE_EEPROM_INFO() 
.................... { 
....................    erase_program_eeprom(FLAG_ADDRESS_EEPROM);//erase 512byte(from 0x18000 to 0x181ff) 
....................    return; 
.................... } 
....................  
.................... void WRITE_FLAG_to_EEPROM()                                                      //saves the flags in the EEPROM from the address 0x18000 (75%) 
.................... { 
.................... //total programming memory size is 128KB 
.................... //start writing the important flag from 75 percent of the programming memory(from the address of 96KB --> 0x18000) 
....................    int16 DATA; 
....................    DATA = (int16)BC_ATTEMPT_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM, DATA); 
....................    DATA = (int16)PASSED_DAYS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+2, DATA); 
....................    DATA = (int16)RESERVE_CHECK; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+4, DATA); 
....................    DATA = (int16)RESERVE_MIN_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+6, DATA); 
....................    DATA = (int16)RESERVE_TARGET_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+8, DATA); 
....................    DATA = (int16)MISSION_CONTENTS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+10, DATA); 
....................    DATA = (int16)MISSION_DETAIL; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+12, DATA); 
....................    DATA = (int16)Kill_FLAG_MAIN; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+14, DATA); 
....................    DATA = (int16)Kill_FLAG_FAB; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+16, DATA); 
....................    DATA = (int16)FIRST_HSSC_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+18, DATA); 
....................    DATA = (int16)AUTO_CAM_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+20, DATA); 
....................    DATA = (int16)AUTO_MBP_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+22, DATA); 
....................    DATA = (int16)AUTO_ADCS_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+24, DATA); 
....................    DATA = (int16)ANT_DEP_STATUS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26, DATA); 
....................    DATA = (int16)UPLINK_SUCCESS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+28, DATA); 
....................    return; 
.................... } 
.................... /* 
.................... void WRITE_AD_INFO_to_EEPROM() 
.................... { 
....................    int16 DATA; 
....................    DATA = BC_ATTEMPT_FLAG >> 16; 
....................    WRITE_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM, DATA); 
....................    DATA = BC_ATTEMPT_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM+2, DATA); 
....................    return; 
.................... } 
.................... */ 
.................... void MAKE_FLAG_from_EEPROM()                                                     //toma de la eeprom la info de los flags y los carga en sus variables respectivas 
.................... { 
....................    if((READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM)!=0xffff)&&(READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26)!=0xffff)) 
....................    { 
....................       BC_ATTEMPT_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM); 
....................       PASSED_DAYS = (int16)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+2); 
....................       RESERVE_CHECK = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+4); 
....................       RESERVE_MIN_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+6); 
....................       RESERVE_TARGET_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+8); 
....................       MISSION_CONTENTS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+10); 
....................       MISSION_DETAIL = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+12); 
....................       Kill_FLAG_MAIN = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+14); 
....................       Kill_FLAG_FAB = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+16); 
....................       FIRST_HSSC_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+18); 
....................       AUTO_CAM_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+20); 
....................       AUTO_MBP_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+22); 
....................       AUTO_ADCS_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+24); 
....................       ANT_DEP_STATUS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26); 
....................       UPLINK_SUCCESS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+28); 
....................    } 
....................     
....................    fprintf(PC,"\r\nPASSED DAYS:%lx\r\n",PASSED_DAYS); 
....................    fprintf(PC,"RESERVE CHECK:%x\r\n",RESERVE_CHECK); 
....................    fprintf(PC,"Kill FLAG MAIN:%x\r\n",Kill_FLAG_MAIN); 
....................    fprintf(PC,"Kill FLAG FAB:%x\r\n",Kill_FLAG_FAB); 
....................    fprintf(PC,"AUTO HIGH SAMPLING:%x\r\n",FIRST_HSSC_DONE); 
....................    fprintf(PC,"AUTO CAM:%x\r\n",AUTO_CAM_DONE); 
....................    fprintf(PC,"AUTO MBP:%x\r\n",AUTO_MBP_DONE); 
....................    fprintf(PC,"AUTO ADCS:%x\r\n",AUTO_ADCS_DONE); 
....................    fprintf(PC,"ANTENNA DEPLOY:%x\r\n",ANT_DEP_STATUS); 
....................    fprintf(PC,"UPLINK SUCCESS:%x\r\n\r\n",UPLINK_SUCCESS); 
....................     
....................    return; 
.................... } 
....................  
.................... void TAKE_AD_INFO_from_EEPROM()                                                  //Reads address data from de program memory 
.................... { 
....................    int16 DATA_high = READ_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM);                
....................    int16 DATA_low = READ_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM+2); 
....................    int32 DATA = (((int32)DATA_high<<16) | (int32)DATA_low); 
....................    if(DATA != 0xffffffff) 
....................    { 
....................       ADD_INFO_ADDRESS = DATA;                                                    
....................    } 
....................    return; 
.................... } 
....................  
.................... void STORE_FLAG_INFO()                                                           //save flag data to flash memory 
.................... { 
....................    flag_info_bffr[0] = BC_ATTEMPT_FLAG; 
....................    flag_info_bffr[1] = PASSED_DAYS >> 8; 
....................    flag_info_bffr[2] = PASSED_DAYS; 
....................    flag_info_bffr[3] = RESERVE_CHECK; 
....................    flag_info_bffr[4] = RESERVE_TARGET_FLAG; 
....................    flag_info_bffr[5] = RESERVE_MIN_FLAG; 
....................    flag_info_bffr[6] = MISSION_CONTENTS; 
....................    flag_info_bffr[7] = MISSION_DETAIL; 
....................    flag_info_bffr[8] = Kill_FLAG_MAIN; 
....................    flag_info_bffr[9] = Kill_FLAG_FAB; 
....................    flag_info_bffr[10] = FIRST_HSSC_DONE; 
....................    flag_info_bffr[11] = AUTO_CAM_DONE; 
....................    flag_info_bffr[12] = AUTO_MBP_DONE; 
....................    flag_info_bffr[13] = AUTO_ADCS_DONE; 
....................    flag_info_bffr[14] = ANT_DEP_STATUS; 
....................    flag_info_bffr[15] = UPLINK_SUCCESS; 
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
....................    SUBSECTOR_4KB_ERASE_OF(FLAG_DATA_ADDRESS); 
....................    delay_ms(200); 
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
....................       delay_us(10); 
....................    } 
....................    delay_ms(10); 
....................    SUBSECTOR_4KB_ERASE_SCF(FLAG_DATA_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
....................       delay_us(10); 
....................    } 
....................    delay_ms(10); 
....................    SUBSECTOR_4KB_ERASE_SMF(FLAG_DATA_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
....................       delay_us(10); 
....................    } 
....................     
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
....................     
....................    fprintf(PC,"FLAG INFO STORED IN FLASH\r\n"); 
....................    return; 
....................     
.................... } 
....................  
.................... void RESET_FLAG_DATA() 
.................... { 
....................    //BC_ATTEMPT_FLAG = 0; 
....................    PASSED_DAYS = 0; 
....................    //RESERVE_CHECK = 0; 
....................    //RESERVE_MIN_FLAG = 0; 
....................    //RESERVE_TARGET_FLAG = 0; 
....................    //MISSION_CONTENTS = 0; 
....................    //MISSION_DETAIL = 0; 
....................    Kill_FLAG_MAIN = 0; 
....................    Kill_FLAG_FAB = 0; 
....................    FIRST_HSSC_DONE = 0; 
....................    AUTO_CAM_DONE = 0; 
....................    AUTO_MBP_DONE = 0; 
....................    AUTO_ADCS_DONE = 0; 
....................    ANT_DEP_STATUS = 0; 
....................    UPLINK_SUCCESS = 0; 
....................    STORE_FLAG_INFO(); 
....................    WRITE_FLAG_to_EEPROM(); 
....................    return; 
.................... } 
....................  
.................... void READ_WRTITING_ADDRESS_LOCATION()                                            //load the variable ADD_INFO_ADDRESS, look for the data in OF, SCF, SMF and EEPROM (carga la variable ADD_INFO_ADDRESS, busca el dato en OF, SCF, SMF y EEPROM) 
.................... {                                                                                //if you can't find it use the initial value (si no lo encuentra usa el valor inicial) 
....................    int i; 
....................    int8 ad_location_bfr[4]; 
....................    output_low(PIN_C4);                                                           //Main side 
....................    output_low(PIN_A5);                                                           //Main side 
....................    if(READ_DATA_BYTE_OF(0) == 0xff)                                              //this means there is no address data in OBC Flash 
....................    { 
....................       if(READ_DATA_BYTE_SCF(0) == 0xff)                                          //this means there is no address data in Shared COM Flash 
....................       { 
....................          if(READ_DATA_BYTE_SMF(0) == 0xff)                                       //if all memory was empty, location should be initial value 
....................          { 
....................             TAKE_AD_INFO_from_EEPROM();                                          //if inside of eeprom is also empty, use the initial value 
....................             ad_location_bfr[0] = ADD_INFO_ADDRESS >> 24; 
....................             ad_location_bfr[1] = ADD_INFO_ADDRESS >> 16; 
....................             ad_location_bfr[2] = ADD_INFO_ADDRESS >> 8; 
....................             ad_location_bfr[3] = ADD_INFO_ADDRESS; 
....................          }else{ 
....................             ad_location_bfr[0] = READ_DATA_BYTE_SMF(0); 
....................             ad_location_bfr[1] = READ_DATA_BYTE_SMF(1); 
....................             ad_location_bfr[2] = READ_DATA_BYTE_SMF(2); 
....................             ad_location_bfr[3] = READ_DATA_BYTE_SMF(3); 
....................             ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
....................          } 
....................       }else{ 
....................          ad_location_bfr[0] = READ_DATA_BYTE_SCF(0); 
....................          ad_location_bfr[1] = READ_DATA_BYTE_SCF(1); 
....................          ad_location_bfr[2] = READ_DATA_BYTE_SCF(2); 
....................          ad_location_bfr[3] = READ_DATA_BYTE_SCF(3); 
....................          ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
....................       } 
....................    }else{ 
....................       ad_location_bfr[0] = READ_DATA_BYTE_OF(0); 
....................       ad_location_bfr[1] = READ_DATA_BYTE_OF(1); 
....................       ad_location_bfr[2] = READ_DATA_BYTE_OF(2); 
....................       ad_location_bfr[3] = READ_DATA_BYTE_OF(3); 
....................       ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
....................    } 
....................     
....................    for(i = 0; i < 4; i++)                                                        //store the subsector(location) information 
....................    { 
....................       WRITE_DATA_BYTE_OF(i,ad_location_bfr[i]); 
....................       WRITE_DATA_BYTE_SCF(i,ad_location_bfr[i]); 
....................       WRITE_DATA_BYTE_SMF(i,ad_location_bfr[i]); 
....................    } 
....................    output_high(PIN_C4); 
....................    fprintf(PC,"\r\naddress info location:%lx\r\n",ADD_INFO_ADDRESS); 
....................    return; 
.................... } 
....................  
.................... void CHANGE_ADDRESS_WRITING_LOCATION()                                           //cambia la direccion de escritura de address locations cuando se superan los 95.000 ciclos 
.................... { 
....................    int32 AD_COUNTER = make32(READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+37),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+38),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+39),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+40));//check counter value 
....................    fprintf(PC,"AD COUNTER:%lx\r\n",AD_COUNTER); 
....................    if((AD_COUNTER > 95000) && (AD_COUNTER != 0xffffffff)) 
....................    { 
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_OF(0); 
....................       SUBSECTOR_4KB_ERASE_SCF(0); 
....................       SUBSECTOR_4KB_ERASE_SMF(0); 
....................       ADDRESS_WRITING_COUNTER = 0;                                               //reset counter 
....................       ADD_INFO_ADDRESS = ADD_INFO_ADDRESS + 0x00001000;                          //use next subsector 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       unsigned int8 address_place[4] = {}; 
....................       address_place[0] = ADD_INFO_ADDRESS >> 24; 
....................       address_place[1] = ADD_INFO_ADDRESS >> 16; 
....................       address_place[2] = ADD_INFO_ADDRESS >> 8; 
....................       address_place[3] = ADD_INFO_ADDRESS; 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       for(int i = 0; i < 4; i++)                                                 //store the new subsector(location) information 
....................       { 
....................          WRITE_DATA_BYTE_OF(i,address_place[i]);                                 //se le pasa direccion y dato 
....................          delay_us(10); 
....................          WRITE_DATA_BYTE_SCF(i,address_place[i]); 
....................          delay_us(10); 
....................          WRITE_DATA_BYTE_SMF(i,address_place[i]); 
....................          delay_us(10); 
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       fprintf(PC,"CHANGED MEMORY ADDRESS:"); 
....................       for(i = 0; i < 4; i++)                                                     //store the subsector(location) information 
....................       { 
....................          fprintf(PC,"%x",READ_DATA_BYTE_OF(i)); 
....................       } 
....................       fprintf(PC,"\r\n"); 
....................    } 
....................     
....................    return; 
.................... } 
....................  
.................... void TAKE_FLAG_INFO_FROM_OF()                                                    //Funcion que lee de memoria el dato de los FLAGS 
.................... { 
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       flag_info_bffr[num] = READ_DATA_BYTE_OF(FLAG_DATA_ADDRESS + num);          //guarda los datos en el vector flag_info_bffr[] 
....................       //delay_ms(1); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void STORE_ADRESS_DATA_TO_FLASH()                                                //save the address data in a new sector if the R / W cycle is reached 
.................... { 
....................    fprintf(PC,"\r\nStoreing Address Data in Flash\r\n"); 
....................    ADDRESS_WRITING_COUNTER++;                                                    //contador de escrituras en una direccion 
....................    CHANGE_ADDRESS_WRITING_LOCATION();                                            //cambia la direccion del lugar de escritura si se superan 95000 ciclos 
....................    sec_add_bfr[0] = FLAG_DATA_ADDRESS >> 24;                                     //se carga el array sec_add_bfr[] con los datos de las direcciones 
....................    sec_add_bfr[1] = FLAG_DATA_ADDRESS >> 16; 
....................    sec_add_bfr[2] = FLAG_DATA_ADDRESS >> 8; 
....................    sec_add_bfr[3] = FLAG_DATA_ADDRESS; 
....................        
....................    sec_add_bfr[4] = RSV_DATA_ADDRESS >> 24; 
....................    sec_add_bfr[5] = RSV_DATA_ADDRESS >> 16; 
....................    sec_add_bfr[6] = RSV_DATA_ADDRESS >> 8; 
....................    sec_add_bfr[7] = RSV_DATA_ADDRESS; 
....................     
....................    sec_add_bfr[8] = SAT_LOG >> 24; 
....................    sec_add_bfr[9] = SAT_LOG >> 16; 
....................    sec_add_bfr[10] = SAT_LOG >> 8; 
....................    sec_add_bfr[11] = SAT_LOG; 
....................     
....................    sec_add_bfr[12] = CAM_ADDRESS >> 24; 
....................    sec_add_bfr[13] = CAM_ADDRESS >> 16; 
....................    sec_add_bfr[14] = CAM_ADDRESS >> 8; 
....................    sec_add_bfr[15] = CAM_ADDRESS; 
....................     
....................    sec_add_bfr[16] = FAB_HK_ADDRESS >> 24; 
....................    sec_add_bfr[17] = FAB_HK_ADDRESS >> 16; 
....................    sec_add_bfr[18] = FAB_HK_ADDRESS >> 8; 
....................    sec_add_bfr[19] = FAB_HK_ADDRESS; 
....................     
....................    sec_add_bfr[20] = FAB_CW_ADDRESS >> 24; 
....................    sec_add_bfr[21] = FAB_CW_ADDRESS >> 16; 
....................    sec_add_bfr[22] = FAB_CW_ADDRESS >> 8; 
....................    sec_add_bfr[23] = FAB_CW_ADDRESS; 
....................     
....................    sec_add_bfr[24] = ADCS_SENSOR_ADDRESS >> 24; 
....................    sec_add_bfr[25] = ADCS_SENSOR_ADDRESS >> 16; 
....................    sec_add_bfr[26] = ADCS_SENSOR_ADDRESS >> 8; 
....................    sec_add_bfr[27] = ADCS_SENSOR_ADDRESS; 
....................     
....................    sec_add_bfr[28] = DC_STATUS_ADDRESS >> 24; 
....................    sec_add_bfr[29] = DC_STATUS_ADDRESS >> 16; 
....................    sec_add_bfr[30] = DC_STATUS_ADDRESS >> 8; 
....................    sec_add_bfr[31] = DC_STATUS_ADDRESS; 
....................     
....................    sec_add_bfr[32] = HIGH_SAMP_HK_ADDRESS >> 24; 
....................    sec_add_bfr[33] = HIGH_SAMP_HK_ADDRESS >> 16; 
....................    sec_add_bfr[34] = HIGH_SAMP_HK_ADDRESS >> 8; 
....................    sec_add_bfr[35] = HIGH_SAMP_HK_ADDRESS; 
....................     
....................    sec_add_bfr[36] = BC_ATTEMPT_FLAG; 
....................     
....................     
....................    sec_add_bfr[37] = ADDRESS_WRITING_COUNTER >> 24; 
....................    sec_add_bfr[38] = ADDRESS_WRITING_COUNTER >> 16; 
....................    sec_add_bfr[39] = ADDRESS_WRITING_COUNTER >> 8; 
....................    sec_add_bfr[40] = ADDRESS_WRITING_COUNTER; 
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
....................    int8 num = 0; 
....................    SUBSECTOR_4KB_ERASE_OF(ADD_INFO_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en OBC FLASH 
....................    { 
....................       WRITE_DATA_BYTE_OF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
....................       delay_us(10); 
....................    } 
....................    SUBSECTOR_4KB_ERASE_SCF(ADD_INFO_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en COM FLASH 
....................    { 
....................       WRITE_DATA_BYTE_SCF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
....................       delay_us(10); 
....................    } 
....................    SUBSECTOR_4KB_ERASE_SMF(ADD_INFO_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en MISSION FLASH 
....................    { 
....................       WRITE_DATA_BYTE_SMF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
....................       delay_us(10); 
....................    } 
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
....................    
....................    fprintf(PC,"ADDRESS DATA STORE DONE:%lx\r\n",ADD_INFO_ADDRESS); 
....................    return; 
.................... } 
....................  
.................... void TAKE_ADDRESS_DATA_FROM_OF()                                                 //Funcion que toma de la memoria las direcciones almacenadas en los primeros lugares 
.................... {   
....................     
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_OF(ADD_INFO_ADDRESS + num); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void TAKE_ADDRESS_DATA_FROM_SCF() 
.................... {   
....................    output_low(PIN_C4);   
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_SCF(ADD_INFO_ADDRESS + num); 
....................    } 
....................    output_high(PIN_C4); 
....................    return; 
.................... } 
....................  
.................... void TAKE_ADDRESS_DATA_FROM_SMF() 
.................... {   
....................    output_low(PIN_A5);   
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_SMF(ADD_INFO_ADDRESS + num); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void MAKE_FLAG_INFO()                                                            //Guarda en cada variable la informacion de flags recuperadas de memoria 
.................... { 
....................    BC_ATTEMPT_FLAG     = flag_info_bffr[0]; 
....................    PASSED_DAYS         = make16(flag_info_bffr[1],flag_info_bffr[2]); 
....................    RESERVE_CHECK       = flag_info_bffr[3]; 
....................    RESERVE_TARGET_FLAG = flag_info_bffr[4]; 
....................    RESERVE_MIN_FLAG    = flag_info_bffr[5]; 
....................    MISSION_CONTENTS    = flag_info_bffr[6]; 
....................    MISSION_DETAIL      = flag_info_bffr[7]; 
....................    Kill_FLAG_MAIN      = flag_info_bffr[8]; 
....................    Kill_FLAG_FAB       = flag_info_bffr[9]; 
....................    FIRST_HSSC_DONE     = flag_info_bffr[10]; 
....................    AUTO_CAM_DONE       = flag_info_bffr[11]; 
....................    AUTO_MBP_DONE       = flag_info_bffr[12]; 
....................    AUTO_ADCS_DONE      = flag_info_bffr[13]; 
....................    ANT_DEP_STATUS      = flag_info_bffr[14]; 
....................    UPLINK_SUCCESS      = flag_info_bffr[15]; 
....................    if(PASSED_DAYS == 0xffff) 
....................    { 
....................       COLLECT_RESET_DATA();                                                      //funcion que envia el comando 0x28 al reset PIC y carga reset_bffr[] 
....................       PASSED_DAYS = make16(reset_bffr[4],reset_bffr[5]); 
....................    } 
....................    return; 
.................... } 
....................                                                                              
.................... void MAKE_ADDRESS_DATA()                                                         //Funcion que separa los datos de direcciones en cada variable correspondiente 
.................... {                                                                                //sec_add_bfr[] vector que contiene los datos de direcciones 
....................  
....................  
....................    FLAG_DATA_ADDRESS = make32(sec_add_bfr[0],sec_add_bfr[1],sec_add_bfr[2],sec_add_bfr[3]);//FLAG_DATA_ADDRESS_1 | FLAG_DATA_ADDRESS_2 | FLAG_DATA_ADDRESS_3 | FLAG_DATA_ADDRESS_4; 
....................     
....................    RSV_DATA_ADDRESS = make32(sec_add_bfr[4],sec_add_bfr[5],sec_add_bfr[6],sec_add_bfr[7]);//RSV_DATA_ADDRESS_1| RSV_DATA_ADDRESS_2 | RSV_DATA_ADDRESS_3 | RSV_DATA_ADDRESS_4; 
....................     
....................    SAT_LOG = make32(sec_add_bfr[8],sec_add_bfr[9],sec_add_bfr[10],sec_add_bfr[11]);//SAT_LOG_1 | SAT_LOG_2 | SAT_LOG_3 | SAT_LOG_4; 
....................     
....................    CAM_ADDRESS = make32(sec_add_bfr[12],sec_add_bfr[13],sec_add_bfr[14],sec_add_bfr[15]);//CAM_ADDRESS_1 | CAM_ADDRESS_2 | CAM_ADDRESS_3 | CAM_ADDRESS_4; 
....................     
....................    FAB_HK_ADDRESS = make32(sec_add_bfr[16],sec_add_bfr[17],sec_add_bfr[18],sec_add_bfr[19]);//FAB_HK_ADDRESS_1 | FAB_HK_ADDRESS_2 | FAB_HK_ADDRESS_3 | FAB_HK_ADDRESS_4; 
....................  
....................    FAB_CW_ADDRESS = make32(sec_add_bfr[20],sec_add_bfr[21],sec_add_bfr[22],sec_add_bfr[23]);//FAB_CW_ADDRESS_1| FAB_CW_ADDRESS_2 | FAB_CW_ADDRESS_3 | FAB_CW_ADDRESS_4; 
....................     
....................    ADCS_SENSOR_ADDRESS = make32(sec_add_bfr[24],sec_add_bfr[25],sec_add_bfr[26],sec_add_bfr[27]);//ADCS_SENSOR_ADDRESS_1 | ADCS_SENSOR_ADDRESS_2 | ADCS_SENSOR_ADDRESS_3 | ADCS_SENSOR_ADDRESS_4; 
....................     
....................    DC_STATUS_ADDRESS = make32(sec_add_bfr[28],sec_add_bfr[29],sec_add_bfr[30],sec_add_bfr[31]);//DC_STATUS_ADDRESS_1 | DC_STATUS_ADDRESS_2 | DC_STATUS_ADDRESS_3 | DC_STATUS_ADDRESS_4; 
....................     
....................    HIGH_SAMP_HK_ADDRESS = make32(sec_add_bfr[32],sec_add_bfr[33],sec_add_bfr[34],sec_add_bfr[35]);//HIGH_SAMP_HK_ADDRESS = HIGH_SAMP_HK_ADDRESS_1 | HIGH_SAMP_HK_ADDRESS_2 | HIGH_SAMP_HK_ADDRESS_3 | HIGH_SAMP_HK_ADDRESS_4; 
....................     
....................    ADDRESS_WRITING_COUNTER = make32(sec_add_bfr[36],sec_add_bfr[37],sec_add_bfr[38],sec_add_bfr[39]);//ADDRESS_WRITING_COUNTER_1 | ADDRESS_WRITING_COUNTER_2 
....................     
....................    return; 
.................... } 
....................  
.................... void CHECK_FLAG_INFO()                                                           //funcion que imprime los datos de los flags y los separa en cada variable 
.................... { 
....................    int8 checksum = 0; 
....................    TAKE_FLAG_INFO_FROM_OF();                                                     //funcion que lee de la Main flash el estado de los flags y carga el array flag_info_bffr 
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       if(flag_info_bffr[num] == 0xff)                                            //si la informacion recuperada es 0xff (no hay informacion) incrementa el checksum 
....................       { 
....................          checksum++; 
....................       } 
....................    } 
....................    //fprintf(PC,"%d",checksum); 
....................     
....................    if((flag_info_bffr[0]!=0xff)&&(flag_info_bffr[FLAG_INFO_SIZE-1]!=0xff))       //if something stored 
....................    { 
....................       for(num = 0; num < FLAG_INFO_SIZE; num++)                                  //imprime la informacion de los flags 
....................       { 
....................          fprintf(PC,"%x",flag_info_bffr[num]); 
....................       } 
....................       MAKE_FLAG_INFO();                                                          //separa el estado de los flags en cada variable 
....................    }else{                                                                        //if nothing stored 
....................       MAKE_FLAG_from_EEPROM();                                                   //lee de la eeprom el estado de los flags 
....................    } 
....................    checksum = 0; 
....................    return; 
.................... } 
....................  
.................... void CHECK_ADDRESS_DATA()                                                        //imprime los datos de direcciones y los separa en cada variable correspondiente 
.................... { 
....................    int8 checksum = 0; 
....................    TAKE_ADDRESS_DATA_FROM_OF();                                                  //craga el array sec_add_bfr[] con address location info y lo imprime                                                   
....................    for(int8 num = 37; num < 41; num++)                                           //check the data of last 4 byte 
....................    { 
....................       if(sec_add_bfr[num] == 0xff)                                               //if nothing, count checksum 
....................       { 
....................          checksum++; 
....................       } 
....................    } 
....................     
....................    if(checksum != 4)                                                             //if something stored (if last 4 byte were not 0xff) 
....................    { 
....................       for(num = 0; num < FLASH_ADD_SIZE; num++) 
....................       { 
....................          fprintf(PC,"%x",sec_add_bfr[num]);                                      //imprime el contenido de sec_add_bfr[] que contiene las direcciones 
....................       } 
....................       fprintf(PC,"\r\n"); 
....................       MAKE_ADDRESS_DATA();                                                       //los separa en las variables correspondientes a cada direccion 
....................    }else{                                                                        //if there is nothing, check from SCF 
....................       output_low(PIN_C4); 
....................       TAKE_ADDRESS_DATA_FROM_SCF(); 
....................       output_high(PIN_C4); 
....................       checksum = 0; 
....................       for(num = 37; num < 41; num++)                                             //check the data of last 4 byte 
....................       { 
....................          if(sec_add_bfr[num] == 0xff)                                            //if nothing, count checksum 
....................          { 
....................             checksum++; 
....................          } 
....................       } 
....................       if(checksum != 4) 
....................       { 
....................          for(num = 0; num < FLASH_ADD_SIZE; num++) 
....................          { 
....................             fprintf(PC,"%x",sec_add_bfr[num]); 
....................          } 
....................          fprintf(PC,"\r\n"); 
....................          MAKE_ADDRESS_DATA(); 
....................       }else{                                                                     //if there is nothing, check from SMF 
....................          output_low(PIN_A5); 
....................          TAKE_ADDRESS_DATA_FROM_SMF(); 
....................          checksum = 0; 
....................          for(num = 37; num < 41; num++)                                          //check the data of last 4 byte 
....................          { 
....................             if(sec_add_bfr[num] == 0xff)                                         //if nothing, count checksum 
....................             { 
....................                checksum++; 
....................             } 
....................          } 
....................          if(checksum != 4) 
....................          { 
....................             for(num = 0; num < FLASH_ADD_SIZE; num++) 
....................             { 
....................                fprintf(PC,"%x",sec_add_bfr[num]); 
....................             } 
....................             fprintf(PC,"\r\n"); 
....................             MAKE_ADDRESS_DATA(); 
....................          } 
....................       } 
....................    }   
....................    checksum = 0;   
....................    return; 
.................... } 
....................  
.................... ////////////////////////// 
.................... //FAB_HK_ADDRESS        // 
.................... //FAB_CW_ADDRESS        // 
.................... //ADCS_SENSOR_ADDRESS   // 
.................... //CAM_ADDRESS           // 
.................... //DC_STATUS_ADDRESS     // 
.................... ////////////////////////// 
.................... void MEMORY_ERASE() 
.................... { 
....................    fprintf(PC,"FLASH MEMORY ERASE START\r\n"); 
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
....................     
....................    sector_erase_OF(0); 
....................    sector_erase_SCF(0); 
....................    sector_erase_SMF(0); 
....................     
....................    sector_erase_OF(FAB_CW_ADDRESS); 
....................    sector_erase_SCF(FAB_CW_ADDRESS); 
....................    sector_erase_SMF(FAB_CW_ADDRESS); 
....................     
....................     
....................    for(int8 num = 0; num < 5; num++) 
....................    { 
....................       sector_erase_OF(FLAG_DATA_ADDRESS + SECT*num);                             //65536*num 
....................       sector_erase_OF(CAM_ADDRESS + SECT*num);                                   //65536*num 
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT*num);                                //65536*num 
....................       sector_erase_OF(ADCS_SENSOR_ADDRESS + SECT*num);                           //65536*num 
....................       sector_erase_OF(DC_STATUS_ADDRESS + SECT*num);                             //65536*num 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*num);                          //65536*num 
....................        
....................       sector_erase_SCF(FLAG_DATA_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SCF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SCF(ADCS_SENSOR_ADDRESS + SECT*num);                          //65536*num 
....................       sector_erase_SCF(DC_STATUS_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................        
....................       sector_erase_SMF(FLAG_DATA_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SMF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SMF(ADCS_SENSOR_ADDRESS + SECT*num);                          //65536*num 
....................       sector_erase_SMF(DC_STATUS_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................    } 
....................    for(num = 5; num < 10; num++) 
....................    { 
....................       sector_erase_OF(CAM_ADDRESS + SECT*num);                                   //65536*num 
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT*num);                                //65536*num 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*num);                          //65536*num 
....................        
....................       sector_erase_SCF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................        
....................       sector_erase_SMF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................    } 
....................     
....................    sector_erase_OF(0x06650000);                                                  //erase ADCS TLE address 
....................    sector_erase_SCF(0x06650000); 
....................    sector_erase_SMF(0x06650000); 
....................     
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
....................    delay_ms(10000); 
....................    fprintf(PC,"FLASH MEMORY ERASE DONE\r\n"); 
....................    for(int t=60; t>0; t--){ 
....................    fprintf(PC,"Remaining time: %d  \r", t); 
....................    delay_ms(1000); 
....................    } 
....................    //delay_ms(60000); 
....................    return; 
.................... } 
.................... /* 
.................... //@@@@@@@@@@@@@@@@@@MISSION LOOP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... void LOOP_FLAG_DATA_ADDRESS() 
.................... { 
....................     
....................    if(FLAG_DATA_ADDRESS > FLAG_DATA_ADDRESS_END) 
....................    { 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_RSV_DATA_ADDRESS() 
.................... { 
....................    if(RSV_DATA_ADDRESS > RSV_DATA_ADDRESS_END) 
....................    { 
....................        
....................    } 
....................    return; 
.................... } 
.................... */ 
.................... void LOOP_SAT_LOG()                                                              //hace un loop en las posiciones de memoria para almacenar SAT_LOG 
.................... { 
....................    if(SAT_LOG >= SAT_LOG_END)                                                    //si la posicion de escritura de SAT_LOG alcanza a SAT_LOG_END 
....................    { 
....................       sector_erase_OF(SECT*7);                                                   //borra un sector de la MAIN flash, 65536*7 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*7);                                                  //borra un sector de la COM flash,65536*7 
....................       output_high(PIN_C4);                                                       //CAM_MUX MAINSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*7);                                                  //borra un sector de la MISSION flash,65536*7 
....................       SAT_LOG = SECT*7;                                                          //Cambia la direccion de SAT_LOG y mantiene el primer sector,65536*7 
....................       STORE_ADRESS_DATA_TO_FLASH();                                              //guarda los datos de direcciones, sera en un nuevo sector si se cumple el ciclo de R/W 
....................    } 
....................    //output_high(PIN_C4);//COM_MUX COMSIDE 
....................    return; 
.................... } 
....................  
.................... void LOOP_CAM_ADDRESS()                                                          //hace un loop en las posiciones de memoria para almacenar CAM data 
.................... { 
....................    if(CAM_ADDRESS >= CAM_ADDRESS_END)                                            //si la posicion de escritura de CAM alcanza a CAM_ADDRESS_END 
....................    { 
....................       sector_erase_OF(SECT*9);                                                   //borra 1 sector de la MAIN flash, 65536*9 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*9);                                                  //borra 1 sector de la COM flash, 65536*9 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*9);                                                  //borra 1 sector de la MISSION flash, 65536*9 
....................        
....................       CAM_ADDRESS = SECT*9;                                                      //CAM address se ubica ahora en el comienzo del espacio designado a CAM 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_FAB_HK_ADDRESS()                                                       //Rota las posiciones de guardado de los datos si llega al final del espacio asignado                                                        
.................... { 
....................    int32 checksum = FAB_HK_ADDRESS && 0x0000ffff; 
....................    if(FAB_HK_ADDRESS >= FAB_HK_ADDRESS_END)                                       
....................    { 
....................       sector_erase_OF(SECT*98); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*98); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*98); 
....................        
....................       FAB_HK_ADDRESS = 65536*8;                                                  //la nueva direccion vuelve a ser el comienzo del espacio asignado 
....................       STORE_ADRESS_DATA_TO_FLASH();                                              //guarda los datos de direcciones y en un nuevo sector si se cumple el ciclo de R/W 
....................    }else if(65536 - checksum < 119){                                             //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT);                                    //erase next sector in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_FAB_CW_ADDRESS()                                                       //Rota las posiciones de guardado de los datos si llega al final del espacio asignado  
.................... { 
....................    int32 checksum = FAB_CW_ADDRESS && 0x0000ffff; 
....................    if(FAB_CW_ADDRESS >= FAB_CW_ADDRESS_END) 
....................    {   
....................       sector_erase_OF(SECT*1098); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*1098); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*1098); 
....................        
....................       FAB_CW_ADDRESS = SECT*1098; 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    }else if(SECT - checksum < 5){                                                //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       sector_erase_OF(FAB_CW_ADDRESS + SECT);                                    //erase next sector in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(FAB_CW_ADDRESS + SECT);                                   //erase next sector in advance 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(FAB_CW_ADDRESS + SECT);                                   //erase next sector in advance 
....................        
....................    } 
....................    return; 
.................... } 
....................  
....................  
.................... void LOOP_ADCS_SENSOR_ADDRESS() 
.................... { 
....................    if(ADCS_SENSOR_ADDRESS >= ADCS_SENSOR_ADDRESS_END)                            //for 15min operation, data size will be more than 1sector 
....................    { 
....................       sector_erase_OF(SECT*1140); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*1140); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*1140); 
....................        
....................       ADCS_SENSOR_ADDRESS = SECT*1140;                                           //keep first 2 sector forever 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    }else{                                                                        //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       int i; 
....................       for(i = 1; i < 10; i++) 
....................       { 
....................          sector_erase_OF(ADCS_SENSOR_ADDRESS + SECT*i);                          //erase next sector in advance 
....................       } 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       for(i = 1; i < 10; i++) 
....................       { 
....................          sector_erase_SCF(ADCS_SENSOR_ADDRESS + SECT*i);                         //erase next sector in advance 
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       for(i = 1; i < 10; i++) 
....................       { 
....................          sector_erase_SMF(ADCS_SENSOR_ADDRESS + SECT*i);                         //erase next sector in advance 
....................       } 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_DC_STATUS_ADDRESS() 
.................... { 
....................    int32 checksum = DC_STATUS_ADDRESS && 0x00000fff; 
....................    if(DC_STATUS_ADDRESS >= DC_STATUS_ADDRESS_END) 
....................    { 
....................       SUBSECTOR_4KB_ERASE_OF(SECT*1639+4096); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SCF(SECT*16394096); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SMF(SECT*1639+4096); 
....................        
....................       DC_STATUS_ADDRESS = SECT*1639+4096;                                        //keep first 1 SUBSECTOR forever 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    }else if(4096 - checksum < 800){                                              //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       SUBSECTOR_4KB_ERASE_OF(DC_STATUS_ADDRESS + 4096);                          //erase next SUBSECTOR in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SCF(DC_STATUS_ADDRESS + 4096);                         //erase next SUBSECTOR in advance 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SMF(DC_STATUS_ADDRESS + 4096);                         //erase next SUBSECTOR in advance 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_HIGH_SAMP_HK_ADDRESS() 
.................... { 
....................    if(HIGH_SAMP_HK_ADDRESS >= HIGH_SAMP_HK_ADDRESS_END)                          //for 15min operation, data size will be more than 2sector 
....................    { 
....................       sector_erase_OF(SECT*1642);                                                //delet from 066A0000 (keep first 3 sectors) 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*1642); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*1642); 
....................        
....................       HIGH_SAMP_HK_ADDRESS = SECT*1642;                                          //keep first 3 sector forever 
....................    }else{                                                                        //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT);                              //erase next sector in advance 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*2);                            //erase next sector in advance 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*3);                            //erase next sector in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT);                             //erase next sector in advance 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*2);                           //erase next sector in advance 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*3);                           //erase next sector in advance 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT);                             //erase next sector in advance 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*2);                           //erase next sector in advance 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*3);                           //erase next sector in advance 
....................    } 
....................    return; 
.................... } 
....................  
....................  
....................  
.................... #include<mainpic_function.c> 
....................  
.................... int8 MISSION_STATUS = 0;                                                         //MISSION STATUS FLAGS 
.................... static int16 currenttime = 0; 
.................... BYTE command[9]; 
.................... int8 reset_time_data[11] = {}; 
.................... BYTE PINO_DATA[39] = {0x00}; 
.................... int8 test_data[11] = {0}; 
.................... unsigned int32 address_data[4]; 
.................... unsigned int32 address; 
.................... BYTE RTUC[8]; 
.................... BYTE Down[81]; 
.................... BYTE RTDC[9]; 
.................... BYTE dummy[1]; 
.................... BYTE Finish_sign[1]; 
.................... int i; 
.................... void Turn_On_CAM() 
.................... { 
....................    output_high (PIN_D7); 
....................    return; 
.................... } 
.................... void Turn_Off_CAM() 
.................... { 
....................    output_low (PIN_D7); 
....................    return; 
.................... } 
.................... void Flash_Memory_Access() 
.................... { 
....................    sector_erase_OF (0x00000000); 
....................    WRITE_DATA_BYTE_OF (0x00000000, 0x01) ; 
....................    TRANSFER_DATA_NBYTE_TOPC_OF (0x00000000, 1) ; 
....................    delay_ms (1000); 
....................     
....................    sector_erase_OF (0x00000000); 
....................    WRITE_DATA_BYTE_OF (0x00000000, 0x02) ; 
....................    TRANSFER_DATA_NBYTE_TOPC_OF (0x00000000, 1) ; 
....................    delay_ms (1000); 
....................     
....................    sector_erase_OF (0x00000000); 
....................    WRITE_DATA_BYTE_OF (0x00000000, 0x03) ; 
....................    TRANSFER_DATA_NBYTE_TOPC_OF (0x00000000, 1) ; 
....................    delay_ms (1000); 
.................... } 
.................... void PINO_Test() 
.................... { 
....................    dummy[0] = 0x01; 
*
00DCC:  MOVLW  01
00DCE:  MOVLB  1
00DD0:  MOVWF  xF4
....................    int32 num; 
....................    while (TRUE) 
....................    { 
....................       command[0] = 0x00; 
00DD2:  CLRF   x38
....................        
....................       for (num = 0; num < 100; num++) 
00DD4:  MOVLB  2
00DD6:  CLRF   x05
00DD8:  CLRF   x04
00DDA:  CLRF   x03
00DDC:  CLRF   x02
00DDE:  MOVF   x05,F
00DE0:  BNZ   0E4E
00DE2:  MOVF   x04,F
00DE4:  BNZ   0E4E
00DE6:  MOVF   x03,F
00DE8:  BNZ   0E4E
00DEA:  MOVF   x02,W
00DEC:  SUBLW  63
00DEE:  BNC   0E4E
....................       { 
....................          if (kbhit (fab)) 
00DF0:  BTFSS  FA6.5
00DF2:  BRA    0E3C
....................          { 
....................  
....................             for (int i = 0; i < 9; i++) 
00DF4:  CLRF   x06
00DF6:  MOVF   x06,W
00DF8:  SUBLW  08
00DFA:  BNC   0E3A
....................             { 
....................                fprintf (fab, "Get command\r\n") ; 
00DFC:  MOVLW  22
00DFE:  MOVWF  FF6
00E00:  MOVLW  05
00E02:  MOVWF  FF7
00E04:  MOVLW  00
00E06:  MOVWF  FF8
00E08:  MOVLB  0
00E0A:  RCALL  07AC
....................                command[i] = fgetc (fab); 
00E0C:  CLRF   03
00E0E:  MOVLB  2
00E10:  MOVF   x06,W
00E12:  ADDLW  38
00E14:  MOVWF  FE9
00E16:  MOVLW  01
00E18:  ADDWFC 03,W
00E1A:  MOVWF  FEA
00E1C:  MOVFF  FEA,20A
00E20:  MOVFF  FE9,209
00E24:  MOVLB  0
00E26:  BRA    07DA
00E28:  MOVFF  20A,FEA
00E2C:  MOVFF  209,FE9
00E30:  MOVFF  01,FEF
00E34:  MOVLB  2
00E36:  INCF   x06,F
00E38:  BRA    0DF6
....................             } 
....................             break; 
00E3A:  BRA    0E4E
....................          } 
00E3C:  MOVLW  01
00E3E:  ADDWF  x02,F
00E40:  BTFSC  FD8.0
00E42:  INCF   x03,F
00E44:  BTFSC  FD8.2
00E46:  INCF   x04,F
00E48:  BTFSC  FD8.2
00E4A:  INCF   x05,F
00E4C:  BRA    0DDE
....................       } 
....................       switch (command[0]) 
00E4E:  MOVLB  1
00E50:  MOVF   x38,W
00E52:  XORLW  13
00E54:  MOVLB  0
00E56:  BZ    0E8A
00E58:  XORLW  07
00E5A:  BTFSC  FD8.2
00E5C:  BRA    0F6A
00E5E:  XORLW  02
00E60:  BTFSC  FD8.2
00E62:  BRA    110C
00E64:  XORLW  87
00E66:  BTFSC  FD8.2
00E68:  BRA    124A
00E6A:  XORLW  03
00E6C:  BTFSC  FD8.2
00E6E:  BRA    12D6
00E70:  XORLW  01
00E72:  BTFSC  FD8.2
00E74:  BRA    13CA
00E76:  XORLW  07
00E78:  BTFSC  FD8.2
00E7A:  BRA    13F2
00E7C:  XORLW  0F
00E7E:  BTFSC  FD8.2
00E80:  BRA    1440
00E82:  XORLW  04
00E84:  BTFSC  FD8.2
00E86:  BRA    146E
00E88:  BRA    1490
....................       { 
....................          case 0x13: 
....................          fprintf (fab, "Start 0x13\r\n") ; 
00E8A:  MOVLW  30
00E8C:  MOVWF  FF6
00E8E:  MOVLW  05
00E90:  MOVWF  FF7
00E92:  MOVLW  00
00E94:  MOVWF  FF8
00E96:  RCALL  07AC
....................          output_low (PIN_A5); 
00E98:  BCF    F92.5
00E9A:  BCF    F89.5
....................          address_data[0] = command[1]<<24; 
00E9C:  MOVFF  139,181
00EA0:  MOVLB  1
00EA2:  CLRF   x7E
00EA4:  CLRF   x7F
00EA6:  CLRF   x80
....................          address_data[1] = command[2]<<16; 
00EA8:  MOVFF  13A,184
00EAC:  CLRF   x82
00EAE:  CLRF   x83
00EB0:  CLRF   x85
....................          address_data[2] = command[3]<<8; 
00EB2:  MOVFF  13B,187
00EB6:  CLRF   x86
00EB8:  CLRF   x88
00EBA:  CLRF   x89
....................          address_data[3] = command[4]; 
00EBC:  CLRF   x8D
00EBE:  CLRF   x8C
00EC0:  CLRF   x8B
00EC2:  MOVFF  13C,18A
....................          address = address_data[0] + address_data[1] + address_data[2] + address_data[3]; 
00EC6:  MOVF   x82,W
00EC8:  ADDWF  x7E,W
00ECA:  MOVLB  2
00ECC:  MOVWF  x07
00ECE:  MOVLB  1
00ED0:  MOVF   x83,W
00ED2:  ADDWFC x7F,W
00ED4:  MOVLB  2
00ED6:  MOVWF  x08
00ED8:  MOVLB  1
00EDA:  MOVF   x84,W
00EDC:  ADDWFC x80,W
00EDE:  MOVLB  2
00EE0:  MOVWF  x09
00EE2:  MOVLB  1
00EE4:  MOVF   x85,W
00EE6:  ADDWFC x81,W
00EE8:  MOVLB  2
00EEA:  MOVWF  x0A
00EEC:  MOVLB  1
00EEE:  MOVF   x86,W
00EF0:  MOVLB  2
00EF2:  ADDWF  x07,F
00EF4:  MOVLB  1
00EF6:  MOVF   x87,W
00EF8:  MOVLB  2
00EFA:  ADDWFC x08,F
00EFC:  MOVLB  1
00EFE:  MOVF   x88,W
00F00:  MOVLB  2
00F02:  ADDWFC x09,F
00F04:  MOVLB  1
00F06:  MOVF   x89,W
00F08:  MOVLB  2
00F0A:  ADDWFC x0A,F
00F0C:  MOVLB  1
00F0E:  MOVF   x8A,W
00F10:  MOVLB  2
00F12:  ADDWF  x07,W
00F14:  MOVLB  1
00F16:  MOVWF  x8E
00F18:  MOVF   x8B,W
00F1A:  MOVLB  2
00F1C:  ADDWFC x08,W
00F1E:  MOVLB  1
00F20:  MOVWF  x8F
00F22:  MOVF   x8C,W
00F24:  MOVLB  2
00F26:  ADDWFC x09,W
00F28:  MOVLB  1
00F2A:  MOVWF  x90
00F2C:  MOVF   x8D,W
00F2E:  MOVLB  2
00F30:  ADDWFC x0A,W
00F32:  MOVLB  1
00F34:  MOVWF  x91
....................          TRANSFER_DATA_NBYTE_TOFAB_SMF(address, command[5] + command[6]); 
00F36:  MOVF   x3E,W
00F38:  ADDWF  x3D,W
00F3A:  MOVLB  2
00F3C:  MOVWF  x07
00F3E:  MOVFF  191,20B
00F42:  MOVFF  190,20A
00F46:  MOVFF  18F,209
00F4A:  MOVFF  18E,208
00F4E:  CLRF   x0F
00F50:  CLRF   x0E
00F52:  CLRF   x0D
00F54:  MOVWF  x0C
00F56:  MOVLB  0
00F58:  BRA    08BC
....................          fprintf (fab, "Finish 0x13\r\n") ; 
00F5A:  MOVLW  3E
00F5C:  MOVWF  FF6
00F5E:  MOVLW  05
00F60:  MOVWF  FF7
00F62:  MOVLW  00
00F64:  MOVWF  FF8
00F66:  RCALL  07AC
....................           
....................          break; 
00F68:  BRA    1490
....................           
....................          case 0x14: 
....................          output_low (PIN_A5) ; 
00F6A:  BCF    F92.5
00F6C:  BCF    F89.5
....................          fprintf (fab, "Start 0x14\r\n") ; 
00F6E:  MOVLW  4C
00F70:  MOVWF  FF6
00F72:  MOVLW  05
00F74:  MOVWF  FF7
00F76:  MOVLW  00
00F78:  MOVWF  FF8
00F7A:  RCALL  07AC
....................          address_data[0] = command[1]<<24; 
00F7C:  MOVFF  139,181
00F80:  MOVLB  1
00F82:  CLRF   x7E
00F84:  CLRF   x7F
00F86:  CLRF   x80
....................          address_data[1] = command[2]<<16; 
00F88:  MOVFF  13A,184
00F8C:  CLRF   x82
00F8E:  CLRF   x83
00F90:  CLRF   x85
....................          address_data[2] = command[3]<<8; 
00F92:  MOVFF  13B,187
00F96:  CLRF   x86
00F98:  CLRF   x88
00F9A:  CLRF   x89
....................          address_data[3] = command[4]; 
00F9C:  CLRF   x8D
00F9E:  CLRF   x8C
00FA0:  CLRF   x8B
00FA2:  MOVFF  13C,18A
....................          address = address_data[0] + address_data[1] + address_data[2] + address_data[3]; 
00FA6:  MOVF   x82,W
00FA8:  ADDWF  x7E,W
00FAA:  MOVLB  2
00FAC:  MOVWF  x07
00FAE:  MOVLB  1
00FB0:  MOVF   x83,W
00FB2:  ADDWFC x7F,W
00FB4:  MOVLB  2
00FB6:  MOVWF  x08
00FB8:  MOVLB  1
00FBA:  MOVF   x84,W
00FBC:  ADDWFC x80,W
00FBE:  MOVLB  2
00FC0:  MOVWF  x09
00FC2:  MOVLB  1
00FC4:  MOVF   x85,W
00FC6:  ADDWFC x81,W
00FC8:  MOVLB  2
00FCA:  MOVWF  x0A
00FCC:  MOVLB  1
00FCE:  MOVF   x86,W
00FD0:  MOVLB  2
00FD2:  ADDWF  x07,F
00FD4:  MOVLB  1
00FD6:  MOVF   x87,W
00FD8:  MOVLB  2
00FDA:  ADDWFC x08,F
00FDC:  MOVLB  1
00FDE:  MOVF   x88,W
00FE0:  MOVLB  2
00FE2:  ADDWFC x09,F
00FE4:  MOVLB  1
00FE6:  MOVF   x89,W
00FE8:  MOVLB  2
00FEA:  ADDWFC x0A,F
00FEC:  MOVLB  1
00FEE:  MOVF   x8A,W
00FF0:  MOVLB  2
00FF2:  ADDWF  x07,W
00FF4:  MOVLB  1
00FF6:  MOVWF  x8E
00FF8:  MOVF   x8B,W
00FFA:  MOVLB  2
00FFC:  ADDWFC x08,W
00FFE:  MOVLB  1
01000:  MOVWF  x8F
01002:  MOVF   x8C,W
01004:  MOVLB  2
01006:  ADDWFC x09,W
01008:  MOVLB  1
0100A:  MOVWF  x90
0100C:  MOVF   x8D,W
0100E:  MOVLB  2
01010:  ADDWFC x0A,W
01012:  MOVLB  1
01014:  MOVWF  x91
....................          sector_erase_SMF (address); 
01016:  MOVFF  191,20A
0101A:  MOVFF  190,209
0101E:  MOVFF  18F,208
01022:  MOVFF  18E,207
01026:  MOVLB  0
01028:  RCALL  0946
....................          WRITE_DATA_BYTE_SMF (address, command[5]) ; 
0102A:  MOVFF  191,20E
0102E:  MOVFF  190,20D
01032:  MOVFF  18F,20C
01036:  MOVFF  18E,20B
0103A:  MOVFF  13D,20F
0103E:  RCALL  09D6
....................          WRITE_DATA_BYTE_SMF (address + 1, command[6]) ; 
01040:  MOVLW  01
01042:  MOVLB  1
01044:  ADDWF  x8E,W
01046:  MOVLB  2
01048:  MOVWF  x07
0104A:  MOVLW  00
0104C:  MOVLB  1
0104E:  ADDWFC x8F,W
01050:  MOVLB  2
01052:  MOVWF  x08
01054:  MOVLW  00
01056:  MOVLB  1
01058:  ADDWFC x90,W
0105A:  MOVLB  2
0105C:  MOVWF  x09
0105E:  MOVLW  00
01060:  MOVLB  1
01062:  ADDWFC x91,W
01064:  MOVLB  2
01066:  MOVWF  x0A
01068:  MOVWF  x0E
0106A:  MOVFF  209,20D
0106E:  MOVFF  208,20C
01072:  MOVFF  207,20B
01076:  MOVFF  13E,20F
0107A:  MOVLB  0
0107C:  RCALL  09D6
....................          WRITE_DATA_BYTE_SMF (address + 2, command[7]) ; 
0107E:  MOVLW  02
01080:  MOVLB  1
01082:  ADDWF  x8E,W
01084:  MOVLB  2
01086:  MOVWF  x07
01088:  MOVLW  00
0108A:  MOVLB  1
0108C:  ADDWFC x8F,W
0108E:  MOVLB  2
01090:  MOVWF  x08
01092:  MOVLW  00
01094:  MOVLB  1
01096:  ADDWFC x90,W
01098:  MOVLB  2
0109A:  MOVWF  x09
0109C:  MOVLW  00
0109E:  MOVLB  1
010A0:  ADDWFC x91,W
010A2:  MOVLB  2
010A4:  MOVWF  x0A
010A6:  MOVWF  x0E
010A8:  MOVFF  209,20D
010AC:  MOVFF  208,20C
010B0:  MOVFF  207,20B
010B4:  MOVFF  13F,20F
010B8:  MOVLB  0
010BA:  RCALL  09D6
....................          WRITE_DATA_BYTE_SMF (address + 3, command[8]) ; 
010BC:  MOVLW  03
010BE:  MOVLB  1
010C0:  ADDWF  x8E,W
010C2:  MOVLB  2
010C4:  MOVWF  x07
010C6:  MOVLW  00
010C8:  MOVLB  1
010CA:  ADDWFC x8F,W
010CC:  MOVLB  2
010CE:  MOVWF  x08
010D0:  MOVLW  00
010D2:  MOVLB  1
010D4:  ADDWFC x90,W
010D6:  MOVLB  2
010D8:  MOVWF  x09
010DA:  MOVLW  00
010DC:  MOVLB  1
010DE:  ADDWFC x91,W
010E0:  MOVLB  2
010E2:  MOVWF  x0A
010E4:  MOVWF  x0E
010E6:  MOVFF  209,20D
010EA:  MOVFF  208,20C
010EE:  MOVFF  207,20B
010F2:  MOVFF  140,20F
010F6:  MOVLB  0
010F8:  RCALL  09D6
....................          fprintf (fab, "Finish 0x14\r\n"); 
010FA:  MOVLW  5A
010FC:  MOVWF  FF6
010FE:  MOVLW  05
01100:  MOVWF  FF7
01102:  MOVLW  00
01104:  MOVWF  FF8
01106:  CALL   07AC
....................          break; 
0110A:  BRA    1490
....................           
....................          case 0x16: 
....................          output_low (PIN_A5); 
0110C:  BCF    F92.5
0110E:  BCF    F89.5
....................          fprintf(fab, "Start 0x16\r\n"); 
01110:  MOVLW  68
01112:  MOVWF  FF6
01114:  MOVLW  05
01116:  MOVWF  FF7
01118:  MOVLW  00
0111A:  MOVWF  FF8
0111C:  CALL   07AC
....................          address_data[0] = command[1]<<24; 
01120:  MOVFF  139,181
01124:  MOVLB  1
01126:  CLRF   x7E
01128:  CLRF   x7F
0112A:  CLRF   x80
....................          address_data[1] = command[2]<<16; 
0112C:  MOVFF  13A,184
01130:  CLRF   x82
01132:  CLRF   x83
01134:  CLRF   x85
....................          address_data[2] = command[3]<<8; 
01136:  MOVFF  13B,187
0113A:  CLRF   x86
0113C:  CLRF   x88
0113E:  CLRF   x89
....................          address_data[3] = command[4]; 
01140:  CLRF   x8D
01142:  CLRF   x8C
01144:  CLRF   x8B
01146:  MOVFF  13C,18A
....................          address = address_data[0] + address_data[1] + address_data[2] + address_data[3]; 
0114A:  MOVF   x82,W
0114C:  ADDWF  x7E,W
0114E:  MOVLB  2
01150:  MOVWF  x07
01152:  MOVLB  1
01154:  MOVF   x83,W
01156:  ADDWFC x7F,W
01158:  MOVLB  2
0115A:  MOVWF  x08
0115C:  MOVLB  1
0115E:  MOVF   x84,W
01160:  ADDWFC x80,W
01162:  MOVLB  2
01164:  MOVWF  x09
01166:  MOVLB  1
01168:  MOVF   x85,W
0116A:  ADDWFC x81,W
0116C:  MOVLB  2
0116E:  MOVWF  x0A
01170:  MOVLB  1
01172:  MOVF   x86,W
01174:  MOVLB  2
01176:  ADDWF  x07,F
01178:  MOVLB  1
0117A:  MOVF   x87,W
0117C:  MOVLB  2
0117E:  ADDWFC x08,F
01180:  MOVLB  1
01182:  MOVF   x88,W
01184:  MOVLB  2
01186:  ADDWFC x09,F
01188:  MOVLB  1
0118A:  MOVF   x89,W
0118C:  MOVLB  2
0118E:  ADDWFC x0A,F
01190:  MOVLB  1
01192:  MOVF   x8A,W
01194:  MOVLB  2
01196:  ADDWF  x07,W
01198:  MOVLB  1
0119A:  MOVWF  x8E
0119C:  MOVF   x8B,W
0119E:  MOVLB  2
011A0:  ADDWFC x08,W
011A2:  MOVLB  1
011A4:  MOVWF  x8F
011A6:  MOVF   x8C,W
011A8:  MOVLB  2
011AA:  ADDWFC x09,W
011AC:  MOVLB  1
011AE:  MOVWF  x90
011B0:  MOVF   x8D,W
011B2:  MOVLB  2
011B4:  ADDWFC x0A,W
011B6:  MOVLB  1
011B8:  MOVWF  x91
....................             switch(command[5]){ 
011BA:  MOVF   x3D,W
011BC:  XORLW  04
011BE:  MOVLB  0
011C0:  BZ    11CC
011C2:  XORLW  36
011C4:  BZ    11F0
011C6:  XORLW  56
011C8:  BZ    1214
011CA:  BRA    1238
....................                case 0x04: 
....................                   SUBSECTOR_4KB_ERASE_SMF(address); 
011CC:  MOVFF  191,20A
011D0:  MOVFF  190,209
011D4:  MOVFF  18F,208
011D8:  MOVFF  18E,207
011DC:  BRA    0A4A
....................                   fprintf(fab, "Erased 4kb\r\n"); 
011DE:  MOVLW  76
011E0:  MOVWF  FF6
011E2:  MOVLW  05
011E4:  MOVWF  FF7
011E6:  MOVLW  00
011E8:  MOVWF  FF8
011EA:  CALL   07AC
....................                   break; 
011EE:  BRA    1238
....................                case 0x32: 
....................                   SUBSECTOR_32KB_ERASE_SMF(address); 
011F0:  MOVFF  191,20A
011F4:  MOVFF  190,209
011F8:  MOVFF  18F,208
011FC:  MOVFF  18E,207
01200:  BRA    0ADC
....................                   fprintf(fab, "Erased 32kb\r\n"); 
01202:  MOVLW  84
01204:  MOVWF  FF6
01206:  MOVLW  05
01208:  MOVWF  FF7
0120A:  MOVLW  00
0120C:  MOVWF  FF8
0120E:  CALL   07AC
....................                   break; 
01212:  BRA    1238
....................                case 0x64: 
....................                   sector_erase_SMF(address); 
01214:  MOVFF  191,20A
01218:  MOVFF  190,209
0121C:  MOVFF  18F,208
01220:  MOVFF  18E,207
01224:  CALL   0946
....................                   fprintf(fab, "Erased 64kb\r\n"); 
01228:  MOVLW  92
0122A:  MOVWF  FF6
0122C:  MOVLW  05
0122E:  MOVWF  FF7
01230:  MOVLW  00
01232:  MOVWF  FF8
01234:  CALL   07AC
....................                   break; 
....................             } 
....................          fprintf(fab, "Finish 0x16\r\n"); 
01238:  MOVLW  A0
0123A:  MOVWF  FF6
0123C:  MOVLW  05
0123E:  MOVWF  FF7
01240:  MOVLW  00
01242:  MOVWF  FF8
01244:  CALL   07AC
....................          break; 
01248:  BRA    1490
....................           
....................          /* case 0x91: 
....................          reset_time_data[0] = 0x82; 
....................          //fprintf (PC, "Command 2 Recieved\r\n") ; 
....................          //fputc (reset_time_data[0], PC) ; 
....................          fputc (0x91, reset); 
....................          break; */ 
....................          case 0x91: 
....................          fprintf (fab, "Start 0x91\r\n"); 
0124A:  MOVLW  AE
0124C:  MOVWF  FF6
0124E:  MOVLW  05
01250:  MOVWF  FF7
01252:  MOVLW  00
01254:  MOVWF  FF8
01256:  CALL   07AC
....................          for (i = 0; i < 9; i++) 
0125A:  MOVLB  1
0125C:  CLRF   xF6
0125E:  MOVF   xF6,W
01260:  SUBLW  08
01262:  BNC   129E
....................          { 
....................             PINO_DATA[i] = command[i]; 
01264:  CLRF   03
01266:  MOVF   xF6,W
01268:  ADDLW  4C
0126A:  MOVWF  01
0126C:  MOVLW  01
0126E:  ADDWFC 03,F
01270:  MOVLB  2
01272:  MOVFF  03,208
01276:  CLRF   03
01278:  MOVLB  1
0127A:  MOVF   xF6,W
0127C:  ADDLW  38
0127E:  MOVWF  FE9
01280:  MOVLW  01
01282:  ADDWFC 03,W
01284:  MOVWF  FEA
01286:  MOVFF  FEF,209
0128A:  MOVLB  2
0128C:  MOVFF  208,FEA
01290:  MOVFF  01,FE9
01294:  MOVFF  209,FEF
01298:  MOVLB  1
0129A:  INCF   xF6,F
0129C:  BRA    125E
....................          } 
....................           
....................          for (i = 0; i<24; i++) 
0129E:  CLRF   xF6
012A0:  MOVF   xF6,W
012A2:  SUBLW  17
012A4:  BNC   12C2
....................          { 
....................             fputc (PINO_DATA[i], DC); 
012A6:  CLRF   03
012A8:  MOVF   xF6,W
012AA:  ADDLW  4C
012AC:  MOVWF  FE9
012AE:  MOVLW  01
012B0:  ADDWFC 03,W
012B2:  MOVWF  FEA
012B4:  MOVFF  FEF,210
012B8:  MOVLB  0
012BA:  RCALL  0B6E
012BC:  MOVLB  1
012BE:  INCF   xF6,F
012C0:  BRA    12A0
....................          } 
....................          fprintf (fab, "Finish 0x91\r\n") ; 
012C2:  MOVLW  BC
012C4:  MOVWF  FF6
012C6:  MOVLW  05
012C8:  MOVWF  FF7
012CA:  MOVLW  00
012CC:  MOVWF  FF8
012CE:  MOVLB  0
012D0:  CALL   07AC
....................          break; 
012D4:  BRA    1490
....................           
....................          case 0x92: 
....................          fprintf (fab, "Start 0x92\r\n") ; 
012D6:  MOVLW  CA
012D8:  MOVWF  FF6
012DA:  MOVLW  05
012DC:  MOVWF  FF7
012DE:  MOVLW  00
012E0:  MOVWF  FF8
012E2:  CALL   07AC
....................          for (i = 0; i < 9; i++) 
012E6:  MOVLB  1
012E8:  CLRF   xF6
012EA:  MOVF   xF6,W
012EC:  SUBLW  08
012EE:  BNC   132A
....................          { 
....................             PINO_data[i] = command[i]; 
012F0:  CLRF   03
012F2:  MOVF   xF6,W
012F4:  ADDLW  4C
012F6:  MOVWF  01
012F8:  MOVLW  01
012FA:  ADDWFC 03,F
012FC:  MOVLB  2
012FE:  MOVFF  03,208
01302:  CLRF   03
01304:  MOVLB  1
01306:  MOVF   xF6,W
01308:  ADDLW  38
0130A:  MOVWF  FE9
0130C:  MOVLW  01
0130E:  ADDWFC 03,W
01310:  MOVWF  FEA
01312:  MOVFF  FEF,209
01316:  MOVLB  2
01318:  MOVFF  208,FEA
0131C:  MOVFF  01,FE9
01320:  MOVFF  209,FEF
01324:  MOVLB  1
01326:  INCF   xF6,F
01328:  BRA    12EA
....................          } 
....................           
....................          for (i = 0; i<24; i++) 
0132A:  CLRF   xF6
0132C:  MOVF   xF6,W
0132E:  SUBLW  17
01330:  BNC   134E
....................          { 
....................             fputc (PINO_DATA[i], DC); 
01332:  CLRF   03
01334:  MOVF   xF6,W
01336:  ADDLW  4C
01338:  MOVWF  FE9
0133A:  MOVLW  01
0133C:  ADDWFC 03,W
0133E:  MOVWF  FEA
01340:  MOVFF  FEF,210
01344:  MOVLB  0
01346:  RCALL  0B6E
01348:  MOVLB  1
0134A:  INCF   xF6,F
0134C:  BRA    132C
....................          } 
....................           
....................          while (1) 
....................          { 
....................             if (kbhit (DC)) 
0134E:  BTFSC  F86.1
01350:  BRA    13C6
....................             { 
....................                for (i = 0; i < 10; i++) 
01352:  CLRF   xF6
01354:  MOVF   xF6,W
01356:  SUBLW  09
01358:  BNC   1386
....................                { 
....................                   Down[i] = fgetc (DC); 
0135A:  CLRF   03
0135C:  MOVF   xF6,W
0135E:  ADDLW  9A
01360:  MOVWF  FE9
01362:  MOVLW  01
01364:  ADDWFC 03,W
01366:  MOVWF  FEA
01368:  MOVFF  FEA,20A
0136C:  MOVFF  FE9,209
01370:  MOVLB  0
01372:  BRA    0BB4
01374:  MOVFF  20A,FEA
01378:  MOVFF  209,FE9
0137C:  MOVFF  01,FEF
01380:  MOVLB  1
01382:  INCF   xF6,F
01384:  BRA    1354
....................                } 
....................                //fprintf (fab, "Finish transmitting\r\n") ; 
....................                for (i = 0; i < 10; i++) 
01386:  CLRF   xF6
01388:  MOVF   xF6,W
0138A:  SUBLW  09
0138C:  BNC   13B0
....................                { 
....................                   fputc (Down[i], fab); 
0138E:  CLRF   03
01390:  MOVF   xF6,W
01392:  ADDLW  9A
01394:  MOVWF  FE9
01396:  MOVLW  01
01398:  ADDWFC 03,W
0139A:  MOVWF  FEA
0139C:  MOVFF  FEF,207
013A0:  MOVLB  2
013A2:  MOVF   x07,W
013A4:  MOVLB  0
013A6:  CALL   08B0
013AA:  MOVLB  1
013AC:  INCF   xF6,F
013AE:  BRA    1388
....................                } 
....................                fprintf (fab, "Finish 0x92\r\n") ; 
013B0:  MOVLW  D8
013B2:  MOVWF  FF6
013B4:  MOVLW  05
013B6:  MOVWF  FF7
013B8:  MOVLW  00
013BA:  MOVWF  FF8
013BC:  MOVLB  0
013BE:  CALL   07AC
....................                break; 
013C2:  BRA    13CA
013C4:  MOVLB  1
....................             } 
013C6:  BRA    134E
013C8:  MOVLB  0
....................          } 
....................           
....................          case 0x93: 
....................          fprintf(fab, "Start 0x93\r\n"); 
013CA:  MOVLW  E6
013CC:  MOVWF  FF6
013CE:  MOVLW  05
013D0:  MOVWF  FF7
013D2:  MOVLW  00
013D4:  MOVWF  FF8
013D6:  CALL   07AC
....................          output_high (PINO_power); 
013DA:  BCF    F95.5
013DC:  BSF    F8C.5
....................          output_high (sel); 
013DE:  BCF    F95.6
013E0:  BSF    F8C.6
....................          fprintf(fab, "Finish 0x93\r\n"); 
013E2:  MOVLW  F4
013E4:  MOVWF  FF6
013E6:  MOVLW  05
013E8:  MOVWF  FF7
013EA:  MOVLW  00
013EC:  MOVWF  FF8
013EE:  CALL   07AC
....................           
....................          case 0x94: 
....................          fprintf (fab, "Start 0x94\r\n") ; 
013F2:  MOVLW  02
013F4:  MOVWF  FF6
013F6:  MOVLW  06
013F8:  MOVWF  FF7
013FA:  MOVLW  00
013FC:  MOVWF  FF8
013FE:  CALL   07AC
....................          for (i = 0; i < 5; i++) 
01402:  MOVLB  1
01404:  CLRF   xF6
01406:  MOVF   xF6,W
01408:  SUBLW  04
0140A:  BNC   142C
....................          { 
....................             GET_RESET_DATA (); 
0140C:  MOVLB  0
0140E:  RCALL  0CBA
....................             delay_ms(5000); 
01410:  MOVLW  14
01412:  MOVLB  2
01414:  MOVWF  x07
01416:  MOVLW  FA
01418:  MOVWF  x10
0141A:  MOVLB  0
0141C:  CALL   0782
01420:  MOVLB  2
01422:  DECFSZ x07,F
01424:  BRA    1416
01426:  MOVLB  1
01428:  INCF   xF6,F
0142A:  BRA    1406
....................          } 
....................          fprintf (fab, "Finish 0x94\r\n") ; 
0142C:  MOVLW  10
0142E:  MOVWF  FF6
01430:  MOVLW  06
01432:  MOVWF  FF7
01434:  MOVLW  00
01436:  MOVWF  FF8
01438:  MOVLB  0
0143A:  CALL   07AC
....................          break; 
0143E:  BRA    1490
....................           
....................          case 0x9B: 
....................          fprintf (fab, "Start 0x9B\r\n") ; 
01440:  MOVLW  1E
01442:  MOVWF  FF6
01444:  MOVLW  06
01446:  MOVWF  FF7
01448:  MOVLW  00
0144A:  MOVWF  FF8
0144C:  CALL   07AC
....................          output_high (hvs); 
01450:  BCF    F95.7
01452:  BSF    F8C.7
....................          fprintf (fab, "Finish 0x9B\r\n"); 
01454:  MOVLW  2C
01456:  MOVWF  FF6
01458:  MOVLW  06
0145A:  MOVWF  FF7
0145C:  MOVLW  00
0145E:  MOVWF  FF8
01460:  CALL   07AC
....................          output_low (PINO_power); 
01464:  BCF    F95.5
01466:  BCF    F8C.5
....................          output_low (sel); 
01468:  BCF    F95.6
0146A:  BCF    F8C.6
....................          break; 
0146C:  BRA    1490
....................           
....................          case 0x9F: 
....................          fprintf (fab, "Start 0x9F\r\n") ; 
0146E:  MOVLW  3A
01470:  MOVWF  FF6
01472:  MOVLW  06
01474:  MOVWF  FF7
01476:  MOVLW  00
01478:  MOVWF  FF8
0147A:  CALL   07AC
....................          GET_RESET_DATA (); 
0147E:  RCALL  0CBA
....................          fprintf (fab, "Finish 0x9F\r\n") ; 
01480:  MOVLW  48
01482:  MOVWF  FF6
01484:  MOVLW  06
01486:  MOVWF  FF7
01488:  MOVLW  00
0148A:  MOVWF  FF8
0148C:  CALL   07AC
....................          break; 
....................           
....................  
....................       } 
01490:  MOVLB  1
01492:  BRA    0DD2
....................    } 
01494:  MOVLB  0
01496:  GOTO   1712 (RETURN)
.................... } 
.................... void GET_RESET_DATA()                                                            //funcion que carga el array HKDATA con los datos del Reset PIC 
.................... { 
....................    dummy[0] = 0x11; 
*
00CBA:  MOVLW  11
00CBC:  MOVLB  1
00CBE:  MOVWF  xF4
....................    Finish_sign[0] = 0xFF; 
00CC0:  SETF   xF5
....................    RESET_DATA = 0; 
00CC2:  MOVLB  0
00CC4:  CLRF   xED
....................    int8 dayh; 
....................    int8 dayl; 
....................    int8 hr; 
....................    int8 min; 
....................    int8 sec; 
....................    int8 j; 
....................    for (int i = 0; i < 6; i++) 
00CC6:  MOVLB  2
00CC8:  CLRF   x0D
00CCA:  MOVF   x0D,W
00CCC:  SUBLW  05
00CCE:  BNC   0CE6
....................    { 
....................       COLLECT_RESET_DATA (); 
00CD0:  MOVLB  0
00CD2:  BRA    0C72
....................       if (reset_bffr[0] == 0x8e) 
00CD4:  MOVF   xEE,W
00CD6:  SUBLW  8E
00CD8:  BNZ   0CE0
....................       { 
....................          break; 
00CDA:  MOVLB  2
00CDC:  BRA    0CE6
00CDE:  MOVLB  0
....................       } 
00CE0:  MOVLB  2
00CE2:  INCF   x0D,F
00CE4:  BRA    0CCA
....................    } 
....................    if (RESET_bffr[0] == 0x8e) 
00CE6:  MOVLB  0
00CE8:  MOVF   xEE,W
00CEA:  SUBLW  8E
00CEC:  BNZ   0DBC
....................    { 
....................       // fprintf (PC, "\r\nRESET DATA OBTAINED\r\n") ; 
....................       for (int num = 0; num < 5; num++)   //carga el array HKDATA con timedata en las posiciones 2 al 6 
00CEE:  MOVLB  2
00CF0:  CLRF   x0E
00CF2:  MOVF   x0E,W
00CF4:  SUBLW  04
00CF6:  BNC   0D2C
....................       { 
....................          reset_time_data[num] = reset_bffr[num + 1]; 
00CF8:  CLRF   03
00CFA:  MOVF   x0E,W
00CFC:  ADDLW  41
00CFE:  MOVWF  01
00D00:  MOVLW  01
00D02:  ADDWFC 03,F
00D04:  MOVFF  03,210
00D08:  MOVLW  01
00D0A:  ADDWF  x0E,W
00D0C:  CLRF   03
00D0E:  ADDLW  EE
00D10:  MOVWF  FE9
00D12:  MOVLW  00
00D14:  ADDWFC 03,W
00D16:  MOVWF  FEA
00D18:  MOVFF  FEF,211
00D1C:  MOVFF  210,FEA
00D20:  MOVFF  01,FE9
00D24:  MOVFF  211,FEF
00D28:  INCF   x0E,F
00D2A:  BRA    0CF2
....................          //fputc (reset_bffr[num + 1], DC); 
....................          //fprintf (PC, " % x, ", reset_bffr[num + 1]) ; 
....................       } 
....................       //fputc (dummy[0], DC); 
....................       sec = reset_time_data[0]; 
00D2C:  MOVFF  141,20B
....................       min = reset_time_data[1]; 
00D30:  MOVFF  142,20A
....................       hr = reset_time_data[2]; 
00D34:  MOVFF  143,209
....................       dayl = reset_time_data[3]; 
00D38:  MOVFF  144,208
....................       dayh = reset_time_data[4]; 
00D3C:  MOVFF  145,207
....................       fprintf (fab, "\r\n") ; 
00D40:  MOVLW  0D
00D42:  BTFSS  FA6.4
00D44:  BRA    0D42
00D46:  MOVLB  F
00D48:  MOVWF  x29
00D4A:  MOVLW  0A
00D4C:  BTFSS  FA6.4
00D4E:  BRA    0D4C
00D50:  MOVWF  x29
....................        
....................       PINO_DATA[0] = 0x81; 
00D52:  MOVLW  81
00D54:  MOVLB  1
00D56:  MOVWF  x4C
....................        
....................       PINO_DATA[1] = reset_time_data[0]; 
00D58:  MOVFF  141,14D
....................       PINO_DATA[2] = reset_time_data[1]; 
00D5C:  MOVFF  142,14E
....................       PINO_DATA[3] = reset_time_data[2]; 
00D60:  MOVFF  143,14F
....................       PINO_DATA[4] = reset_time_data[3]; 
00D64:  MOVFF  144,150
....................       PINO_DATA[5] = reset_time_data[4]; 
00D68:  MOVFF  145,151
....................        
....................       for(i=6; i<39; i++) 
00D6C:  MOVLW  06
00D6E:  MOVLB  2
00D70:  MOVWF  x0D
00D72:  MOVF   x0D,W
00D74:  SUBLW  26
00D76:  BNC   0D8E
....................       { 
....................          PINO_DATA[i] = 0x01; 
00D78:  CLRF   03
00D7A:  MOVF   x0D,W
00D7C:  ADDLW  4C
00D7E:  MOVWF  FE9
00D80:  MOVLW  01
00D82:  ADDWFC 03,W
00D84:  MOVWF  FEA
00D86:  MOVLW  01
00D88:  MOVWF  FEF
00D8A:  INCF   x0D,F
00D8C:  BRA    0D72
....................       } 
....................        
....................        
....................        
....................       for (j = 0; j < 39; j++) 
00D8E:  CLRF   x0C
00D90:  MOVF   x0C,W
00D92:  SUBLW  26
00D94:  BNC   0DB2
....................       { 
....................          //fprintf (fab, " % x, ", PINO_DATA[j]) ; 
....................           
....................          fputc (PINO_DATA[j], DC); 
00D96:  CLRF   03
00D98:  MOVF   x0C,W
00D9A:  ADDLW  4C
00D9C:  MOVWF  FE9
00D9E:  MOVLW  01
00DA0:  ADDWFC 03,W
00DA2:  MOVWF  FEA
00DA4:  MOVFF  FEF,210
00DA8:  MOVLB  0
00DAA:  RCALL  0B6E
00DAC:  MOVLB  2
00DAE:  INCF   x0C,F
00DB0:  BRA    0D90
....................       } 
....................       fputc (Finish_sign[0], DC); 
00DB2:  MOVFF  1F5,210
00DB6:  MOVLB  0
00DB8:  RCALL  0B6E
....................        
....................       //fprintf (fab, "\r\n") ; 
....................        
....................       }else{ 
00DBA:  BRA    0DCA
....................       fprintf (fab, "\r\nRESET DATA NOT OBTAINED\r\n") ; 
00DBC:  MOVLW  56
00DBE:  MOVWF  FF6
00DC0:  MOVLW  06
00DC2:  MOVWF  FF7
00DC4:  MOVLW  00
00DC6:  MOVWF  FF8
00DC8:  RCALL  07AC
....................    } 
....................    return; 
00DCA:  RETURN 0
.................... } 
....................  
....................  
.................... #include<SATELLITE_LOG.c> 
.................... void waiting(int32 counterval)                                                   //about 200000 : 1s 
.................... { 
....................    for(int32 num = 0; num < counterval; num++) 
*
00C32:  MOVLB  2
00C34:  CLRF   x17
00C36:  CLRF   x16
00C38:  CLRF   x15
00C3A:  CLRF   x14
00C3C:  MOVF   x17,W
00C3E:  SUBWF  x13,W
00C40:  BNC   0C6C
00C42:  BNZ   0C5A
00C44:  MOVF   x16,W
00C46:  SUBWF  x12,W
00C48:  BNC   0C6C
00C4A:  BNZ   0C5A
00C4C:  MOVF   x15,W
00C4E:  SUBWF  x11,W
00C50:  BNC   0C6C
00C52:  BNZ   0C5A
00C54:  MOVF   x10,W
00C56:  SUBWF  x14,W
00C58:  BC    0C6C
....................    {} 
00C5A:  MOVLW  01
00C5C:  ADDWF  x14,F
00C5E:  BTFSC  FD8.0
00C60:  INCF   x15,F
00C62:  BTFSC  FD8.2
00C64:  INCF   x16,F
00C66:  BTFSC  FD8.2
00C68:  INCF   x17,F
00C6A:  BRA    0C3C
....................    return; 
00C6C:  MOVLB  0
00C6E:  GOTO   0CA2 (RETURN)
.................... } 
....................  
.................... //--------RESET Function--------------------------------------------- 
....................  
....................  
.................... void DELETE_RESET()                                                              //funcion que pone a cero el vector reset_bffr[] 
.................... { 
....................    for(int8 num = 0; num < Reset_size; num++) 
*
00C00:  MOVLB  2
00C02:  CLRF   x10
00C04:  MOVF   x10,W
00C06:  SUBLW  0A
00C08:  BNC   0C1E
....................    { 
....................       reset_bffr[num] = 0; 
00C0A:  CLRF   03
00C0C:  MOVF   x10,W
00C0E:  ADDLW  EE
00C10:  MOVWF  FE9
00C12:  MOVLW  00
00C14:  ADDWFC 03,W
00C16:  MOVWF  FEA
00C18:  CLRF   FEF
00C1A:  INCF   x10,F
00C1C:  BRA    0C04
....................    } 
....................    return; 
00C1E:  MOVLB  0
00C20:  GOTO   0C74 (RETURN)
.................... } 
....................  
.................... void SEND_CMD_FOR_RESET_SATELLITE() 
.................... {   
....................    STORE_FLAG_INFO();                                                            //save flag data to flash memory 
....................    //Save_RSV();                                                                   //save in flash memory reserve_table[] content 
....................    STORE_ADRESS_DATA_TO_FLASH(); 
.................... // while(true) 
.................... // { 
....................       //fputc(0x27,PC); 
....................       fprintf(PC,"%x,",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-122));                   //sec 
....................       fprintf(PC,"%x,",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-121));                   //min 
....................       fprintf(PC,"%x,",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-120));                   //hou 
....................       fprintf(PC,"%x",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-119));                    //day H 
....................       fprintf(PC,"%x\r\n",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-118));                //day L 
....................         for(int i = 0; i<100; i++) 
....................         { 
....................          fputc(0x27,reset);                                                      //send command for satellite reset 
....................          delay_ms(10); 
....................         } 
....................       //delay_ms(100);//if it is needed 
.................... //!      fputc(READ_DATA_BYTE_OF(FAB_HK_ADDRESS-122),reset); 
.................... //!      fputc(READ_DATA_BYTE_OF(FAB_HK_ADDRESS-121),reset); 
.................... //!      fputc(READ_DATA_BYTE_OF(FAB_HK_ADDRESS-120),reset); 
.................... //!      fputc(READ_DATA_BYTE_OF(FAB_HK_ADDRESS-119),reset); 
.................... //!      fputc(READ_DATA_BYTE_OF(FAB_HK_ADDRESS-118),reset); 
....................       RESET_DATA = 0; 
....................       fprintf(PC,"Ready for reset"); 
....................       delay_ms(1000); 
.................... // } 
....................    return; 
.................... } 
....................  
.................... void RESET_SATELLITE()                                                           //if get reset command from reset, prepare for resetting 
.................... { 
....................    if(reset_flag == 1)                                                           //get ready for reset satellite 
....................    { 
....................       SEND_CMD_FOR_RESET_SATELLITE();                                            //store flag, save RSV, store Address, send command and wait for reset 
....................    } 
....................    DELETE_RESET();                                                               //load zero in reset_bffr[] 
....................    RESET_DATA = 0; 
....................    return; 
.................... } 
....................  
.................... void COLLECT_RESET_DATA()                                                        //funcion que envia el comando 0x28 al reset PIC y carga reset_bffr[] 
.................... { 
....................    DELETE_RESET();                                                               //pone a cero todas las posiciones del vector 
*
00C72:  BRA    0C00
....................    RESET_DATA = 0; 
00C74:  CLRF   xED
....................    for(int m=0; m<10; m++) 
00C76:  MOVLB  2
00C78:  CLRF   x0F
00C7A:  MOVF   x0F,W
00C7C:  SUBLW  09
00C7E:  BNC   0CB4
....................    { 
....................       fputc(0x28,reset);                                                            //Envia el comando 0x28 en el puerto del reset PIC 
00C80:  MOVLW  28
00C82:  MOVLB  0
00C84:  BRA    0C24
....................       delay_ms(10); 
00C86:  MOVLW  0A
00C88:  MOVLB  2
00C8A:  MOVWF  x10
00C8C:  MOVLB  0
00C8E:  RCALL  0782
....................       waiting(10000);                                                               //wait aprox 0.5s para que el RESET PIC envie los datos por el UART (interrupcion) 
00C90:  MOVLB  2
00C92:  CLRF   x13
00C94:  CLRF   x12
00C96:  MOVLW  27
00C98:  MOVWF  x11
00C9A:  MOVLW  10
00C9C:  MOVWF  x10
00C9E:  MOVLB  0
00CA0:  BRA    0C32
....................          if(RESET_bffr[0] == 0x8e) 
00CA2:  MOVF   xEE,W
00CA4:  SUBLW  8E
00CA6:  BNZ   0CAE
....................          { 
....................          break; 
00CA8:  MOVLB  2
00CAA:  BRA    0CB4
00CAC:  MOVLB  0
....................          } 
00CAE:  MOVLB  2
00CB0:  INCF   x0F,F
00CB2:  BRA    0C7A
....................    } 
....................    return; 
00CB4:  MOVLB  0
00CB6:  GOTO   0CD4 (RETURN)
.................... } 
....................  
....................  
.................... //@@@@@@@@@@@for satellite log@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... #define logdata_size 11 
.................... int8 satellitelog[logdata_size] = {}; 
....................  
.................... void SAVE_SAT_LOG(int8 data1, int8 data2, int8 data3) 
.................... { 
....................    LOOP_SAT_LOG();                                                               //hace un loop en las posiciones de memoria para almacenar SAT_LOG 
....................    RESET_DATA = 0; 
....................    COLLECT_RESET_DATA();                                                         //carga el RESET_bffr[] con los datos del reset PIC 
....................    if(RESET_bffr[0] == 0x8e) 
....................    { 
....................       satellitelog[0] = 0xda;                                                    //header of the satellite log 
....................       satellitelog[1] = 0xda;                                                    //header of the satellite log 
....................     
....................       satellitelog[2] = RESET_bffr[1]; 
....................       satellitelog[3] = RESET_bffr[2]; 
....................       satellitelog[4] = RESET_bffr[3]; 
....................       satellitelog[5] = RESET_bffr[4]; 
....................       satellitelog[6] = RESET_bffr[5]; 
....................        
....................       satellitelog[7] = data1; 
....................       satellitelog[8] = data2; 
....................       satellitelog[9] = data3; 
....................       satellitelog[10] = 0xef;                                                   //footer, fin del array 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX main side 
....................       output_low(PIN_C4);                                                        //COM_MUX main side 
....................       for(int i = 0; i < logdata_size; i++)                                      //guarda el dato en las tres Flash en la posicion de memoria indicada por SAT_LOG  
....................       { 
....................          WRITE_DATA_BYTE_OF(SAT_LOG + i,satellitelog[i]); 
....................          WRITE_DATA_BYTE_SCF(SAT_LOG + i,satellitelog[i]); 
....................          WRITE_DATA_BYTE_SMF(SAT_LOG + i,satellitelog[i]); 
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COM side 
....................       SAT_LOG = SAT_LOG + logdata_size; 
....................       fprintf(PC,"LOG saving done\r\n"); 
....................    } 
....................     
....................    return; 
.................... } 
....................  
....................  
....................  
....................  
.................... //----------Flash_memory_MT25QL01GBBB_OF.c------------------------------------- 
....................  
.................... void WRITE_ENABLE_OF(); 
.................... void WRITE_ENABLE_SCF(); 
.................... void WRITE_ENABLE_SMF(); 
....................  
.................... void sector_erase_OF(unsigned int32 sector_address); 
.................... void sector_erase_SCF(unsigned int32 sector_address); 
.................... void sector_erase_SMF(unsigned int32 sector_address); 
....................  
.................... void SUBSECTOR_4KB_ERASE_OF(unsigned int32 sector_address); 
.................... void SUBSECTOR_4KB_ERASE_SCF(unsigned int32 sector_address); 
.................... void SUBSECTOR_4KB_ERASE_SMF(unsigned int32 sector_address); 
....................  
.................... void SUBSECTOR_32KB_ERASE_OF(unsigned int32 sector_address); 
.................... void SUBSECTOR_32KB_ERASE_SCF(unsigned int32 sector_address); 
.................... void SUBSECTOR_32KB_ERASE_SMF(unsigned int32 sector_address); 
....................  
.................... void WRITE_DATA_BYTE_OF(unsigned int32 page_address, int8 data); 
.................... void WRITE_DATA_BYTE_SCF(unsigned int32 page_address, int8 data); 
.................... void WRITE_DATA_BYTE_SMF(unsigned int32 page_address, int8 data); 
....................  
.................... int8 READ_CHIP_ID_OF(); 
.................... int8 READ_CHIP_ID_SCF(); 
.................... int8 READ_CHIP_ID_SMF(); 
....................  
.................... int8 READ_STATUS_REGISTER_OF(); 
.................... int8 READ_STATUS_REGISTER_SCF(); 
.................... int8 READ_STATUS_REGISTER_SMF(); 
....................  
.................... int8 READ_DATA_BYTE_OF(unsigned INT32 ADDRESS); 
.................... int8 READ_DATA_BYTE_SCF(unsigned INT32 ADDRESS); 
.................... int8 READ_DATA_BYTE_SMF(unsigned INT32 ADDRESS); 
....................  
.................... void TRANSFER_DATA_256byte_OF(unsigned INT32 ADRESS, int PORT_NUM); 
.................... void TRANSFER_DATA_256byte_SCF(unsigned INT32 ADRESS, int PORT_NUM); 
.................... void TRANSFER_DATA_256byte_SMF(unsigned INT32 ADRESS, int PORT_NUM); 
....................  
.................... void WRITE_DATA_NBYTE_OF(unsigned INT32 ADDRES,int32 data_byte); 
.................... void WRITE_DATA_NBYTE_SCF(unsigned INT32 ADDRES,int32 data_byte); 
.................... void WRITE_DATA_NBYTE_SMF(unsigned INT32 ADDRES,int32 data_byte); 
....................  
.................... void TRANSFER_DATA_NBYTE_TOPC_OF(unsigned INT32 ADRESS,int32 data_byte); //for testing 
.................... void TRANSFER_DATA_NBYTE_TOPC_SCF(unsigned INT32 ADRESS,int32 data_byte); //for testing 
.................... void TRANSFER_DATA_NBYTE_TOPC_SMF(unsigned INT32 ADRESS,int32 data_byte); //for testing 
....................  
.................... void TRANSFER_DATA_NBYTE_OFtoSCF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //transfer data from MAIN FLASH to COM FLASH 
.................... void TRANSFER_DATA_NBYTE_SCFtoOF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //transfer data from COM FLASH to MAIN FLASH 
.................... void TRANSFER_DATA_NBYTE_OFtoSMF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //transfer data from MAIN FLASH to MISSION FLASH 
.................... void TRANSFER_DATA_NBYTE_SMFtoOF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //transfer data from MISSION FLASH to MAIN FLASH 
.................... void TRANSFER_DATA_NBYTE_SMFtoSCF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //transfer data from MISSION FLASH to COM FLASH 
.................... void TRANSFER_DATA_NBYTE_SCFtoSMF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //transfer data from COM FLASH to MISSION FLASH 
....................  
.................... void TRANSFER_DATA_NBYTE_OF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //for testing 
....................  
.................... //void sector_erase(unsigned int32 sector_address);  //this is for sector erase 
....................  
....................  
.................... //----------------------------------------------------------------------------- 
....................  
....................  
....................  
....................  
.................... #INT_rda4                                                                        //Reset PIC Interrupt, RS232 receive data available in buffer 4 
.................... void UART4_RXD(void) 
.................... { 
....................    reset_bffr[RESET_DATA] = fgetc(reset);                                        //loads the reset_bffr array with the data sent by the Reset PIC (carga el array reset_bffr con los datos enviados por el Reset PIC) 
*
006DE:  CLRF   03
006E0:  MOVF   xED,W
006E2:  ADDLW  EE
006E4:  MOVWF  FE9
006E6:  MOVLW  00
006E8:  ADDWFC 03,W
006EA:  MOVWF  FEA
006EC:  MOVFF  FEA,225
006F0:  MOVFF  FE9,224
006F4:  BRA    0694
006F6:  MOVFF  225,FEA
006FA:  MOVFF  224,FE9
006FE:  MOVFF  01,FEF
....................    RESET_DATA = ((RESET_DATA + 1) % RESET_size);                                 //when the data is obtained in position 11 RESET_DATA = 0 (cuando se obtenga el dato en la posicion 11 RESET_DATA=0) 
00702:  MOVLW  01
00704:  ADDWF  xED,W
00706:  MOVLB  2
00708:  MOVWF  x23
0070A:  MOVWF  x24
0070C:  MOVLW  0B
0070E:  MOVWF  x25
00710:  MOVLB  0
00712:  BRA    06B0
00714:  MOVFF  00,ED
....................    if(reset_bffr[0] == 0xaa)                                                     //get ready for reset satellite 
00718:  MOVF   xEE,W
0071A:  SUBLW  AA
0071C:  BNZ   0724
....................    { 
....................       reset_flag = 1;                                                            //raise flag to reset (pone a alto bandera para reseteo) 
0071E:  MOVLW  01
00720:  MOVWF  xF9
....................       RESET_DATA = 0;                                                            //position indicator within reset_data vector (indicador de posicion dentro del vector reset_data) 
00722:  CLRF   xED
....................    } 
....................     
00724:  BCF    FA6.7
00726:  GOTO   0078
.................... }  
....................  
.................... void main() 
*
0149A:  CLRF   FF8
0149C:  BCF    FA9.7
0149E:  BSF    FD0.7
014A0:  BSF    07.7
014A2:  MOVLB  E
014A4:  MOVLW  55
014A6:  MOVWF  F7E
014A8:  MOVLW  AA
014AA:  MOVWF  F7E
014AC:  BCF    F66.6
014AE:  MOVLW  F4
014B0:  MOVWF  x2A
014B2:  MOVLW  F5
014B4:  MOVWF  x2B
014B6:  MOVLW  F8
014B8:  MOVWF  x2C
014BA:  MOVLW  F9
014BC:  MOVWF  x2D
014BE:  MOVLW  01
014C0:  MOVWF  x1B
014C2:  MOVLW  20
014C4:  MOVWF  x1D
014C6:  MOVLW  30
014C8:  MOVWF  x22
014CA:  MOVLW  20
014CC:  MOVWF  x24
014CE:  MOVLW  55
014D0:  MOVWF  F7E
014D2:  MOVLW  AA
014D4:  MOVWF  F7E
014D6:  BSF    F66.6
014D8:  CLRF   F9B
014DA:  CLRF   F64
014DC:  CLRF   F65
014DE:  CLRF   F66
014E0:  MOVLW  02
014E2:  MOVWF  FD3
014E4:  BSF    F67.3
014E6:  MOVLW  22
014E8:  MOVWF  FAF
014EA:  MOVLW  00
014EC:  MOVLB  F
014EE:  MOVWF  x30
014F0:  MOVLW  A6
014F2:  MOVWF  FAC
014F4:  MOVLW  90
014F6:  MOVWF  FAB
014F8:  CLRF   1B
014FA:  BSF    x31.3
014FC:  MOVLW  A0
014FE:  MOVWF  x1F
01500:  MOVLW  01
01502:  MOVWF  x20
01504:  MOVLW  A6
01506:  MOVWF  x32
01508:  MOVLW  90
0150A:  MOVWF  x33
0150C:  MOVLB  E
0150E:  BSF    xFD.3
01510:  MOVLW  A0
01512:  MOVWF  xFB
01514:  MOVLW  01
01516:  MOVWF  xFC
01518:  MOVLW  A6
0151A:  MOVWF  xFE
0151C:  MOVLW  90
0151E:  MOVWF  xFF
01520:  MOVLB  F
01522:  BSF    x2D.3
01524:  MOVLW  A0
01526:  MOVWF  x2B
01528:  MOVLW  01
0152A:  MOVWF  x2C
0152C:  MOVLW  A6
0152E:  MOVWF  x2E
01530:  MOVLW  90
01532:  MOVWF  x2F
01534:  BCF    F98.2
01536:  BSF    F8F.2
01538:  BCF    F98.0
0153A:  BSF    F8F.0
0153C:  BSF    F96.0
0153E:  BCF    F96.6
01540:  BCF    F96.1
01542:  BCF    F8D.1
01544:  BSF    F93.5
01546:  BCF    F93.4
01548:  BCF    F93.2
0154A:  BCF    F8A.2
0154C:  BSF    F92.0
0154E:  BCF    F92.1
01550:  BCF    F92.3
01552:  BCF    F89.3
01554:  CLRF   1F
01556:  CLRF   1E
01558:  MOVLW  10
0155A:  MOVWF  1D
0155C:  CLRF   1C
0155E:  CLRF   23
01560:  CLRF   22
01562:  CLRF   21
01564:  CLRF   20
01566:  CLRF   27
01568:  MOVLW  04
0156A:  MOVWF  26
0156C:  CLRF   25
0156E:  CLRF   24
01570:  CLRF   2B
01572:  MOVLW  05
01574:  MOVWF  2A
01576:  CLRF   29
01578:  CLRF   28
0157A:  CLRF   2F
0157C:  MOVLW  06
0157E:  MOVWF  2E
01580:  CLRF   2D
01582:  CLRF   2C
01584:  CLRF   33
01586:  MOVLW  08
01588:  MOVWF  32
0158A:  CLRF   31
0158C:  CLRF   30
0158E:  CLRF   37
01590:  MOVLW  62
01592:  MOVWF  36
01594:  CLRF   35
01596:  CLRF   34
01598:  MOVLW  04
0159A:  MOVWF  3B
0159C:  MOVLW  4A
0159E:  MOVWF  3A
015A0:  CLRF   39
015A2:  CLRF   38
015A4:  MOVLW  04
015A6:  MOVWF  3F
015A8:  MOVLW  72
015AA:  MOVWF  3E
015AC:  CLRF   3D
015AE:  CLRF   3C
015B0:  MOVLW  06
015B2:  MOVWF  43
015B4:  MOVLW  65
015B6:  MOVWF  42
015B8:  CLRF   41
015BA:  CLRF   40
015BC:  MOVLW  06
015BE:  MOVWF  47
015C0:  MOVLW  66
015C2:  MOVWF  46
015C4:  CLRF   45
015C6:  CLRF   44
015C8:  MOVLW  06
015CA:  MOVWF  4B
015CC:  MOVLW  67
015CE:  MOVWF  4A
015D0:  CLRF   49
015D2:  CLRF   48
015D4:  CLRF   4F
015D6:  MOVLW  01
015D8:  MOVWF  4E
015DA:  MOVLW  80
015DC:  MOVWF  4D
015DE:  CLRF   4C
015E0:  CLRF   53
015E2:  MOVLW  01
015E4:  MOVWF  52
015E6:  MOVLW  80
015E8:  MOVWF  51
015EA:  MOVLW  1C
015EC:  MOVWF  50
015EE:  CLRF   54
015F0:  CLRF   56
015F2:  CLRF   55
015F4:  CLRF   57
015F6:  CLRF   58
015F8:  CLRF   59
015FA:  CLRF   5A
015FC:  CLRF   5B
015FE:  CLRF   5C
01600:  CLRF   5D
01602:  CLRF   5E
01604:  CLRF   5F
01606:  MOVLB  0
01608:  CLRF   x60
0160A:  CLRF   x61
0160C:  CLRF   x62
0160E:  CLRF   x63
01610:  CLRF   x64
01612:  CLRF   x65
01614:  CLRF   x66
01616:  CLRF   x67
01618:  CLRF   x68
0161A:  CLRF   x69
0161C:  CLRF   x82
0161E:  CLRF   x83
01620:  CLRF   x84
01622:  CLRF   x85
01624:  CLRF   x86
01626:  CLRF   xEB
01628:  CLRF   xEC
0162A:  CLRF   xED
0162C:  CLRF   xF9
0162E:  MOVLB  1
01630:  CLRF   x34
01632:  CLRF   x33
01634:  CLRF   x35
01636:  CLRF   x37
01638:  CLRF   x36
0163A:  MOVLB  E
0163C:  CLRF   xD9
0163E:  CLRF   xDA
01640:  CLRF   x45
01642:  CLRF   x46
01644:  CLRF   x47
01646:  BCF    x8D.7
01648:  BCF    x8D.6
0164A:  BCF    x8D.5
0164C:  MOVLB  1
0164E:  CLRF   x88
01650:  MOVLB  F
01652:  CLRF   x53
01654:  CLRF   x38
01656:  CLRF   x37
01658:  BRA    1674
0165A:  DATA 18,40
0165C:  DATA 6A,00
0165E:  DATA 64,40
01660:  DATA 87,00
01662:  DATA 0B,40
01664:  DATA EE,00
01666:  DATA 39,40
01668:  DATA FA,00
0166A:  DATA 3D,41
0166C:  DATA 41,00
0166E:  DATA 0B,41
01670:  DATA F7,00
01672:  DATA 00,00
01674:  MOVLW  00
01676:  MOVWF  FF8
01678:  MOVLW  16
0167A:  MOVWF  FF7
0167C:  MOVLW  5A
0167E:  MOVWF  FF6
01680:  TBLRD*+
01682:  MOVF   FF5,W
01684:  MOVWF  00
01686:  XORLW  00
01688:  BZ    16B0
0168A:  TBLRD*+
0168C:  MOVF   FF5,W
0168E:  MOVWF  01
01690:  BTFSC  FE8.7
01692:  BRA    169E
01694:  ANDLW  0F
01696:  MOVWF  FEA
01698:  TBLRD*+
0169A:  MOVFF  FF5,FE9
0169E:  BTFSC  01.6
016A0:  TBLRD*+
016A2:  BTFSS  01.6
016A4:  TBLRD*+
016A6:  MOVFF  FF5,FEE
016AA:  DCFSNZ 00,F
016AC:  BRA    1680
016AE:  BRA    16A2
016B0:  CLRF   FF8
.................... { 
....................    //settings(); 
....................    set_tris_b(0b11010000); 
016B2:  MOVLW  D0
016B4:  MOVWF  F93
....................    enable_interrupts(global); 
016B6:  MOVLW  C0
016B8:  IORWF  FF2,F
....................    enable_interrupts(INT_rda4); 
016BA:  BSF    F61.7
....................    fprintf(PC,"Start Operating\r\n"); 
016BC:  MOVLW  2A
016BE:  MOVWF  FF6
016C0:  MOVLW  07
016C2:  MOVWF  FF7
016C4:  MOVLW  00
016C6:  MOVWF  FF8
016C8:  MOVLB  0
016CA:  CALL   0758
....................    output_high(PIN_A5);  //MUX MISSION SIDE 
016CE:  BCF    F92.5
016D0:  BSF    F89.5
....................    output_low(PIN_A5); //MUX MAIN SIDE 
016D2:  BCF    F92.5
016D4:  BCF    F89.5
....................     
....................    while(TRUE) 
....................    { 
....................       fprintf(PC,"\r\nHello World\r\n"); 
016D6:  MOVLW  3C
016D8:  MOVWF  FF6
016DA:  MOVLW  07
016DC:  MOVWF  FF7
016DE:  MOVLW  00
016E0:  MOVWF  FF8
016E2:  CALL   0758
....................       fprintf(PC,"Operating\r\n"); 
016E6:  MOVLW  4C
016E8:  MOVWF  FF6
016EA:  MOVLW  07
016EC:  MOVWF  FF7
016EE:  MOVLW  00
016F0:  MOVWF  FF8
016F2:  CALL   0758
....................       delay_ms(2500); 
016F6:  MOVLW  0A
016F8:  MOVLB  2
016FA:  MOVWF  x02
016FC:  MOVLW  FA
016FE:  MOVWF  x10
01700:  MOVLB  0
01702:  CALL   0782
01706:  MOVLB  2
01708:  DECFSZ x02,F
0170A:  BRA    16FC
....................       PINO_Test(); 
0170C:  MOVLB  0
0170E:  GOTO   0DCC
01712:  BRA    16D6
....................    } 
....................  
.................... } 
01714:  SLEEP 

Configuration Fuses:
   Word  1: F6A0   STVREN NOXINST NODEBUG NOBROWNOUT BORV18 NOPROTECT
   Word  2: FFA2   PR SOSC_DIG CLOCKOUT IESO NOPLL
   Word  3: F032   HS
   Word  4: F7FF   WPFP WPDIS WPEND NOWPCFG
   Word  5: FF03   T5G_IS_T5G CINA_DEFAULT IOL1WAY LS48MHZ MSSP2MSK7 MSSPMSK7
   Word  6: FCFF   WDTWIN_25% WDTCLK_FRC WDT32768 NOWDT WINDIS WPRES128
   Word  7: F01D   NOVREGSLEEP VBATBOR DSBOR DS_SW
   Word  8: F3F8   DSWDT_25DAYS DSWDT DSWDTOSC_INT
