CCS PCH C Compiler, Version 5.050, 5967               04-Jul-21 18:43

               Filename:   C:\Users\keena\Dropbox\BIRDS5_Project\BIRDS5_OBC.lst

               ROM used:   6146 bytes (5%)
                           Largest free fragment is 65520
               RAM used:   527 (15%) at main() level
                           563 (16%) worst case
               Stack used: 0 locations
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   1588
*
00008:  NOP   
0000A:  NOP   
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  FF8,18
00058:  MOVFF  FFB,19
0005C:  MOVFF  00,0E
00060:  MOVFF  01,0F
00064:  MOVFF  02,10
00068:  MOVFF  03,11
0006C:  BTFSS  F61.7
0006E:  GOTO   0078
00072:  BTFSC  FA6.7
00074:  GOTO   06DE
00078:  MOVFF  0E,00
0007C:  MOVFF  0F,01
00080:  MOVFF  10,02
00084:  MOVFF  11,03
00088:  MOVFF  0C,FE9
0008C:  MOVFF  07,FEA
00090:  BSF    07.7
00092:  MOVFF  08,FE1
00096:  MOVFF  09,FE2
0009A:  MOVFF  0A,FD9
0009E:  MOVFF  0B,FDA
000A2:  MOVFF  12,FF3
000A6:  MOVFF  13,FF4
000AA:  MOVFF  14,FFA
000AE:  MOVFF  15,FF5
000B2:  MOVFF  16,FF6
000B6:  MOVFF  17,FF7
000BA:  MOVFF  18,FF8
000BE:  MOVFF  19,FFB
000C2:  MOVF   04,W
000C4:  MOVFF  06,FE0
000C8:  MOVFF  05,FD8
000CC:  RETFIE 0
.................... #include <BIRDS5_OBC.h> 
.................... #include <18F67J94.h> 
.................... //////////// Standard Header file for the PIC18F67J94 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F67J94 
000CE:  DATA 0D,0A
000D0:  DATA 50,41
000D2:  DATA 53,53
000D4:  DATA 45,44
000D6:  DATA 20,44
000D8:  DATA 41,59
000DA:  DATA 53,3A
000DC:  DATA 25,78
000DE:  DATA 0D,0A
000E0:  DATA 00,00
000E2:  DATA 52,45
000E4:  DATA 53,45
000E6:  DATA 52,56
000E8:  DATA 45,20
000EA:  DATA 43,48
000EC:  DATA 45,43
000EE:  DATA 4B,3A
000F0:  DATA 25,78
000F2:  DATA 0D,0A
000F4:  DATA 00,00
000F6:  DATA 4B,69
000F8:  DATA 6C,6C
000FA:  DATA 20,46
000FC:  DATA 4C,41
000FE:  DATA 47,20
00100:  DATA 4D,41
00102:  DATA 49,4E
00104:  DATA 3A,25
00106:  DATA 78,0D
00108:  DATA 0A,00
0010A:  DATA 4B,69
0010C:  DATA 6C,6C
0010E:  DATA 20,46
00110:  DATA 4C,41
00112:  DATA 47,20
00114:  DATA 46,41
00116:  DATA 42,3A
00118:  DATA 25,78
0011A:  DATA 0D,0A
0011C:  DATA 00,00
0011E:  DATA 41,55
00120:  DATA 54,4F
00122:  DATA 20,48
00124:  DATA 49,47
00126:  DATA 48,20
00128:  DATA 53,41
0012A:  DATA 4D,50
0012C:  DATA 4C,49
0012E:  DATA 4E,47
00130:  DATA 3A,25
00132:  DATA 78,0D
00134:  DATA 0A,00
00136:  DATA 41,55
00138:  DATA 54,4F
0013A:  DATA 20,43
0013C:  DATA 41,4D
0013E:  DATA 3A,25
00140:  DATA 78,0D
00142:  DATA 0A,00
00144:  DATA 41,55
00146:  DATA 54,4F
00148:  DATA 20,4D
0014A:  DATA 42,50
0014C:  DATA 3A,25
0014E:  DATA 78,0D
00150:  DATA 0A,00
00152:  DATA 41,55
00154:  DATA 54,4F
00156:  DATA 20,41
00158:  DATA 44,43
0015A:  DATA 53,3A
0015C:  DATA 25,78
0015E:  DATA 0D,0A
00160:  DATA 00,00
00162:  DATA 41,4E
00164:  DATA 54,45
00166:  DATA 4E,4E
00168:  DATA 41,20
0016A:  DATA 44,45
0016C:  DATA 50,4C
0016E:  DATA 4F,59
00170:  DATA 3A,25
00172:  DATA 78,0D
00174:  DATA 0A,00
00176:  DATA 41,4E
00178:  DATA 54,45
0017A:  DATA 4E,4E
0017C:  DATA 41,20
0017E:  DATA 44,45
00180:  DATA 50,4C
00182:  DATA 4F,59
00184:  DATA 20,41
00186:  DATA 54,54
00188:  DATA 45,4D
0018A:  DATA 50,54
0018C:  DATA 3A,25
0018E:  DATA 78,0D
00190:  DATA 0A,00
00192:  DATA 55,50
00194:  DATA 4C,49
00196:  DATA 4E,4B
00198:  DATA 20,53
0019A:  DATA 55,43
0019C:  DATA 43,45
0019E:  DATA 53,53
001A0:  DATA 3A,25
001A2:  DATA 78,0D
001A4:  DATA 0A,0D
001A6:  DATA 0A,00
001A8:  DATA 0D,0A
001AA:  DATA 41,44
001AC:  DATA 44,20
001AE:  DATA 49,4E
001B0:  DATA 46,4F
001B2:  DATA 20,41
001B4:  DATA 44,44
001B6:  DATA 52,45
001B8:  DATA 53,53
001BA:  DATA 3A,25
001BC:  DATA 6C,78
001BE:  DATA 0D,0A
001C0:  DATA 0D,0A
001C2:  DATA 00,00
001C4:  DATA 46,4C
001C6:  DATA 41,47
001C8:  DATA 20,44
001CA:  DATA 41,54
001CC:  DATA 41,20
001CE:  DATA 41,44
001D0:  DATA 44,52
001D2:  DATA 45,53
001D4:  DATA 53,3A
001D6:  DATA 25,78
001D8:  DATA 25,78
001DA:  DATA 25,78
001DC:  DATA 25,78
001DE:  DATA 0D,0A
001E0:  DATA 00,00
001E2:  DATA 52,45
001E4:  DATA 53,45
001E6:  DATA 52,56
001E8:  DATA 41,54
001EA:  DATA 49,4F
001EC:  DATA 4E,20
001EE:  DATA 54,41
001F0:  DATA 42,4C
001F2:  DATA 45,20
001F4:  DATA 41,44
001F6:  DATA 44,52
001F8:  DATA 45,53
001FA:  DATA 53,3A
001FC:  DATA 25,78
001FE:  DATA 25,78
00200:  DATA 25,78
00202:  DATA 25,78
00204:  DATA 0D,0A
00206:  DATA 00,00
00208:  DATA 53,41
0020A:  DATA 54,45
0020C:  DATA 4C,4C
0020E:  DATA 49,54
00210:  DATA 45,20
00212:  DATA 4C,4F
00214:  DATA 47,20
00216:  DATA 41,44
00218:  DATA 44,52
0021A:  DATA 45,53
0021C:  DATA 53,3A
0021E:  DATA 25,78
00220:  DATA 25,78
00222:  DATA 25,78
00224:  DATA 25,78
00226:  DATA 0D,0A
00228:  DATA 00,00
0022A:  DATA 43,41
0022C:  DATA 4D,20
0022E:  DATA 41,44
00230:  DATA 44,52
00232:  DATA 45,53
00234:  DATA 53,3A
00236:  DATA 25,78
00238:  DATA 25,78
0023A:  DATA 25,78
0023C:  DATA 25,78
0023E:  DATA 0D,0A
00240:  DATA 00,00
00242:  DATA 46,41
00244:  DATA 42,20
00246:  DATA 48,4B
00248:  DATA 20,41
0024A:  DATA 44,44
0024C:  DATA 52,45
0024E:  DATA 53,53
00250:  DATA 3A,25
00252:  DATA 78,25
00254:  DATA 78,25
00256:  DATA 78,25
00258:  DATA 78,0D
0025A:  DATA 0A,00
0025C:  DATA 46,41
0025E:  DATA 42,20
00260:  DATA 43,57
00262:  DATA 20,41
00264:  DATA 44,44
00266:  DATA 52,45
00268:  DATA 53,53
0026A:  DATA 3A,25
0026C:  DATA 78,25
0026E:  DATA 78,25
00270:  DATA 78,25
00272:  DATA 78,0D
00274:  DATA 0A,00
00276:  DATA 41,44
00278:  DATA 43,53
0027A:  DATA 20,53
0027C:  DATA 45,4E
0027E:  DATA 53,4F
00280:  DATA 52,20
00282:  DATA 41,44
00284:  DATA 44,52
00286:  DATA 45,53
00288:  DATA 53,3A
0028A:  DATA 25,78
0028C:  DATA 25,78
0028E:  DATA 25,78
00290:  DATA 25,78
00292:  DATA 0D,0A
00294:  DATA 00,00
00296:  DATA 41,44
00298:  DATA 43,53
0029A:  DATA 20,54
0029C:  DATA 4C,45
0029E:  DATA 20,41
002A0:  DATA 44,44
002A2:  DATA 52,45
002A4:  DATA 53,53
002A6:  DATA 3A,25
002A8:  DATA 78,25
002AA:  DATA 78,25
002AC:  DATA 78,25
002AE:  DATA 78,0D
002B0:  DATA 0A,00
002B2:  DATA 4D,49
002B4:  DATA 53,53
002B6:  DATA 49,4F
002B8:  DATA 4E,20
002BA:  DATA 42,4F
002BC:  DATA 53,53
002BE:  DATA 20,41
002C0:  DATA 44,44
002C2:  DATA 52,45
002C4:  DATA 53,53
002C6:  DATA 3A,25
002C8:  DATA 78,25
002CA:  DATA 78,25
002CC:  DATA 78,25
002CE:  DATA 78,0D
002D0:  DATA 0A,00
002D2:  DATA 48,49
002D4:  DATA 47,48
002D6:  DATA 20,53
002D8:  DATA 41,4D
002DA:  DATA 50,20
002DC:  DATA 48,4B
002DE:  DATA 20,41
002E0:  DATA 44,44
002E2:  DATA 52,45
002E4:  DATA 53,53
002E6:  DATA 3A,25
002E8:  DATA 78,25
002EA:  DATA 78,25
002EC:  DATA 78,25
002EE:  DATA 78,0D
002F0:  DATA 0A,00
002F2:  DATA 57,52
002F4:  DATA 49,54
002F6:  DATA 45,20
002F8:  DATA 25,6C
002FA:  DATA 78,20
002FC:  DATA 54,49
002FE:  DATA 4D,45
00300:  DATA 53,0D
00302:  DATA 0A,00
00304:  DATA 0D,0A
00306:  DATA 50,41
00308:  DATA 53,53
0030A:  DATA 45,44
0030C:  DATA 20,44
0030E:  DATA 41,59
00310:  DATA 53,3A
00312:  DATA 25,6C
00314:  DATA 78,0D
00316:  DATA 0A,00
00318:  DATA 52,45
0031A:  DATA 53,45
0031C:  DATA 52,56
0031E:  DATA 45,20
00320:  DATA 43,48
00322:  DATA 45,43
00324:  DATA 4B,3A
00326:  DATA 25,78
00328:  DATA 0D,0A
0032A:  DATA 00,00
0032C:  DATA 4B,69
0032E:  DATA 6C,6C
00330:  DATA 20,46
00332:  DATA 4C,41
00334:  DATA 47,20
00336:  DATA 4D,41
00338:  DATA 49,4E
0033A:  DATA 3A,25
0033C:  DATA 78,0D
0033E:  DATA 0A,00
00340:  DATA 4B,69
00342:  DATA 6C,6C
00344:  DATA 20,46
00346:  DATA 4C,41
00348:  DATA 47,20
0034A:  DATA 46,41
0034C:  DATA 42,3A
0034E:  DATA 25,78
00350:  DATA 0D,0A
00352:  DATA 00,00
00354:  DATA 41,55
00356:  DATA 54,4F
00358:  DATA 20,48
0035A:  DATA 49,47
0035C:  DATA 48,20
0035E:  DATA 53,41
00360:  DATA 4D,50
00362:  DATA 4C,49
00364:  DATA 4E,47
00366:  DATA 3A,25
00368:  DATA 78,0D
0036A:  DATA 0A,00
0036C:  DATA 41,55
0036E:  DATA 54,4F
00370:  DATA 20,43
00372:  DATA 41,4D
00374:  DATA 3A,25
00376:  DATA 78,0D
00378:  DATA 0A,00
0037A:  DATA 41,55
0037C:  DATA 54,4F
0037E:  DATA 20,4D
00380:  DATA 42,50
00382:  DATA 3A,25
00384:  DATA 78,0D
00386:  DATA 0A,00
00388:  DATA 41,55
0038A:  DATA 54,4F
0038C:  DATA 20,41
0038E:  DATA 44,43
00390:  DATA 53,3A
00392:  DATA 25,78
00394:  DATA 0D,0A
00396:  DATA 00,00
00398:  DATA 41,4E
0039A:  DATA 54,45
0039C:  DATA 4E,4E
0039E:  DATA 41,20
003A0:  DATA 44,45
003A2:  DATA 50,4C
003A4:  DATA 4F,59
003A6:  DATA 3A,25
003A8:  DATA 78,0D
003AA:  DATA 0A,00
003AC:  DATA 55,50
003AE:  DATA 4C,49
003B0:  DATA 4E,4B
003B2:  DATA 20,53
003B4:  DATA 55,43
003B6:  DATA 43,45
003B8:  DATA 53,53
003BA:  DATA 3A,25
003BC:  DATA 78,0D
003BE:  DATA 0A,0D
003C0:  DATA 0A,00
003C2:  DATA 46,4C
003C4:  DATA 41,47
003C6:  DATA 20,49
003C8:  DATA 4E,46
003CA:  DATA 4F,20
003CC:  DATA 53,54
003CE:  DATA 4F,52
003D0:  DATA 45,44
003D2:  DATA 20,49
003D4:  DATA 4E,20
003D6:  DATA 46,4C
003D8:  DATA 41,53
003DA:  DATA 48,0D
003DC:  DATA 0A,00
003DE:  DATA 0D,0A
003E0:  DATA 61,64
003E2:  DATA 64,72
003E4:  DATA 65,73
003E6:  DATA 73,20
003E8:  DATA 69,6E
003EA:  DATA 66,6F
003EC:  DATA 20,6C
003EE:  DATA 6F,63
003F0:  DATA 61,74
003F2:  DATA 69,6F
003F4:  DATA 6E,3A
003F6:  DATA 25,6C
003F8:  DATA 78,0D
003FA:  DATA 0A,00
003FC:  DATA 41,44
003FE:  DATA 20,43
00400:  DATA 4F,55
00402:  DATA 4E,54
00404:  DATA 45,52
00406:  DATA 3A,25
00408:  DATA 6C,78
0040A:  DATA 0D,0A
0040C:  DATA 00,00
0040E:  DATA 43,48
00410:  DATA 41,4E
00412:  DATA 47,45
00414:  DATA 44,20
00416:  DATA 4D,45
00418:  DATA 4D,4F
0041A:  DATA 52,59
0041C:  DATA 20,41
0041E:  DATA 44,44
00420:  DATA 52,45
00422:  DATA 53,53
00424:  DATA 3A,00
00426:  DATA 0D,0A
00428:  DATA 53,74
0042A:  DATA 6F,72
0042C:  DATA 65,69
0042E:  DATA 6E,67
00430:  DATA 20,41
00432:  DATA 64,64
00434:  DATA 72,65
00436:  DATA 73,73
00438:  DATA 20,44
0043A:  DATA 61,74
0043C:  DATA 61,20
0043E:  DATA 69,6E
00440:  DATA 20,46
00442:  DATA 6C,61
00444:  DATA 73,68
00446:  DATA 0D,0A
00448:  DATA 00,00
0044A:  DATA 41,44
0044C:  DATA 44,52
0044E:  DATA 45,53
00450:  DATA 53,20
00452:  DATA 44,41
00454:  DATA 54,41
00456:  DATA 20,53
00458:  DATA 54,4F
0045A:  DATA 52,45
0045C:  DATA 20,44
0045E:  DATA 4F,4E
00460:  DATA 45,3A
00462:  DATA 25,6C
00464:  DATA 78,0D
00466:  DATA 0A,00
00468:  DATA 46,4C
0046A:  DATA 41,53
0046C:  DATA 48,20
0046E:  DATA 4D,45
00470:  DATA 4D,4F
00472:  DATA 52,59
00474:  DATA 20,45
00476:  DATA 52,41
00478:  DATA 53,45
0047A:  DATA 20,53
0047C:  DATA 54,41
0047E:  DATA 52,54
00480:  DATA 0D,0A
00482:  DATA 00,00
00484:  DATA 46,4C
00486:  DATA 41,53
00488:  DATA 48,20
0048A:  DATA 4D,45
0048C:  DATA 4D,4F
0048E:  DATA 52,59
00490:  DATA 20,45
00492:  DATA 52,41
00494:  DATA 53,45
00496:  DATA 20,44
00498:  DATA 4F,4E
0049A:  DATA 45,0D
0049C:  DATA 0A,00
0049E:  DATA 52,65
004A0:  DATA 6D,61
004A2:  DATA 69,6E
004A4:  DATA 69,6E
004A6:  DATA 67,20
004A8:  DATA 74,69
004AA:  DATA 6D,65
004AC:  DATA 3A,20
004AE:  DATA 25,64
004B0:  DATA 20,20
004B2:  DATA 0D,00
004B4:  DATA 65,72
004B6:  DATA 61,73
004B8:  DATA 69,6E
004BA:  DATA 67,20
004BC:  DATA 6E,65
004BE:  DATA 78,74
004C0:  DATA 20,73
004C2:  DATA 65,63
004C4:  DATA 74,6F
004C6:  DATA 72,0D
004C8:  DATA 0A,00
004CA:  DATA 65,72
004CC:  DATA 61,73
004CE:  DATA 69,6E
004D0:  DATA 67,20
004D2:  DATA 6E,65
004D4:  DATA 78,74
004D6:  DATA 20,73
004D8:  DATA 65,63
004DA:  DATA 74,6F
004DC:  DATA 72,0D
004DE:  DATA 0A,00
004E0:  DATA 65,72
004E2:  DATA 61,73
004E4:  DATA 69,6E
004E6:  DATA 67,20
004E8:  DATA 6E,65
004EA:  DATA 78,74
004EC:  DATA 20,73
004EE:  DATA 65,63
004F0:  DATA 74,6F
004F2:  DATA 72,0D
004F4:  DATA 0A,00
004F6:  DATA 65,72
004F8:  DATA 61,73
004FA:  DATA 69,6E
004FC:  DATA 67,20
004FE:  DATA 6E,65
00500:  DATA 78,74
00502:  DATA 20,73
00504:  DATA 65,63
00506:  DATA 74,6F
00508:  DATA 72,0D
0050A:  DATA 0A,00
0050C:  DATA 65,72
0050E:  DATA 61,73
00510:  DATA 69,6E
00512:  DATA 67,20
00514:  DATA 6E,65
00516:  DATA 78,74
00518:  DATA 20,73
0051A:  DATA 65,63
0051C:  DATA 74,6F
0051E:  DATA 72,0D
00520:  DATA 0A,00
00522:  DATA 53,74
00524:  DATA 61,72
00526:  DATA 74,20
00528:  DATA 30,78
0052A:  DATA 31,32
0052C:  DATA 0D,0A
0052E:  DATA 00,00
00530:  DATA 46,69
00532:  DATA 6E,69
00534:  DATA 73,68
00536:  DATA 20,30
00538:  DATA 78,31
0053A:  DATA 32,0D
0053C:  DATA 0A,00
0053E:  DATA 53,74
00540:  DATA 61,72
00542:  DATA 74,20
00544:  DATA 30,78
00546:  DATA 31,34
00548:  DATA 0D,0A
0054A:  DATA 00,00
0054C:  DATA 46,69
0054E:  DATA 6E,69
00550:  DATA 73,68
00552:  DATA 20,30
00554:  DATA 78,31
00556:  DATA 34,0D
00558:  DATA 0A,00
0055A:  DATA 53,74
0055C:  DATA 61,72
0055E:  DATA 74,20
00560:  DATA 30,78
00562:  DATA 31,36
00564:  DATA 0D,0A
00566:  DATA 00,00
00568:  DATA 46,69
0056A:  DATA 6E,69
0056C:  DATA 73,68
0056E:  DATA 20,30
00570:  DATA 78,31
00572:  DATA 36,0D
00574:  DATA 0A,00
00576:  DATA 46,69
00578:  DATA 6E,69
0057A:  DATA 73,68
0057C:  DATA 20,30
0057E:  DATA 78,31
00580:  DATA 36,0D
00582:  DATA 0A,00
00584:  DATA 46,69
00586:  DATA 6E,69
00588:  DATA 73,68
0058A:  DATA 20,30
0058C:  DATA 78,31
0058E:  DATA 36,0D
00590:  DATA 0A,00
00592:  DATA 53,74
00594:  DATA 61,72
00596:  DATA 74,20
00598:  DATA 30,78
0059A:  DATA 39,30
0059C:  DATA 0D,0A
0059E:  DATA 00,00
005A0:  DATA 46,69
005A2:  DATA 6E,69
005A4:  DATA 73,68
005A6:  DATA 20,30
005A8:  DATA 78,39
005AA:  DATA 30,0D
005AC:  DATA 0A,00
005AE:  DATA 53,74
005B0:  DATA 61,72
005B2:  DATA 74,20
005B4:  DATA 30,78
005B6:  DATA 39,31
005B8:  DATA 0D,0A
005BA:  DATA 00,00
005BC:  DATA 46,69
005BE:  DATA 6E,69
005C0:  DATA 73,68
005C2:  DATA 20,30
005C4:  DATA 78,39
005C6:  DATA 31,0D
005C8:  DATA 0A,00
005CA:  DATA 53,74
005CC:  DATA 61,72
005CE:  DATA 74,20
005D0:  DATA 30,78
005D2:  DATA 39,32
005D4:  DATA 0D,0A
005D6:  DATA 00,00
005D8:  DATA 46,69
005DA:  DATA 6E,69
005DC:  DATA 73,68
005DE:  DATA 20,30
005E0:  DATA 78,39
005E2:  DATA 32,0D
005E4:  DATA 0A,00
005E6:  DATA 53,74
005E8:  DATA 61,72
005EA:  DATA 74,20
005EC:  DATA 30,78
005EE:  DATA 39,33
005F0:  DATA 0D,0A
005F2:  DATA 00,00
005F4:  DATA 46,69
005F6:  DATA 6E,69
005F8:  DATA 73,68
005FA:  DATA 20,30
005FC:  DATA 78,39
005FE:  DATA 33,0D
00600:  DATA 0A,00
00602:  DATA 53,74
00604:  DATA 61,72
00606:  DATA 74,20
00608:  DATA 30,78
0060A:  DATA 39,34
0060C:  DATA 0D,0A
0060E:  DATA 00,00
00610:  DATA 46,69
00612:  DATA 6E,69
00614:  DATA 73,68
00616:  DATA 20,30
00618:  DATA 78,39
0061A:  DATA 34,0D
0061C:  DATA 0A,00
0061E:  DATA 53,74
00620:  DATA 61,72
00622:  DATA 74,20
00624:  DATA 30,78
00626:  DATA 39,42
00628:  DATA 0D,0A
0062A:  DATA 00,00
0062C:  DATA 46,69
0062E:  DATA 6E,69
00630:  DATA 73,68
00632:  DATA 20,30
00634:  DATA 78,39
00636:  DATA 42,0D
00638:  DATA 0A,00
0063A:  DATA 53,74
0063C:  DATA 61,72
0063E:  DATA 74,20
00640:  DATA 30,78
00642:  DATA 39,46
00644:  DATA 0D,0A
00646:  DATA 00,00
00648:  DATA 46,69
0064A:  DATA 6E,69
0064C:  DATA 73,68
0064E:  DATA 20,30
00650:  DATA 78,39
00652:  DATA 46,0D
00654:  DATA 0A,00
00656:  DATA 0D,0A
00658:  DATA 52,45
0065A:  DATA 53,45
0065C:  DATA 54,20
0065E:  DATA 44,41
00660:  DATA 54,41
00662:  DATA 20,4E
00664:  DATA 4F,54
00666:  DATA 20,4F
00668:  DATA 42,54
0066A:  DATA 41,49
0066C:  DATA 4E,45
0066E:  DATA 44,0D
00670:  DATA 0A,00
00672:  DATA 52,65
00674:  DATA 61,64
00676:  DATA 79,20
00678:  DATA 66,6F
0067A:  DATA 72,20
0067C:  DATA 72,65
0067E:  DATA 73,65
00680:  DATA 74,00
00682:  DATA 4C,4F
00684:  DATA 47,20
00686:  DATA 73,61
00688:  DATA 76,69
0068A:  DATA 6E,67
0068C:  DATA 20,64
0068E:  DATA 6F,6E
00690:  DATA 65,0D
00692:  DATA 0A,00
*
006B0:  MOVLB  2
006B2:  MOVF   x31,W
006B4:  CLRF   01
006B6:  SUBWF  x30,W
006B8:  BC    06C0
006BA:  MOVFF  230,00
006BE:  BRA    06D8
006C0:  CLRF   00
006C2:  MOVLW  08
006C4:  MOVWF  x32
006C6:  RLCF   x30,F
006C8:  RLCF   00,F
006CA:  MOVF   x31,W
006CC:  SUBWF  00,W
006CE:  BTFSC  FD8.0
006D0:  MOVWF  00
006D2:  RLCF   01,F
006D4:  DECFSZ x32,F
006D6:  BRA    06C6
006D8:  MOVLB  0
006DA:  GOTO   0714 (RETURN)
*
0072A:  DATA 53,74
0072C:  DATA 61,72
0072E:  DATA 74,20
00730:  DATA 4F,70
00732:  DATA 65,72
00734:  DATA 61,74
00736:  DATA 69,6E
00738:  DATA 67,0D
0073A:  DATA 0A,00
0073C:  DATA 0D,0A
0073E:  DATA 48,65
00740:  DATA 6C,6C
00742:  DATA 6F,20
00744:  DATA 57,6F
00746:  DATA 72,6C
00748:  DATA 64,0D
0074A:  DATA 0A,00
0074C:  DATA 4F,70
0074E:  DATA 65,72
00750:  DATA 61,74
00752:  DATA 69,6E
00754:  DATA 67,0D
00756:  DATA 0A,00
00758:  TBLRD*+
0075A:  MOVF   FF5,F
0075C:  BZ    0780
0075E:  MOVFF  FF6,20E
00762:  MOVFF  FF7,20F
00766:  MOVFF  FF8,210
0076A:  MOVF   FF5,W
0076C:  BTFSS  F9E.4
0076E:  BRA    076C
00770:  MOVWF  FAD
00772:  MOVFF  20E,FF6
00776:  MOVFF  20F,FF7
0077A:  MOVFF  210,FF8
0077E:  BRA    0758
00780:  GOTO   17BC (RETURN)
00784:  TBLRD*+
00786:  MOVF   FF5,F
00788:  BZ    07B0
0078A:  MOVFF  FF6,21C
0078E:  MOVFF  FF7,21D
00792:  MOVFF  FF8,21E
00796:  MOVF   FF5,W
00798:  BTFSS  FA6.4
0079A:  BRA    0798
0079C:  MOVLB  F
0079E:  MOVWF  x29
007A0:  MOVFF  21C,FF6
007A4:  MOVFF  21D,FF7
007A8:  MOVFF  21E,FF8
007AC:  MOVLB  0
007AE:  BRA    0784
007B0:  RETURN 0
*
007F8:  MOVLB  2
007FA:  CLRF   x20
007FC:  CLRF   x21
007FE:  MOVLW  01
00800:  MOVWF  x22
00802:  CLRF   FDA
00804:  CLRF   FD9
00806:  MOVLW  02
00808:  MOVWF  x25
0080A:  MOVLW  18
0080C:  MOVWF  x24
0080E:  MOVLW  02
00810:  MOVWF  FEA
00812:  MOVLW  1C
00814:  MOVWF  FE9
00816:  MOVFF  225,FE2
0081A:  MOVFF  224,FE1
0081E:  MOVFF  222,223
00822:  BCF    FD8.0
00824:  MOVF   FE5,W
00826:  MULWF  FEE
00828:  MOVF   FF3,W
0082A:  ADDWFC x20,F
0082C:  MOVF   FF4,W
0082E:  ADDWFC x21,F
00830:  DECFSZ x23,F
00832:  BRA    0822
00834:  MOVFF  220,FDE
00838:  MOVFF  221,220
0083C:  CLRF   x21
0083E:  BTFSC  FD8.0
00840:  INCF   x21,F
00842:  INCF   x24,F
00844:  BTFSC  FD8.2
00846:  INCF   x25,F
00848:  INCF   x22,F
0084A:  MOVF   x22,W
0084C:  SUBLW  05
0084E:  BNZ   080E
00850:  MOVLB  0
00852:  GOTO   0FE2 (RETURN)
....................  
.................... #list 
....................  
.................... #FUSES NOWDT, NOBROWNOUT, NOPROTECT 
.................... #use delay(crystal=16Mhz, clock=16Mhz) 
*
007B2:  MOVLW  02
007B4:  MOVWF  FEA
007B6:  MOVLW  1D
007B8:  MOVWF  FE9
007BA:  MOVF   FEF,W
007BC:  BZ    07DA
007BE:  MOVLW  05
007C0:  MOVWF  01
007C2:  CLRF   00
007C4:  DECFSZ 00,F
007C6:  BRA    07C4
007C8:  DECFSZ 01,F
007CA:  BRA    07C2
007CC:  MOVLW  2E
007CE:  MOVWF  00
007D0:  DECFSZ 00,F
007D2:  BRA    07D0
007D4:  BRA    07D6
007D6:  DECFSZ FEF,F
007D8:  BRA    07BE
007DA:  RETURN 0
.................... #include<PIC18F67J94_registers.h> 
.................... #byte ADCBUF0H = 0xFC3 
.................... #byte ADCBUF0L = 0xFC2 
.................... #byte ADCON1H = 0xFC1 
.................... #bit    FORM0 = ADCON1H.0 
.................... #bit    FORM1 = ADCON1H.1 
.................... #bit    MODE12 = ADCON1H.2 
.................... #bit    DMAEN = ADCON1H.3 
.................... #bit    DMABM = ADCON1H.4 
.................... #bit    ADSIDL = ADCON1H.5 
.................... #bit    ADFRZ = ADCON1H.6 
.................... #bit    ADON = ADCON1H.7 
.................... #byte ADCON1L = 0xFC0 
.................... #bit    DONE = ADCON1L.0 
.................... #bit    SAMP = ADCON1L.1 
.................... #bit    ASAM = ADCON1L.2 
.................... #bit    SIMSAM = ADCON1L.3 
.................... #bit    SSRC0 = ADCON1L.4 
.................... #bit    SSRC1 = ADCON1L.5 
.................... #bit    SSRC2 = ADCON1L.6 
.................... #bit    SSRC3 = ADCON1L.7 
.................... #byte TRISG = 0xF98 
.................... #byte TRISF = 0xF97 
.................... #byte TRISE = 0xF96 
.................... #byte TRISD = 0xF95 
.................... #byte TRISC = 0xF94 
.................... #byte TRISB = 0xF93 
....................  
.................... #byte TRISA = 0xF92 
.................... #bit    TRISA0 = TRISA.0 
.................... #bit    TRISA1 = TRISA.1 
.................... #bit    TRISA2 = TRISA.2 
....................  
....................  
.................... #byte LATG = 0xF8F 
.................... #byte LATF = 0xF8E 
.................... #byte LATE = 0xF8D 
.................... #byte LATD = 0xF8C 
.................... #byte LATC = 0xF8B 
.................... #byte LATB = 0xF8A 
....................  
.................... #byte LATA = 0xF89 
.................... #bit    LATA0 = LATA.0 
.................... #bit    LATA1 = LATA.1 
.................... #bit    LATA2 = LATA.2 
.................... #bit    LATA3 = LATA.3 
....................  
.................... #byte PORTG = 0xF86 
.................... #bit    RG0 = PORTG.0 
.................... #bit    RG1 = PORTG.1 
.................... #bit    RG2 = PORTG.2 
.................... #bit    RG3 = PORTG.3 
.................... #bit    RG4 = PORTG.4 
.................... #bit    RG6 = PORTG.6 
.................... #bit    RG7 = PORTG.7 
.................... #byte PORTF = 0xF85 
.................... #bit    RF2 = PORTF.2 
.................... #bit    RF3 = PORTF.3 
.................... #bit    RF4 = PORTF.4 
.................... #bit    RF5 = PORTF.5 
.................... #bit    RF6 = PORTF.6 
.................... #bit    RF7 = PORTF.7 
.................... #byte PORTE = 0xF84 
.................... #byte PORTD = 0xF83 
.................... #byte PORTC = 0xF82 
.................... #bit    RC0 = PORTC.0 
.................... #bit    RC1 = PORTC.1 
.................... #bit    RC2 = PORTC.2 
.................... #bit    RC3 = PORTC.3 
.................... #bit    RC4 = PORTC.4 
.................... #bit    RC5 = PORTC.5 
.................... #bit    RC6 = PORTC.6 
.................... #bit    RC7 = PORTC.7 
.................... #byte PORTB = 0xF81 
.................... #byte PORTA = 0xF80 
.................... #bit    RA0 = PORTA.0 
.................... #bit    RA1 = PORTA.1 
.................... #bit    RA2 = PORTA.2 
.................... #bit    RA3 = PORTA.3 
.................... #bit    RA4 = PORTA.4 
.................... #bit    RA5 = PORTA.5 
.................... #bit    RA6 = PORTA.6 
.................... #bit    RA7 = PORTA.7 
.................... #byte TRISVP = 0xF73 
.................... #byte LATVP = 0xF72 
.................... #byte PORTVP = 0xF71 
.................... #byte WPUB = 0xF62 
.................... #byte ALRMVALH = 0xF59 
.................... #byte ALRMVALL = 0xF58 
.................... #byte ANCFG = 0xF01 
.................... #bit    VBGEN = ANCFG.0 
.................... #bit    VBG2EN = ANCFG.1 
.................... #bit    VBG6EN = ANCFG.2 
.................... #byte ODCON1 = 0xEEB 
.................... #bit    SSP1OD = ODCON1.0 
.................... #bit    SSP2OD = ODCON1.1 
.................... #bit    USART1OD = ODCON1.2 
.................... #bit    USART2OD = ODCON1.3 
.................... #bit    USART3OD = ODCON1.4 
.................... #bit    USART4OD = ODCON1.5 
.................... #bit    ECCP1OD = ODCON1.6 
.................... #bit    ECCP2OD = ODCON1.7 
.................... #byte ODCON2 = 0xEEA 
.................... #bit    ECCP3OD = ODCON2.0 
.................... #bit    CCP4OD = ODCON2.1 
.................... #bit    CCP5OD = ODCON2.2 
.................... #bit    CCP6OD = ODCON2.3 
.................... #bit    CCP7OD = ODCON2.4 
.................... #bit    CCP8OD = ODCON2.5 
.................... #bit    CCP9OD = ODCON2.6 
.................... #bit    CCP10OD = ODCON2.7 
.................... #byte ADCON2H = 0xE8D 
.................... #bit    CHPS0 = ADCON2H.0 
.................... #bit    CHPS1 = ADCON2H.1 
.................... #bit    CSCNA = ADCON2H.2 
.................... #bit    BUFREGEN = ADCON2H.3 
.................... #bit    OFFCAL = ADCON2H.4 
.................... #bit    NVCFG0 = ADCON2H.5 
.................... #bit    PVCFG0 = ADCON2H.6 
.................... #bit    PVCFG1 = ADCON2H.7 
.................... #byte ADCON2L = 0xE8C 
.................... #bit    ALTS = ADCON2L.0 
.................... #bit    BUFM = ADCON2L.1 
.................... #bit    SMPI0 = ADCON2L.2 
.................... #bit    SMPI1 = ADCON2L.3 
.................... #bit    SMPI2 = ADCON2L.4 
.................... #bit    SMPI3 = ADCON2L.5 
.................... #bit    SMPI4 = ADCON2L.6 
.................... #bit    BUFS = ADCON2L.7 
.................... #byte ADCON3H = 0xE8B 
.................... #bit    SAMC0 = ADCON3H.0 
.................... #bit    SAMC1 = ADCON3H.1 
.................... #bit    SAMC2 = ADCON3H.2 
.................... #bit    SAMC3 = ADCON3H.3 
.................... #bit    SAMC4 = ADCON3H.4 
.................... #bit    PUMPEN = ADCON3H.5 
.................... #bit    EXTSAM = ADCON3H.6 
.................... #bit    ADRC = ADCON3H.7 
.................... #byte ADCON3L = 0xE8A 
.................... #byte ADCON5H = 0xE89 
.................... #bit    ASINTMD0 = ADCON5H.0 
.................... #bit    ASINTMD1 = ADCON5H.1 
.................... #bit    VREGSREQ = ADCON5H.3 
.................... #bit    BGREQ = ADCON5H.4 
.................... #bit    CTMUREQ = ADCON5H.5 
.................... #bit    LPENA = ADCON5H.6 
.................... #bit    ASENA = ADCON5H.7 
.................... #byte ADCON5L = 0xE88 
.................... #bit    CM0 = ADCON5L.0 
.................... #bit    CM1 = ADCON5L.1 
.................... #bit    WM0 = ADCON5L.2 
.................... #bit    WM1 = ADCON5L.3 
.................... #byte ADCHS0H = 0xE87 
.................... #bit    CH0SB0 = ADCHS0H.0 
.................... #bit    CH0SB1 = ADCHS0H.1 
.................... #bit    CH0SB2 = ADCHS0H.2 
.................... #bit    CH0SB3 = ADCHS0H.3 
.................... #bit    CH0SB4 = ADCHS0H.4 
.................... #bit    CH0NB0 = ADCHS0H.5 
.................... #bit    CH0NB1 = ADCHS0H.6 
.................... #bit    CH0NB2 = ADCHS0H.7 
.................... #byte ADCHS0L = 0xE86 
.................... #bit    CH0SA0 = ADCHS0L.0 
.................... #bit    CH0SA1 = ADCHS0L.1 
.................... #bit    CH0SA2 = ADCHS0L.2 
.................... #bit    CH0SA3 = ADCHS0L.3 
.................... #bit    CH0SA4 = ADCHS0L.4 
.................... #bit    CH0NA0 = ADCHS0L.5 
.................... #bit    CH0NA1 = ADCHS0L.6 
.................... #bit    CH0NA2 = ADCHS0L.7 
.................... #byte ADCSS1H = 0xE85 
.................... #bit    CSS24 = ADCSS1H.0 
.................... #bit    CSS25 = ADCSS1H.1 
.................... #bit    CSS26 = ADCSS1H.2 
.................... #bit    CSS27 = ADCSS1H.3 
.................... #bit    CSS28 = ADCSS1H.4 
.................... #bit    CSS29 = ADCSS1H.5 
.................... #bit    CSS30 = ADCSS1H.6 
.................... #bit    CSS31 = ADCSS1H.7 
.................... #byte ADCSS1L = 0xE84 
.................... #bit    CSS16 = ADCSS1L.0 
.................... #bit    CSS17 = ADCSS1L.1 
.................... #bit    CSS18 = ADCSS1L.2 
.................... #bit    CSS19 = ADCSS1L.3 
.................... #bit    CSS20 = ADCSS1L.4 
.................... #bit    CSS21 = ADCSS1L.5 
.................... #bit    CSS22 = ADCSS1L.6 
.................... #bit    CSS23 = ADCSS1L.7 
.................... #byte ADCSS0H = 0xE83 
.................... #bit    CSS8 = ADCSS0H.0 
.................... #bit    CSS9 = ADCSS0H.1 
.................... #bit    CSS10 = ADCSS0H.2 
.................... #bit    CSS11 = ADCSS0H.3 
.................... #bit    CSS12 = ADCSS0H.4 
.................... #bit    CSS13 = ADCSS0H.5 
.................... #bit    CSS14 = ADCSS0H.6 
.................... #bit    CSS15 = ADCSS0H.7 
.................... #byte ADCSS0L = 0xE82 
.................... #byte ADCHIT1H = 0xE81 
.................... #bit    CHH24 = ADCHIT1H.0 
.................... #bit    CHH25 = ADCHIT1H.1 
.................... #bit    CHH26 = ADCHIT1H.2 
.................... #bit    CHH27 = ADCHIT1H.3 
.................... #bit    CHH28 = ADCHIT1H.4 
.................... #bit    CHH29 = ADCHIT1H.5 
.................... #bit    CHH30 = ADCHIT1H.6 
.................... #bit    CHH31 = ADCHIT1H.7 
.................... #byte ADCHIT1L = 0xE80 
.................... #bit    CHH16 = ADCHIT1L.0 
.................... #bit    CHH17 = ADCHIT1L.1 
.................... #bit    CHH18 = ADCHIT1L.2 
.................... #bit    CHH19 = ADCHIT1L.3 
.................... #bit    CHH20 = ADCHIT1L.4 
.................... #bit    CHH21 = ADCHIT1L.5 
.................... #bit    CHH22 = ADCHIT1L.6 
.................... #bit    CHH23 = ADCHIT1L.7 
.................... #byte ADCHIT0H = 0xE7F 
.................... #bit    CHH8 = ADCHIT0H.0 
.................... #bit    CHH9 = ADCHIT0H.1 
.................... #bit    CHH10 = ADCHIT0H.2 
.................... #bit    CHH11 = ADCHIT0H.3 
.................... #bit    CHH12 = ADCHIT0H.4 
.................... #bit    CHH13 = ADCHIT0H.5 
.................... #bit    CHH14 = ADCHIT0H.6 
.................... #bit    CHH15 = ADCHIT0H.7 
.................... #byte ADCHIT0L = 0xE7E 
.................... #byte ADCTMUEN1H = 0xE7D 
.................... #bit    CTUMEN24 = ADCTMUEN1H.0 
.................... #bit    CTUMEN25 = ADCTMUEN1H.1 
.................... #bit    CTUMEN26 = ADCTMUEN1H.2 
.................... #bit    CTUMEN27 = ADCTMUEN1H.3 
.................... #bit    CTUMEN28 = ADCTMUEN1H.4 
.................... #bit    CTUMEN29 = ADCTMUEN1H.5 
.................... #bit    CTMUEN30 = ADCTMUEN1H.6 
.................... #bit    CTMUEN31 = ADCTMUEN1H.7 
.................... #byte ADCTMUEN1L = 0xE7C 
.................... #bit    CTUMEN16 = ADCTMUEN1L.0 
.................... #bit    CTUMEN17 = ADCTMUEN1L.1 
.................... #bit    CTUMEN18 = ADCTMUEN1L.2 
.................... #bit    CTUMEN19 = ADCTMUEN1L.3 
.................... #bit    CTMUEN20 = ADCTMUEN1L.4 
.................... #bit    CTMUEN21 = ADCTMUEN1L.5 
.................... #bit    CTMUEN22 = ADCTMUEN1L.6 
.................... #bit    CTMUEN23 = ADCTMUEN1L.7 
.................... #byte ADCTMUEN0H = 0xE7B 
.................... #bit    CTMUEN8 = ADCTMUEN0H.0 
.................... #bit    CTMUEN9 = ADCTMUEN0H.1 
.................... #bit    CTMUEN10 = ADCTMUEN0H.2 
.................... #bit    CTMUEN11 = ADCTMUEN0H.3 
.................... #bit    CTMUEN12 = ADCTMUEN0H.4 
.................... #bit    CTMUEN13 = ADCTMUEN0H.5 
.................... #bit    CTMUEN14 = ADCTMUEN0H.6 
.................... #bit    CTMUEN15 = ADCTMUEN0H.7 
.................... #byte ADCTMUEN0L = 0xE7A 
.................... #byte ADCBUF25H = 0xE79 
.................... #byte ADCBUF25L = 0xE78 
.................... #byte ADCBUF24H = 0xE77 
.................... #byte ADCBUF24L = 0xE76 
.................... #byte ADCBUF23H = 0xE75 
.................... #byte ADCBUF23L = 0xE74 
.................... #byte ADCBUF22H = 0xE73 
.................... #byte ADCBUF22L = 0xE72 
.................... #byte ADCBUF21H = 0xE71 
.................... #byte ADCBUF21L = 0xE70 
.................... #byte ADCBUF20H = 0xE6F 
.................... #byte ADCBUF20L = 0xE6E 
.................... #byte ADCBUF19H = 0xE6D 
.................... #byte ADCBUF19L = 0xE6C 
.................... #byte ADCBUF18H = 0xE6B 
.................... #byte ADCBUF18L = 0xE6A 
.................... #byte ADCBUF17H = 0xE69 
.................... #byte ADCBUF17L = 0xE68 
.................... #byte ADCBUF16H = 0xE67 
.................... #byte ADCBUF16L = 0xE66 
.................... #byte ADCBUF15H = 0xE65 
.................... #byte ADCBUF15L = 0xE64 
.................... #byte ADCBUF14H = 0xE63 
.................... #byte ADCBUF14L = 0xE62 
.................... #byte ADCBUF13H = 0xE61 
.................... #byte ADCBUF13L = 0xE60 
.................... #byte ADCBUF12H = 0xE5F 
.................... #byte ADCBUF12L = 0xE5E 
.................... #byte ADCBUF11H = 0xE5D 
.................... #byte ADCBUF11L = 0xE5C 
.................... #byte ADCBUF10H = 0xE5B 
.................... #byte ADCBUF10L = 0xE5A 
.................... #byte ADCBUF9H = 0xE59 
.................... #byte ADCBUF9L = 0xE58 
.................... #byte ADCBUF8H = 0xE57 
.................... #byte ADCBUF8L = 0xE56 
.................... #byte ADCBUF7H = 0xE55 
.................... #byte ADCBUF7L = 0xE54 
.................... #byte ADCBUF6H = 0xE53 
.................... #byte ADCBUF6L = 0xE52 
.................... #byte ADCBUF5H = 0xE51 
.................... #byte ADCBUF5L = 0xE50 
.................... #byte ADCBUF4H = 0xE4F 
.................... #byte ADCBUF4L = 0xE4E 
.................... #byte ADCBUF3H = 0xE4D 
.................... #byte ADCBUF3L = 0xE4C 
.................... #byte ADCBUF2H = 0xE4B 
.................... #byte ADCBUF2L = 0xE4A 
.................... #byte ADCBUF1H = 0xE49 
.................... #byte ADCBUF1L = 0xE48 
.................... #byte ANCON1 = 0xE47 
.................... #byte ANCON2 = 0xE46 
.................... #bit    ANSEL8 = ANCON2.0 
.................... #bit    ANSEL9 = ANCON2.1 
.................... #bit    ANSEL10 = ANCON2.2 
.................... #bit    ANSEL11 = ANCON2.3 
.................... #bit    ANSEL12 = ANCON2.4 
.................... #bit    ANSEL13 = ANCON2.5 
.................... #bit    ANSEL14 = ANCON2.6 
.................... #bit    ANSEL15 = ANCON2.7 
.................... #byte ANCON3 = 0xE45 
.................... #bit    ANSEL16 = ANCON3.0 
.................... #bit    ANSEL17 = ANCON3.1 
.................... #bit    ANSEL18 = ANCON3.2 
.................... #bit    ANSEL19 = ANCON3.3 
.................... #bit    ANSEL20 = ANCON3.4 
.................... #bit    ANSEL21 = ANCON3.5 
.................... #bit    ANSEL22 = ANCON3.6 
.................... #bit    ANSEL23 = ANCON3.7 
....................  
....................  
.................... #device HIGH_INTS=TRUE 
....................  
.................... //-------------UART and SPI Setting-------------------------------------------------------------------------------------- 
....................  
.................... #pin_select TX1=PIN_C6                                                           //TX PIN EXT +/- 6v 
.................... #pin_select RX1=PIN_C7                                                           //RX PIN EXT +/- 6V 
.................... #use rs232(baud=115200,parity=N,UART1,bits=8,stream=pc)                      // MAIN to Ext +/- 6v 
....................  
.................... #pin_select TX2=PIN_D3 
.................... #pin_select RX2=PIN_D2 
.................... #use rs232(baud=9600,parity=N,UART2,bits=8,stream=com,ERRORS)                           //UART Main to COM PIC 
....................  
.................... #pin_select TX4=PIN_E3   
.................... #pin_select RX4=PIN_F2 
.................... #use rs232(baud=9600,parity=N,UART4,bits=8,stream=reset,ERRORS)                         //UART MAIN to RESET PIC 
*
00694:  BTFSS  FA6.7
00696:  BRA    0694
00698:  MOVLB  E
0069A:  MOVFF  EFF,1B
0069E:  MOVFF  EFA,01
006A2:  BTFSS  1B.1
006A4:  BRA    06AA
006A6:  BCF    xFF.4
006A8:  BSF    xFF.4
006AA:  MOVLB  0
006AC:  GOTO   06F6 (RETURN)
*
00C86:  BTFSS  FA6.6
00C88:  BRA    0C86
00C8A:  MOVLB  E
00C8C:  MOVWF  xF9
00C8E:  MOVLB  0
00C90:  GOTO   0CE8 (RETURN)
....................  
.................... #pin_select TX3=PIN_E5   
.................... #pin_select RX3=PIN_E4 
.................... #use rs232(baud=9600,parity=N,UART3,bits=8,stream=fab,ERRORS)                           //UART MAIN to FAB PIC 
*
007DC:  BTFSS  FA6.5
007DE:  BRA    07DC
007E0:  MOVLB  F
007E2:  MOVFF  F2F,1B
007E6:  MOVFF  F2A,01
007EA:  BTFSS  1B.1
007EC:  BRA    07F2
007EE:  BCF    x2F.4
007F0:  BSF    x2F.4
007F2:  MOVLB  0
007F4:  GOTO   0E78 (RETURN)
*
00910:  BTFSS  FA6.4
00912:  BRA    0910
00914:  MOVLB  F
00916:  MOVWF  x29
00918:  MOVLB  0
0091A:  RETURN 0
....................  
....................  
.................... #use rs232(baud=9600,parity=N,xmit=pin_G2,rcv=pin_G3,bits=8,stream=IMGCLS,ERRORS)       //UART MAIN to IMGCLS 
.................... #use rs232(baud=9600,parity=N,xmit=pin_G0,rcv=pin_G1,bits=8,stream=DC,ERRORS)           //UART MAIN to MB DCM 
*
00BD0:  BCF    F98.0
00BD2:  BCF    F8F.0
00BD4:  MOVLW  08
00BD6:  MOVWF  01
00BD8:  BRA    0BDA
00BDA:  NOP   
00BDC:  BSF    01.7
00BDE:  BRA    0C00
00BE0:  BCF    01.7
00BE2:  MOVLB  2
00BE4:  RRCF   x1D,F
00BE6:  MOVLB  0
00BE8:  BTFSC  FD8.0
00BEA:  BSF    F8F.0
00BEC:  BTFSS  FD8.0
00BEE:  BCF    F8F.0
00BF0:  BSF    01.6
00BF2:  BRA    0C00
00BF4:  BCF    01.6
00BF6:  DECFSZ 01,F
00BF8:  BRA    0BE2
00BFA:  BRA    0BFC
00BFC:  NOP   
00BFE:  BSF    F8F.0
00C00:  MOVLW  84
00C02:  MOVWF  FE9
00C04:  DECFSZ FE9,F
00C06:  BRA    0C04
00C08:  BRA    0C0A
00C0A:  NOP   
00C0C:  BTFSC  01.7
00C0E:  BRA    0BE0
00C10:  BTFSC  01.6
00C12:  BRA    0BF4
00C14:  RETURN 0
00C16:  BSF    F98.1
00C18:  BTFSC  F86.1
00C1A:  BRA    0C18
00C1C:  MOVLW  08
00C1E:  MOVWF  00
00C20:  MOVLB  2
00C22:  CLRF   x18
00C24:  BSF    00.7
00C26:  BRA    0C44
00C28:  BCF    00.7
00C2A:  BRA    0C44
00C2C:  BCF    FD8.0
00C2E:  BTFSC  F86.1
00C30:  BSF    FD8.0
00C32:  RRCF   x18,F
00C34:  BSF    00.6
00C36:  BRA    0C44
00C38:  BCF    00.6
00C3A:  DECFSZ 00,F
00C3C:  BRA    0C2C
00C3E:  MOVFF  218,01
00C42:  BRA    0C5C
00C44:  MOVLW  84
00C46:  BTFSC  00.7
00C48:  MOVLW  24
00C4A:  MOVWF  01
00C4C:  DECFSZ 01,F
00C4E:  BRA    0C4C
00C50:  BRA    0C52
00C52:  BTFSC  00.7
00C54:  BRA    0C28
00C56:  BTFSC  00.6
00C58:  BRA    0C38
00C5A:  BRA    0C2C
00C5C:  MOVLB  0
00C5E:  GOTO   1434 (RETURN)
....................  
....................  
.................... #use spi(MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6,  BAUD=1000000, BITS=8, STREAM=MAIN_FM, MODE=0)        //MAIN flash memory port 
.................... #use spi(MASTER, CLK=PIN_B2, DI=PIN_B5, DO=PIN_B4,  BAUD=1000000, BITS=8, STREAM=COM_FM, MODE=0)         //COM flash memory port 
.................... #use spi(MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1,  BAUD=1000000, BITS=8, STREAM=MISSION_FM, MODE=0)     //MISSION flash memory port 
*
00856:  MOVLB  2
00858:  MOVF   x2A,W
0085A:  SUBLW  08
0085C:  BZ    0866
0085E:  MOVWF  x2B
00860:  RLCF   x29,F
00862:  DECFSZ x2B,F
00864:  BRA    0860
00866:  BSF    F92.0
00868:  BCF    F92.1
0086A:  BCF    F92.3
0086C:  BCF    F89.3
0086E:  MOVFF  22A,22B
00872:  BTFSS  x29.7
00874:  BCF    F89.1
00876:  BTFSC  x29.7
00878:  BSF    F89.1
0087A:  RLCF   x29,F
0087C:  BSF    F89.3
0087E:  RLCF   01,F
00880:  BTFSS  F80.0
00882:  BCF    01.0
00884:  BTFSC  F80.0
00886:  BSF    01.0
00888:  BCF    F89.3
0088A:  DECFSZ x2B,F
0088C:  BRA    0872
0088E:  MOVLB  0
00890:  RETURN 0
....................  
.................... //--------------Pin Assignment--------------------------------------------------------------------------------------------- 
.................... #define sel PIN_D6 
.................... #define hvs PIN_D7 
.................... #define PINO_POWER PIN_D5 
....................  
....................  
.................... //-------------mainpic_function.c----------------------------------------------------------------------------------------- 
....................  
.................... void Check_UART(); 
.................... void waiting(int32 counterval); 
....................  
.................... /////////////CAM MISSION///////////// 
.................... void Turn_On_CAM(); 
.................... void Turn_Off_CAM(); 
....................  
.................... /////////////RESET SENSOR collection///////////// 
.................... void COLLECT_RESET_DATA(); 
....................  
.................... /////////////Testing Stuff///////////// 
.................... void Flash_Memory_Access(); 
.................... void PINO_test(); 
.................... void GET_RESET_DATA(); 
....................  
....................  
.................... #include <mainpic_function.h> 
.................... #include<flash_ memory_ MT25QL01GBBB_OF.c> //all flash memory 
.................... #define SPIPORT MAIN_FM 
.................... #define SPIPORT_2 COM_FM 
.................... #define SPIPORT_3 MISSION_FM 
....................  
.................... #define CS_PIN PIN_E2 
.................... #define CS_PIN_2 PIN_B3 
.................... #define CS_PIN_3 PIN_A2 
....................  
.................... #define READ_ID              0x9F 
.................... #define READ_STATUS_REG      0x05  
.................... #define READ_DATA_BYTES      0x13  //0x03 for byte 
.................... #define ENABLE_WRITE         0x06 
.................... #define WRITE_PAGE           0x12  //0x02 for 3byte 
.................... #define ERASE_SECTOR         0xDC  //0xD8 for 3byte 
.................... #define ERASE_4KB_SUBSECTOR  0x21 
.................... #define ERASE_32KB_SUBSECTOR 0x5C 
.................... #define DIE_ERASE            0xC4 
....................  
....................  
....................  
.................... void WRITE_ENABLE_OF(){ 
....................  output_low(CS_PIN); 
....................   
....................  ///////////////////////////////////////////////////////////// 
....................  //delay_ms(2); 
....................  spi_xfer(SPIPORT,ENABLE_WRITE);                //Send 0x06 
....................  ///////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN);   
....................  return; 
.................... } 
....................  
....................  
.................... void WRITE_ENABLE_SCF(){ 
....................  output_low(CS_PIN_2); 
....................   
....................  ///////////////////////////////////////////////////////////// 
....................  //delay_ms(2); 
....................  spi_xfer(SPIPORT_2,ENABLE_WRITE);                //Send 0x06 
....................  ///////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_2);   
....................  return; 
.................... } 
....................  
....................  
.................... void WRITE_ENABLE_SMF(){ 
....................  output_low(CS_PIN_3); 
*
0098E:  BCF    F92.2
00990:  BCF    F89.2
....................   
....................  ///////////////////////////////////////////////////////////// 
....................  //delay_ms(2); 
....................  spi_xfer(SPIPORT_3,ENABLE_WRITE);                //Send 0x06 
00992:  MOVLW  06
00994:  MOVLB  2
00996:  MOVWF  x29
00998:  MOVLW  08
0099A:  MOVWF  x2A
0099C:  MOVLB  0
0099E:  RCALL  0856
....................  ///////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_3);   
009A0:  BCF    F92.2
009A2:  BSF    F89.2
....................  return; 
009A4:  RETURN 0
.................... } 
....................  
....................  
.................... void sector_erase_OF(unsigned int32 sector_address)                              //borra un sector de la flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_OF(); 
....................    output_low(CS_PIN);                                                           //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT,ERASE_SECTOR);                                               //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT,adsress[0]);    
....................    spi_xfer(SPIPORT,adsress[1]);     
....................    spi_xfer(SPIPORT,adsress[2]);     
....................    spi_xfer(SPIPORT,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN);                                                          //take CS PIN higher back 
....................    //delay_ms(1000); 
....................    delay_ms(750); 
....................     
....................    return; 
.................... } 
....................  
....................  
.................... void sector_erase_SCF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_SCF(); 
....................    output_low(CS_PIN_2);                                                         //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_2,ERASE_SECTOR);                                             //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT_2,adsress[0]);    
....................    spi_xfer(SPIPORT_2,adsress[1]);     
....................    spi_xfer(SPIPORT_2,adsress[2]);     
....................    spi_xfer(SPIPORT_2,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN_2);                                                        //take CS PIN higher back 
....................    //delay_ms(1000); 
....................    delay_ms(750); 
....................     
....................    return; 
.................... } 
....................  
....................  
.................... void sector_erase_SMF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
*
00B3E:  MOVLB  2
00B40:  MOVFF  217,218
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
00B44:  MOVFF  216,219
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
00B48:  MOVFF  215,21A
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);       // 0x 00 00 00 _ _ 
00B4C:  MOVFF  214,21B
....................     
....................     
....................    WRITE_ENABLE_SMF(); 
00B50:  MOVLB  0
00B52:  RCALL  098E
....................    output_low(CS_PIN_3);             //lower the CS PIN 
00B54:  BCF    F92.2
00B56:  BCF    F89.2
....................    delay_us(2); 
00B58:  MOVLW  02
00B5A:  MOVWF  00
00B5C:  DECFSZ 00,F
00B5E:  BRA    0B5C
00B60:  NOP   
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,ERASE_SECTOR); //SECTOR ERASE COMAND   (0xDC) 
00B62:  MOVLW  DC
00B64:  MOVLB  2
00B66:  MOVWF  x29
00B68:  MOVLW  08
00B6A:  MOVWF  x2A
00B6C:  MOVLB  0
00B6E:  RCALL  0856
....................     
....................    spi_xfer(SPIPORT_3,adsress[0]);    
00B70:  MOVFF  218,229
00B74:  MOVLW  08
00B76:  MOVLB  2
00B78:  MOVWF  x2A
00B7A:  MOVLB  0
00B7C:  RCALL  0856
....................    spi_xfer(SPIPORT_3,adsress[1]);     
00B7E:  MOVFF  219,229
00B82:  MOVLW  08
00B84:  MOVLB  2
00B86:  MOVWF  x2A
00B88:  MOVLB  0
00B8A:  RCALL  0856
....................    spi_xfer(SPIPORT_3,adsress[2]);     
00B8C:  MOVFF  21A,229
00B90:  MOVLW  08
00B92:  MOVLB  2
00B94:  MOVWF  x2A
00B96:  MOVLB  0
00B98:  RCALL  0856
....................    spi_xfer(SPIPORT_3,adsress[3]); 
00B9A:  MOVFF  21B,229
00B9E:  MOVLW  08
00BA0:  MOVLB  2
00BA2:  MOVWF  x2A
00BA4:  MOVLB  0
00BA6:  RCALL  0856
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
00BA8:  MOVLW  02
00BAA:  MOVWF  00
00BAC:  DECFSZ 00,F
00BAE:  BRA    0BAC
00BB0:  NOP   
....................    output_high(CS_PIN_3);           //take CS PIN higher back 
00BB2:  BCF    F92.2
00BB4:  BSF    F89.2
....................    //delay_ms(1000);   
....................    delay_ms(750); 
00BB6:  MOVLW  03
00BB8:  MOVLB  2
00BBA:  MOVWF  x1C
00BBC:  MOVLW  FA
00BBE:  MOVWF  x1D
00BC0:  MOVLB  0
00BC2:  RCALL  07B2
00BC4:  MOVLB  2
00BC6:  DECFSZ x1C,F
00BC8:  BRA    0BBC
....................    return; 
00BCA:  MOVLB  0
00BCC:  GOTO   12D6 (RETURN)
.................... } 
....................  
....................  
.................... void SUBSECTOR_4KB_ERASE_OF(unsigned int32 sector_address)                       //Funcion que borra un sector de 4KB de la Main Flash 
.................... {                                                                                //Recibe la direccion del sector que se quiere borrar 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_OF();                                                            //Funcion que habilita escritura en Own Flash 
....................    output_low(CS_PIN);                                                           //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT,ERASE_4KB_SUBSECTOR);                                        //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT,adsress[0]);                                                 //Se le pasa la direccion del sector a borrar 
....................    spi_xfer(SPIPORT,adsress[1]);     
....................    spi_xfer(SPIPORT,adsress[2]);     
....................    spi_xfer(SPIPORT,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN);                                                          //take CS PIN higher back 
....................    delay_ms(100);   
....................     
....................    return; 
.................... } 
....................  
....................  
.................... void SUBSECTOR_4KB_ERASE_SCF(unsigned int32 sector_address)                      //Funcion que borra un sector de 4KB de la COM Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_SCF();                                                           //Funcion que habilita escritura en COM Flash 
....................    output_low(CS_PIN_2);                                                         //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_2,ERASE_4KB_SUBSECTOR); //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT_2,adsress[0]);    
....................    spi_xfer(SPIPORT_2,adsress[1]);     
....................    spi_xfer(SPIPORT_2,adsress[2]);     
....................    spi_xfer(SPIPORT_2,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN_2);                                                        //take CS PIN higher back 
....................    delay_ms(10);   
....................     
....................    return; 
.................... } 
....................  
....................  
.................... void SUBSECTOR_4KB_ERASE_SMF(unsigned int32 sector_address)                      //Funcion que borra un sector de 4KB de la Mission Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
*
00A1A:  MOVLB  2
00A1C:  MOVFF  217,218
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
00A20:  MOVFF  216,219
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
00A24:  MOVFF  215,21A
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
00A28:  MOVFF  214,21B
....................     
....................     
....................    WRITE_ENABLE_SMF();                                                           //Funcion que habilita escritura en Mission Flash 
00A2C:  MOVLB  0
00A2E:  RCALL  098E
....................    output_low(CS_PIN_3);                                                         //lower the CS PIN 
00A30:  BCF    F92.2
00A32:  BCF    F89.2
....................    delay_us(2); 
00A34:  MOVLW  02
00A36:  MOVWF  00
00A38:  DECFSZ 00,F
00A3A:  BRA    0A38
00A3C:  NOP   
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,ERASE_4KB_SUBSECTOR);                                      //SECTOR ERASE COMAND   (0xDC) 
00A3E:  MOVLW  21
00A40:  MOVLB  2
00A42:  MOVWF  x29
00A44:  MOVLW  08
00A46:  MOVWF  x2A
00A48:  MOVLB  0
00A4A:  RCALL  0856
....................     
....................    spi_xfer(SPIPORT_3,adsress[0]);    
00A4C:  MOVFF  218,229
00A50:  MOVLW  08
00A52:  MOVLB  2
00A54:  MOVWF  x2A
00A56:  MOVLB  0
00A58:  RCALL  0856
....................    spi_xfer(SPIPORT_3,adsress[1]);     
00A5A:  MOVFF  219,229
00A5E:  MOVLW  08
00A60:  MOVLB  2
00A62:  MOVWF  x2A
00A64:  MOVLB  0
00A66:  RCALL  0856
....................    spi_xfer(SPIPORT_3,adsress[2]);     
00A68:  MOVFF  21A,229
00A6C:  MOVLW  08
00A6E:  MOVLB  2
00A70:  MOVWF  x2A
00A72:  MOVLB  0
00A74:  RCALL  0856
....................    spi_xfer(SPIPORT_3,adsress[3]); 
00A76:  MOVFF  21B,229
00A7A:  MOVLW  08
00A7C:  MOVLB  2
00A7E:  MOVWF  x2A
00A80:  MOVLB  0
00A82:  RCALL  0856
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
00A84:  MOVLW  02
00A86:  MOVWF  00
00A88:  DECFSZ 00,F
00A8A:  BRA    0A88
00A8C:  NOP   
....................    output_high(CS_PIN_3);                                                        //take CS PIN higher back 
00A8E:  BCF    F92.2
00A90:  BSF    F89.2
....................    delay_ms(1000);   
00A92:  MOVLW  04
00A94:  MOVLB  2
00A96:  MOVWF  x1C
00A98:  MOVLW  FA
00A9A:  MOVWF  x1D
00A9C:  MOVLB  0
00A9E:  RCALL  07B2
00AA0:  MOVLB  2
00AA2:  DECFSZ x1C,F
00AA4:  BRA    0A98
....................     
....................    return; 
00AA6:  MOVLB  0
00AA8:  GOTO   128C (RETURN)
.................... } 
....................  
....................  
.................... void SUBSECTOR_32KB_ERASE_OF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_OF(); 
....................    output_low(CS_PIN);             //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT,ERASE_32KB_SUBSECTOR); //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT,adsress[0]);    
....................    spi_xfer(SPIPORT,adsress[1]);     
....................    spi_xfer(SPIPORT,adsress[2]);     
....................    spi_xfer(SPIPORT,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN);           //take CS PIN higher back 
....................    delay_ms(1000);   
....................     
....................    return; 
.................... } 
....................  
....................  
.................... void SUBSECTOR_32KB_ERASE_SCF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_SCF(); 
....................    output_low(CS_PIN_2);             //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_2,ERASE_32KB_SUBSECTOR); //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT_2,adsress[0]);    
....................    spi_xfer(SPIPORT_2,adsress[1]);     
....................    spi_xfer(SPIPORT_2,adsress[2]);     
....................    spi_xfer(SPIPORT_2,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN_2);           //take CS PIN higher back 
....................    delay_ms(1000);   
....................     
....................    return; 
.................... } 
....................  
....................  
.................... void SUBSECTOR_32KB_ERASE_SMF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
00AAC:  MOVLB  2
00AAE:  MOVFF  217,218
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
00AB2:  MOVFF  216,219
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
00AB6:  MOVFF  215,21A
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);       // 0x 00 00 00 _ _ 
00ABA:  MOVFF  214,21B
....................     
....................     
....................    WRITE_ENABLE_SMF(); 
00ABE:  MOVLB  0
00AC0:  RCALL  098E
....................    output_low(CS_PIN_3);             //lower the CS PIN 
00AC2:  BCF    F92.2
00AC4:  BCF    F89.2
....................    delay_us(2); 
00AC6:  MOVLW  02
00AC8:  MOVWF  00
00ACA:  DECFSZ 00,F
00ACC:  BRA    0ACA
00ACE:  NOP   
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,ERASE_32KB_SUBSECTOR); //SECTOR ERASE COMAND   (0xDC) 
00AD0:  MOVLW  5C
00AD2:  MOVLB  2
00AD4:  MOVWF  x29
00AD6:  MOVLW  08
00AD8:  MOVWF  x2A
00ADA:  MOVLB  0
00ADC:  RCALL  0856
....................     
....................    spi_xfer(SPIPORT_3,adsress[0]);    
00ADE:  MOVFF  218,229
00AE2:  MOVLW  08
00AE4:  MOVLB  2
00AE6:  MOVWF  x2A
00AE8:  MOVLB  0
00AEA:  RCALL  0856
....................    spi_xfer(SPIPORT_3,adsress[1]);     
00AEC:  MOVFF  219,229
00AF0:  MOVLW  08
00AF2:  MOVLB  2
00AF4:  MOVWF  x2A
00AF6:  MOVLB  0
00AF8:  RCALL  0856
....................    spi_xfer(SPIPORT_3,adsress[2]);     
00AFA:  MOVFF  21A,229
00AFE:  MOVLW  08
00B00:  MOVLB  2
00B02:  MOVWF  x2A
00B04:  MOVLB  0
00B06:  RCALL  0856
....................    spi_xfer(SPIPORT_3,adsress[3]); 
00B08:  MOVFF  21B,229
00B0C:  MOVLW  08
00B0E:  MOVLB  2
00B10:  MOVWF  x2A
00B12:  MOVLB  0
00B14:  RCALL  0856
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
00B16:  MOVLW  02
00B18:  MOVWF  00
00B1A:  DECFSZ 00,F
00B1C:  BRA    0B1A
00B1E:  NOP   
....................    output_high(CS_PIN_3);           //take CS PIN higher back 
00B20:  BCF    F92.2
00B22:  BSF    F89.2
....................    delay_ms(1000);   
00B24:  MOVLW  04
00B26:  MOVLB  2
00B28:  MOVWF  x1C
00B2A:  MOVLW  FA
00B2C:  MOVWF  x1D
00B2E:  MOVLB  0
00B30:  RCALL  07B2
00B32:  MOVLB  2
00B34:  DECFSZ x1C,F
00B36:  BRA    0B2A
....................     
....................    return; 
00B38:  MOVLB  0
00B3A:  GOTO   12B2 (RETURN)
.................... } 
....................  
....................  
.................... void ALL_SECTOR_ERASE_OF() 
.................... { 
....................    int32 ADDRESS = 0; 
....................    for(int16 i = 0; i < 2048; i++) 
....................    { 
....................       sector_erase_OF(ADDRESS); 
....................       ADDRESS = ADDRESS + 65536; 
....................    } 
.................... } 
....................  
....................  
.................... void ALL_SECTOR_ERASE_SCF() 
.................... { 
....................    int32 ADRESS = 0; 
....................    for(int16 i = 0; i < 2048; i++) 
....................    { 
....................       sector_erase_SCF(ADRESS); 
....................       ADRESS = ADRESS + 65536; 
....................    } 
.................... } 
....................  
....................  
.................... void ALL_SECTOR_ERASE_SMF() 
.................... { 
....................    int32 ADRESS = 0; 
....................    for(int16 i = 0; i < 2048; i++) 
....................    { 
....................       sector_erase_SMF(ADRESS); 
....................       ADRESS = ADRESS + 65536; 
....................    } 
.................... } 
....................  
....................  
.................... void WRITE_DATA_BYTE_OF(unsigned int32 page_address, int8 data)                  //Funcion que escribe un Byte en la Main Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((page_address>>24) & 0xFF);                     // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((page_address>>16) & 0xFF);                     // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((page_address>>8) & 0xFF);                      // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((page_address) & 0xFF);                         // 0x 00 00 00 _ _ 
....................     
....................    WRITE_ENABLE_OF(); 
....................    output_low(CS_PIN);                                                           //lower the CS PIN 
....................    //delay_us(2); 
....................     
....................    //////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT,WRITE_PAGE);                                                 //PAGE WRITE COMAND  (0x12) 
....................    
....................    spi_xfer(SPIPORT,adsress[0]);     
....................    spi_xfer(SPIPORT,adsress[1]);     
....................    spi_xfer(SPIPORT,adsress[2]);     
....................    spi_xfer(SPIPORT,adsress[3]); 
....................     
....................    spi_xfer(SPIPORT,data);  
....................    //////////////////////////////////////////////////////////////// 
....................     
....................    output_high(CS_PIN);                                                          //take CS PIN higher back 
....................  
....................    //delay_us(5);   
....................     
....................    return; 
.................... } 
....................  
....................  
.................... void WRITE_DATA_BYTE_SCF(unsigned int32 page_address, int8 data)                 //Funcion que escribe un Byte en la COM Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((page_address>>24) & 0xFF);                     // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((page_address>>16) & 0xFF);                     // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((page_address>>8) & 0xFF);                      // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((page_address) & 0xFF);                         // 0x 00 00 00 _ _ 
....................     
....................    WRITE_ENABLE_SCF(); 
....................    output_low(CS_PIN_2);                                                         //lower the CS PIN 
....................    //delay_us(2); 
....................     
....................    //////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_2,WRITE_PAGE);                                               //PAGE WRITE COMAND  (0x12) 
....................    
....................    spi_xfer(SPIPORT_2,adsress[0]);     
....................    spi_xfer(SPIPORT_2,adsress[1]);     
....................    spi_xfer(SPIPORT_2,adsress[2]);     
....................    spi_xfer(SPIPORT_2,adsress[3]); 
....................     
....................    spi_xfer(SPIPORT_2,data);  
....................    //////////////////////////////////////////////////////////////// 
....................     
....................    output_high(CS_PIN_2);                                                        //take CS PIN higher back 
....................  
....................    //delay_us(5);   
....................     
....................    return; 
.................... } 
....................  
....................  
.................... void WRITE_DATA_BYTE_SMF(unsigned int32 page_address, int8 data)                 //Funcion que escribe un Byte en la Mission Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((page_address>>24) & 0xFF);                     // 0x _ _ 00 00 00 
*
009A6:  MOVLB  2
009A8:  MOVFF  21B,21D
....................    adsress[1]  = (unsigned int8)((page_address>>16) & 0xFF);                     // 0x 00 _ _ 00 00 
009AC:  MOVFF  21A,21E
....................    adsress[2]  = (unsigned int8)((page_address>>8) & 0xFF);                      // 0x 00 00 _ _ 00 
009B0:  MOVFF  219,21F
....................    adsress[3]  = (unsigned int8)((page_address) & 0xFF);                         // 0x 00 00 00 _ _ 
009B4:  MOVFF  218,220
....................     
....................    WRITE_ENABLE_SMF(); 
009B8:  MOVLB  0
009BA:  RCALL  098E
....................    output_low(CS_PIN_3);                                                         //lower the CS PIN 
009BC:  BCF    F92.2
009BE:  BCF    F89.2
....................    //delay_us(2); 
....................     
....................    //////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,WRITE_PAGE);                                               //PAGE WRITE COMAND  (0x12) 
009C0:  MOVLW  12
009C2:  MOVLB  2
009C4:  MOVWF  x29
009C6:  MOVLW  08
009C8:  MOVWF  x2A
009CA:  MOVLB  0
009CC:  RCALL  0856
....................    
....................    spi_xfer(SPIPORT_3,adsress[0]);     
009CE:  MOVFF  21D,229
009D2:  MOVLW  08
009D4:  MOVLB  2
009D6:  MOVWF  x2A
009D8:  MOVLB  0
009DA:  RCALL  0856
....................    spi_xfer(SPIPORT_3,adsress[1]);     
009DC:  MOVFF  21E,229
009E0:  MOVLW  08
009E2:  MOVLB  2
009E4:  MOVWF  x2A
009E6:  MOVLB  0
009E8:  RCALL  0856
....................    spi_xfer(SPIPORT_3,adsress[2]);     
009EA:  MOVFF  21F,229
009EE:  MOVLW  08
009F0:  MOVLB  2
009F2:  MOVWF  x2A
009F4:  MOVLB  0
009F6:  RCALL  0856
....................    spi_xfer(SPIPORT_3,adsress[3]); 
009F8:  MOVFF  220,229
009FC:  MOVLW  08
009FE:  MOVLB  2
00A00:  MOVWF  x2A
00A02:  MOVLB  0
00A04:  RCALL  0856
....................     
....................    spi_xfer(SPIPORT_3,data);  
00A06:  MOVFF  21C,229
00A0A:  MOVLW  08
00A0C:  MOVLB  2
00A0E:  MOVWF  x2A
00A10:  MOVLB  0
00A12:  RCALL  0856
....................    //////////////////////////////////////////////////////////////// 
....................     
....................    output_high(CS_PIN_3);                                                        //take CS PIN higher back 
00A14:  BCF    F92.2
00A16:  BSF    F89.2
....................  
....................    //delay_us(10);   
....................     
....................    return; 
00A18:  RETURN 0
.................... } 
....................  
....................  
.................... int8 READ_CHIP_ID_OF() 
.................... { 
....................  output_low(CS_PIN);           //lower the CS PIN 
....................   
....................  //////////////////////////////////////////////////////////////// 
....................  int8 chip_id; 
....................  spi_xfer(SPIPORT,READ_ID);    //READ ID COMAND   (0x9F) 
....................  chip_id = spi_xfer(SPIPORT); 
....................  //////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN);         //take CS PIN higher back 
....................  return chip_id; 
.................... } 
....................  
....................  
.................... int8 READ_CHIP_ID_SCF() 
.................... { 
....................  output_low(CS_PIN_2);           //lower the CS PIN 
....................   
....................  //////////////////////////////////////////////////////////////// 
....................  int8 chip_id; 
....................  spi_xfer(SPIPORT_2,READ_ID);    //READ ID COMAND   (0x9F) 
....................  chip_id = spi_xfer(SPIPORT_2); 
....................  //////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_2);         //take CS PIN higher back 
....................  return chip_id; 
.................... } 
....................  
....................  
.................... int8 READ_CHIP_ID_SMF() 
.................... { 
....................  output_low(CS_PIN_3);           //lower the CS PIN 
....................   
....................  //////////////////////////////////////////////////////////////// 
....................  int8 chip_id; 
....................  spi_xfer(SPIPORT_3,READ_ID);    //READ ID COMAND   (0x9F) 
....................  chip_id = spi_xfer(SPIPORT_3); 
....................  //////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_3);         //take CS PIN higher back 
....................  return chip_id; 
.................... } 
....................  
....................  
.................... int8 READ_STATUS_REGISTER_OF() 
.................... { 
....................  output_low(CS_PIN);           //lower the CS PIN 
....................   
....................  ///////////////////////////////////////////////////////////////// 
....................  int8 status_reg; 
....................  spi_xfer(SPIPORT,READ_STATUS_REG); //READ STATUS REGISTER COMAND  (0x05) 
....................  status_reg = spi_xfer(SPIPORT); 
....................  ///////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN);         //take CS PIN higher back 
....................  return status_reg; 
.................... } 
....................  
....................  
.................... int8 READ_STATUS_REGISTER_SCF() 
.................... { 
....................  output_low(CS_PIN_2);           //lower the CS PIN 
....................   
....................  ///////////////////////////////////////////////////////////////// 
....................  int8 status_reg; 
....................  spi_xfer(SPIPORT_2,READ_STATUS_REG); //READ STATUS REGISTER COMAND  (0x05) 
....................  status_reg = spi_xfer(SPIPORT_2); 
....................  ///////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_2);         //take CS PIN higher back 
....................  return status_reg; 
.................... } 
.................... int8 READ_STATUS_REGISTER_SMF() 
.................... { 
....................  output_low(CS_PIN_3);           //lower the CS PIN 
....................   
....................  ///////////////////////////////////////////////////////////////// 
....................  int8 status_reg; 
....................  spi_xfer(SPIPORT_3,READ_STATUS_REG); //READ STATUS REGISTER COMAND  (0x05) 
....................  status_reg = spi_xfer(SPIPORT_3); 
....................  ///////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_3);         //take CS PIN higher back 
....................  return status_reg; 
.................... } 
....................  
....................  
.................... int8 READ_DATA_BYTE_OF(unsigned INT32 ADDRESS) 
.................... { 
....................  
....................  unsigned int8 address_OF[4]; 
....................    //Byte extraction 
....................    address_OF[0]  = (unsigned int8)((ADDRESS>>24) & 0xFF);                          // 0x _ _ 00 00 00 
....................    address_OF[1]  = (unsigned int8)((ADDRESS>>16) & 0xFF);                          // 0x 00 _ _ 00 00 
....................    address_OF[2]  = (unsigned int8)((ADDRESS>>8) & 0xFF);                           // 0x 00 00 _ _ 00 
....................    address_OF[3]  = (unsigned int8)((ADDRESS) & 0xFF);                              // 0x 00 00 00 _ _ 
....................     
....................  output_low(CS_PIN);                                                             //lower the CS PIN 
....................   
....................  ////////////////////////////////////////////////////////////////// 
....................  int8 data; 
....................  spi_xfer(SPIPORT,READ_DATA_BYTES);                                              //READ DATA COMAND   (0x13) 
....................   
....................  spi_xfer(SPIPORT,address_OF[0]); 
....................  spi_xfer(SPIPORT,address_OF[1]); 
....................  spi_xfer(SPIPORT,address_OF[2]); 
....................  spi_xfer(SPIPORT,address_OF[3]); 
....................  data = spi_xfer(SPIPORT); 
....................  ////////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN);                                                            //take CS PIN higher back 
....................  return data; 
....................   
.................... } 
....................  
....................  
.................... int8 READ_DATA_BYTE_SCF(unsigned INT32 ADDRESS) 
.................... { 
....................  
....................  unsigned int8 adsress[4]; 
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((ADDRESS>>24) & 0xFF);                          // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((ADDRESS>>16) & 0xFF);                          // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((ADDRESS>>8) & 0xFF);                           // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((ADDRESS) & 0xFF);                              // 0x 00 00 00 _ _ 
....................     
....................  output_low(CS_PIN_2);                                                           //lower the CS PIN 
....................   
....................  ////////////////////////////////////////////////////////////////// 
....................  int8 data; 
....................  spi_xfer(SPIPORT_2,READ_DATA_BYTES);                                            //READ DATA COMAND   (0x13) 
....................   
....................  spi_xfer(SPIPORT_2,adsress[0]); 
....................  spi_xfer(SPIPORT_2,adsress[1]); 
....................  spi_xfer(SPIPORT_2,adsress[2]); 
....................  spi_xfer(SPIPORT_2,adsress[3]); 
....................  data = spi_xfer(SPIPORT_2); 
....................  ////////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_2);                                                          //take CS PIN higher back 
....................  return data; 
....................   
.................... } 
....................  
....................  
.................... int8 READ_DATA_BYTE_SMF(unsigned INT32 ADDRESS) 
.................... { 
....................  
....................  unsigned int8 adsress[4]; 
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((ADDRESS>>24) & 0xFF);                          // 0x _ _ 00 00 00 
*
00892:  MOVLB  2
00894:  MOVFF  223,224
....................    adsress[1]  = (unsigned int8)((ADDRESS>>16) & 0xFF);                          // 0x 00 _ _ 00 00 
00898:  MOVFF  222,225
....................    adsress[2]  = (unsigned int8)((ADDRESS>>8) & 0xFF);                           // 0x 00 00 _ _ 00 
0089C:  MOVFF  221,226
....................    adsress[3]  = (unsigned int8)((ADDRESS) & 0xFF);                              // 0x 00 00 00 _ _ 
008A0:  MOVFF  220,227
....................     
....................  output_low(CS_PIN_3);                                                           //lower the CS PIN 
008A4:  BCF    F92.2
008A6:  BCF    F89.2
....................   
....................  ////////////////////////////////////////////////////////////////// 
....................  int8 data; 
....................  spi_xfer(SPIPORT_3,READ_DATA_BYTES);                                            //READ DATA COMAND   (0x13) 
008A8:  MOVLW  13
008AA:  MOVWF  x29
008AC:  MOVLW  08
008AE:  MOVWF  x2A
008B0:  MOVLB  0
008B2:  RCALL  0856
....................   
....................  spi_xfer(SPIPORT_3,adsress[0]); 
008B4:  MOVFF  224,229
008B8:  MOVLW  08
008BA:  MOVLB  2
008BC:  MOVWF  x2A
008BE:  MOVLB  0
008C0:  RCALL  0856
....................  spi_xfer(SPIPORT_3,adsress[1]); 
008C2:  MOVFF  225,229
008C6:  MOVLW  08
008C8:  MOVLB  2
008CA:  MOVWF  x2A
008CC:  MOVLB  0
008CE:  RCALL  0856
....................  spi_xfer(SPIPORT_3,adsress[2]); 
008D0:  MOVFF  226,229
008D4:  MOVLW  08
008D6:  MOVLB  2
008D8:  MOVWF  x2A
008DA:  MOVLB  0
008DC:  RCALL  0856
....................  spi_xfer(SPIPORT_3,adsress[3]); 
008DE:  MOVFF  227,229
008E2:  MOVLW  08
008E4:  MOVLB  2
008E6:  MOVWF  x2A
008E8:  MOVLB  0
008EA:  RCALL  0856
....................  data = spi_xfer(SPIPORT_3); 
008EC:  MOVLW  03
008EE:  MOVLB  2
008F0:  MOVWF  x29
008F2:  MOVLW  08
008F4:  MOVWF  x2A
008F6:  MOVLB  0
008F8:  RCALL  0856
008FA:  MOVF   01,W
008FC:  MOVFF  01,228
....................  ////////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_3);                                                          //take CS PIN higher back 
00900:  BCF    F92.2
00902:  BSF    F89.2
....................  return data; 
00904:  MOVLB  2
00906:  MOVFF  228,01
0090A:  MOVLB  0
0090C:  GOTO   0958 (RETURN)
....................   
.................... } 
....................  
....................  
.................... /* 
.................... void TRANSFER_DATA_256byte_OF(unsigned INT32 ADRESS, int PORT_NUM) //read and send the specified data 
.................... { 
....................    unsigned long int i; 
....................     
....................    switch(PORT_NUM) 
....................    { 
....................       case 1: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_OF(ADRESS),PC); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................       case 2: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_OF(ADRESS),reset); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................       case 3: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_OF(ADRESS),com); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................    } 
....................    return;  
.................... } 
.................... void TRANSFER_DATA_256byte_SCF(unsigned INT32 ADRESS, int PORT_NUM) //read and send the specified data 
.................... { 
....................    unsigned long int i; 
....................     
....................    switch(PORT_NUM) 
....................    { 
....................       case 1: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_SCF(ADRESS),PC); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................       case 2: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_SCF(ADRESS),reset); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................       case 3: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_SCF(ADRESS),com); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................    } 
....................     return;   
.................... } 
.................... void TRANSFER_DATA_256byte_SMF(unsigned INT32 ADRESS, int PORT_NUM) //read and send the specified data 
.................... { 
....................    unsigned long int i; 
....................     
....................    switch(PORT_NUM) 
....................    { 
....................       case 1: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_SMF(ADRESS),PC); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................       case 2: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_SMF(ADRESS),reset); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................       case 3: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_SMF(ADRESS),com); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................    } 
....................     return;   
.................... } 
....................  
.................... void WRITE_DATA_NBYTE_OF(unsigned INT32 ADDRES,int32 data_byte) //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(ADDRES,0x77); 
....................       ADDRES++; 
....................    } 
....................    return; 
.................... } 
.................... void WRITE_DATA_NBYTE_SCF(unsigned INT32 ADDRES,int32 data_byte) //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(ADDRES,0x69); 
....................       ADDRES++; 
....................    } 
....................    return; 
.................... } 
.................... void WRITE_DATA_NBYTE_SMF(unsigned INT32 ADDRES,int32 data_byte) //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(ADDRES,0x55); 
....................       ADDRES++; 
....................    } 
....................    return; 
.................... } 
.................... */ 
....................  
....................  
.................... void TRANSFER_DATA_NBYTE_TOPC_OF(unsigned INT32 ADDRESS,int32 data_byte)          //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       fputc(READ_DATA_BYTE_OF(ADDRESS),PC); 
....................       ADDRESS++; 
....................    } 
....................    return; 
.................... } 
....................  
....................  
.................... void TRANSFER_DATA_NBYTE_TOPC_SCF(unsigned INT32 ADRESS,int32 data_byte)         //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       fprintf(PC,"%x",READ_DATA_BYTE_SCF(ADRESS)); 
....................       ADRESS++; 
....................    } 
....................    return; 
.................... } 
....................  
....................  
.................... void TRANSFER_DATA_NBYTE_TOPC_SMF(unsigned INT32 ADRESS,int32 data_byte)         //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       fputc(READ_DATA_BYTE_SMF(ADRESS),PC); 
....................       ADRESS++; 
....................    } 
....................    return; 
.................... } 
....................  
.................... void TRANSFER_DATA_NBYTE_TOFAB_SMF(unsigned INT32 ADRESS,int32 data_byte)         //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
*
0091C:  MOVLB  2
0091E:  CLRF   x1F
00920:  CLRF   x1E
00922:  CLRF   x1D
00924:  CLRF   x1C
00926:  MOVF   x1F,W
00928:  SUBWF  x1B,W
0092A:  BNC   0988
0092C:  BNZ   0944
0092E:  MOVF   x1E,W
00930:  SUBWF  x1A,W
00932:  BNC   0988
00934:  BNZ   0944
00936:  MOVF   x1D,W
00938:  SUBWF  x19,W
0093A:  BNC   0988
0093C:  BNZ   0944
0093E:  MOVF   x18,W
00940:  SUBWF  x1C,W
00942:  BC    0988
....................    { 
....................       fputc(READ_DATA_BYTE_SMF(ADRESS),fab); 
00944:  MOVFF  217,223
00948:  MOVFF  216,222
0094C:  MOVFF  215,221
00950:  MOVFF  214,220
00954:  MOVLB  0
00956:  BRA    0892
00958:  MOVFF  01,220
0095C:  MOVLB  2
0095E:  MOVF   x20,W
00960:  MOVLB  0
00962:  RCALL  0910
....................       ADRESS++; 
00964:  MOVLW  01
00966:  MOVLB  2
00968:  ADDWF  x14,F
0096A:  BTFSC  FD8.0
0096C:  INCF   x15,F
0096E:  BTFSC  FD8.2
00970:  INCF   x16,F
00972:  BTFSC  FD8.2
00974:  INCF   x17,F
00976:  MOVLW  01
00978:  ADDWF  x1C,F
0097A:  BTFSC  FD8.0
0097C:  INCF   x1D,F
0097E:  BTFSC  FD8.2
00980:  INCF   x1E,F
00982:  BTFSC  FD8.2
00984:  INCF   x1F,F
00986:  BRA    0926
....................    } 
....................    return; 
00988:  MOVLB  0
0098A:  GOTO   1014 (RETURN)
.................... } 
....................  
....................  
.................... /* 
.................... void TRANSFER_DATA_NBYTE_OFtoSCF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from MAIN FLASH to COM FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(TO_ADRESS,READ_DATA_BYTE_OF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... } 
.................... void TRANSFER_DATA_NBYTE_SCFtoOF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from COM FLASH to MAIN FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(TO_ADRESS,READ_DATA_BYTE_SCF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... } 
.................... void TRANSFER_DATA_NBYTE_OFtoSMF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from MAIN FLASH to MISSION FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(TO_ADRESS,READ_DATA_BYTE_OF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... }*/ 
....................  
....................  
.................... void TRANSFER_DATA_NBYTE_SMFtoOF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from MISSION FLASH to MAIN FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(TO_ADRESS,READ_DATA_BYTE_SMF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... } 
....................  
....................  
.................... void TRANSFER_DATA_NBYTE_SMFtoSCF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from MISSION FLASH to COM FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(TO_ADRESS,READ_DATA_BYTE_SMF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... }/* 
.................... void TRANSFER_DATA_NBYTE_SCFtoSMF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from COM FLASH to MISSION FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(TO_ADRESS,READ_DATA_BYTE_SCF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... } 
.................... void TRANSFER_DATA_NBYTE_SCF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(TO_ADRESS,READ_DATA_BYTE_SCF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... } 
.................... */ 
....................  
....................  
....................  
.................... #include<MEMORY_OPERATION.c> 
.................... //-------------------------ADDRESS (PREVIOUS)---------------------------------- 
.................... //!/////////////////previous////////////////////////////// 
.................... //!Static int32 ADCS_SENSOR_ADDRESS = 65536*500; 
.................... //!Static int32 FAB_HK_ADDRESS = 65536 * 200; 
.................... //!Static int32 FAB_CW_ADDRESS = 65536 * 50; 
.................... //!Static int32 FAB_CW_ADDRESS_FOR_MF = 65536; //sector1 
.................... //!Static int32 HIGH_SAMP_HK_ADDRESS = 65536 * 1800; 
.................... //!Static int32 CAM_ADDRESS = 65536; 
.................... //!Static int32 DC_STATUS_ADDRESS = 65536*300; 
.................... //!/////////////////////////////////////////////////////// 
.................... #define SECT 65536                                                               //1 Sector = 65536 Bytes 
....................  
.................... Static int32 ADD_INFO_ADDRESS = 4096;                                            //for keeping the address data to flash memory 
.................... Static int32 ADDRESS_WRITING_COUNTER = 0;                                        //if address writing more than 30000 times, change the store address 
....................  
.................... Static int32 FLAG_DATA_ADDRESS = SECT*4;                                         //1sector 
.................... Static int32 RSV_DATA_ADDRESS=SECT*5;                                            //1sector 
.................... Static int32 SAT_LOG = SECT*6;                                                   //2sector 
.................... Static int32 CAM_ADDRESS = SECT*8;                                               //90sector 
.................... Static int32 FAB_HK_ADDRESS = SECT*98;                                           //1000sector 
.................... Static int32 FAB_CW_ADDRESS = SECT*1098;                                         //40sector 
.................... Static int32 ADCS_SENSOR_ADDRESS = SECT*1138;                                    //500sector 
.................... Static int32 ADCS_TLE_ADDRESS = SECT*1637;                                       //1sector (el ultimo no utilizado por ADCS data) 
.................... Static int32 DC_STATUS_ADDRESS = SECT*1638;                                      //1sector 
.................... Static int32 HIGH_SAMP_HK_ADDRESS = SECT*1639;                                   //409sector 
.................... Static int32 FLAG_ADDRESS_EEPROM = 0x18000;                                      //from 75 percent of the programming memory 
.................... Static int32 FLASH_AD_ADDRESS_EEPROM = 0x18000 + 28;                             //after flag info 
....................                                                                                  //Definicion de direcciones de espacio de memoria (fin) 
.................... #define FLAG_DATA_ADDRESS_END  SECT*5-26                                         //considera la longitud de cada dato para determinar la direccion de finalizacion 
.................... #define RSV_DATA_ADDRESS_END  SECT*6-160 
.................... #define SAT_LOG_END  SECT*8-22 
.................... #define CAM_ADDRESS_END  SECT*98-SECT*2 
.................... #define FAB_HK_ADDRESS_END  SECT*1098-SECT-248 
.................... #define FAB_CW_ADDRESS_END  SECT*1138-10 
.................... #define FAB_CW_ADDRESS_FOR_MF_END FAB_CW_ADDRESS_END 
.................... #define ADCS_SENSOR_ADDRESS_END  SECT*1638-408000                                //408000 is for 2 hour data(85*3600*2/1.5) 
.................... #define ADCS_TLE_ADDRESS_END  SECT*1638-TLE_size 
.................... #define DC_STATUS_ADDRESS_END SECT*1639-415 
.................... #define HIGH_SAMP_HK_ADDRESS_END  SECT*2047-178560                               //178560 is for 2 hour data(124*3600*2/5) 
....................                                                                                  //Flags definition 
.................... int8 BC_ATTEMPT_FLAG = 0; 
.................... int16 PASSED_DAYS = 0; 
.................... int8 RESERVE_CHECK = 0; 
.................... int8 RESERVE_MIN_FLAG = 0; 
.................... int8 RESERVE_TARGET_FLAG = 0; 
.................... int8 MISSION_CONTENTS = 0; 
.................... int8 MISSION_DETAIL = 0; 
.................... int8 RESERVE_ADDRESS_1 = 0; 
.................... int8 RESERVE_ADDRESS_2 = 0; 
.................... int8 RESERVE_ADDRESS_3 = 0; 
.................... int8 RESERVE_ADDRESS_4 = 0; 
.................... int8 RESERVE_PACKET_NUM = 0; 
.................... int8 Kill_FLAG_MAIN = 0; 
.................... int8 Kill_FLAG_FAB = 0; 
.................... int8 FIRST_HSSC_DONE = 0; 
.................... int8 AUTO_CAM_DONE = 0; 
.................... int8 AUTO_MBP_DONE = 0; 
.................... int8 AUTO_ADCS_DONE = 0; 
.................... int8 ANT_DEP_STATUS = 0; 
.................... int8 UPLINK_SUCCESS = 0; 
....................  
.................... int8 RESERVE_SEC_FLAG = 0; 
....................  
.................... //--------MAIN PIC Buffer------------------------------------------------------ 
.................... int8 CMD_FROM_PC[8] = {}; 
.................... unsigned int8 in_bffr_main[16] = {}; 
.................... int8 COM_DATA= 0; 
.................... static int8 CW_IDENTIFIER = 0; 
.................... int8 OPERATION_MODE = 0x00; 
.................... int8 PC_DATA = 0;                                   
.................... int8 COM_ONEBYTE_COMMAND = 0;                                                    //for GS testing 
....................  
.................... #define buffer_from_com  (in_bffr_main[0]==0xAA) && (in_bffr_main[15]==0xBB) 
.................... #define buffer_flash  (in_bffr_main[7]==0x73) 
.................... #define START_ADCS_MISSION  (in_bffr_main[1]==0x73) 
.................... #define ADCS_SENSOR_SIZE 100                                                      //for testing additional 6byte for checking duty 
....................  
....................  
.................... int8 ADCS_SENSOR_DATA[ADCS_SENSOR_SIZE] = {}; 
.................... int8 ADCS_ACK = 0; 
.................... int8 ADCS_ACK_COMMING = 0;                                                       //for Checking ACK from ADCS 
.................... #define ATTEMPT_TIME 8 
....................  
....................  
.................... #define EX_PANEL_THRESHHOLD 0x14 
.................... #define HIGH_SAMP_TIMES 12                                                       //for 2 hours 
....................  
.................... //----------RESET-------------------------------------------------------------- 
.................... #define Reset_size 11                                                            //1byte ack, 4byte time, 10byte sensor 
.................... int8 RESET_DATA = 0; 
.................... int8 reset_bffr[Reset_size] = {}; 
.................... int8 reset_flag = 0; 
....................  
.................... //---------OTHER FUNCTION------------------------------------------------------ 
.................... #define FLASH_ADD_SIZE 41                                                        //10 kinds of address(40byte), 1 flag(1byte), 1 WRITING COUNTER(2byte) 
.................... #define FLAG_INFO_SIZE 16 
.................... unsigned int8 sec_add_bfr[FLASH_ADD_SIZE] = {};                                  //vector utilizado para almacenar las direcciones leidas de la flash 
.................... unsigned int8 flag_info_bffr[FLAG_INFO_SIZE] = {}; 
....................  
.................... void CURRENT_FLAG_STATUS()                                                      //Print on PC port current flag status 
.................... { 
....................    fprintf(PC,"\r\nPASSED DAYS:%x\r\n",PASSED_DAYS); 
....................    fprintf(PC,"RESERVE CHECK:%x\r\n",RESERVE_CHECK); 
....................    fprintf(PC,"Kill FLAG MAIN:%x\r\n",Kill_FLAG_MAIN); 
....................    fprintf(PC,"Kill FLAG FAB:%x\r\n",Kill_FLAG_FAB); 
....................    fprintf(PC,"AUTO HIGH SAMPLING:%x\r\n",FIRST_HSSC_DONE); 
....................    fprintf(PC,"AUTO CAM:%x\r\n",AUTO_CAM_DONE); 
....................    fprintf(PC,"AUTO MBP:%x\r\n",AUTO_MBP_DONE); 
....................    fprintf(PC,"AUTO ADCS:%x\r\n",AUTO_ADCS_DONE); 
....................    fprintf(PC,"ANTENNA DEPLOY:%x\r\n",ANT_DEP_STATUS); 
....................    fprintf(PC,"ANTENNA DEPLOY ATTEMPT:%x\r\n",BC_ATTEMPT_FLAG); 
....................    fprintf(PC,"UPLINK SUCCESS:%x\r\n\r\n",UPLINK_SUCCESS); 
....................    return; 
.................... } 
....................  
....................  
.................... void CURRENT_ADDRESS_OF_FLASH()                                                  //imprime la asignacion de direcciones de la Flash memory 
.................... {   
....................    fprintf(PC,"\r\nADD INFO ADDRESS:%lx\r\n\r\n",ADD_INFO_ADDRESS); 
....................    fprintf(PC,"FLAG DATA ADDRESS:%x%x%x%x\r\n",FLAG_DATA_ADDRESS>>24,FLAG_DATA_ADDRESS>>16,FLAG_DATA_ADDRESS>>8,FLAG_DATA_ADDRESS); 
....................    fprintf(PC,"RESERVATION TABLE ADDRESS:%x%x%x%x\r\n",RSV_DATA_ADDRESS>>24,RSV_DATA_ADDRESS>>16,RSV_DATA_ADDRESS>>8,RSV_DATA_ADDRESS); 
....................    fprintf(PC,"SATELLITE LOG ADDRESS:%x%x%x%x\r\n",SAT_LOG>>24,SAT_LOG>>16,SAT_LOG>>8,SAT_LOG); 
....................    fprintf(PC,"CAM ADDRESS:%x%x%x%x\r\n",CAM_ADDRESS>>24,CAM_ADDRESS>>16,CAM_ADDRESS>>8,CAM_ADDRESS); 
....................    fprintf(PC,"FAB HK ADDRESS:%x%x%x%x\r\n",FAB_HK_ADDRESS>>24,FAB_HK_ADDRESS>>16,FAB_HK_ADDRESS>>8,FAB_HK_ADDRESS); 
....................    fprintf(PC,"FAB CW ADDRESS:%x%x%x%x\r\n",FAB_CW_ADDRESS>>24,FAB_CW_ADDRESS>>16,FAB_CW_ADDRESS>>8,FAB_CW_ADDRESS); 
....................    fprintf(PC,"ADCS SENSOR ADDRESS:%x%x%x%x\r\n",ADCS_SENSOR_ADDRESS>>24,ADCS_SENSOR_ADDRESS>>16,ADCS_SENSOR_ADDRESS>>8,ADCS_SENSOR_ADDRESS); 
....................    fprintf(PC,"ADCS TLE ADDRESS:%x%x%x%x\r\n",ADCS_TLE_ADDRESS>>24,ADCS_TLE_ADDRESS>>16,ADCS_TLE_ADDRESS>>8,ADCS_TLE_ADDRESS); 
....................    fprintf(PC,"MISSION BOSS ADDRESS:%x%x%x%x\r\n",DC_STATUS_ADDRESS>>24,DC_STATUS_ADDRESS>>16,DC_STATUS_ADDRESS>>8,DC_STATUS_ADDRESS); 
....................    fprintf(PC,"HIGH SAMP HK ADDRESS:%x%x%x%x\r\n",HIGH_SAMP_HK_ADDRESS>>24,HIGH_SAMP_HK_ADDRESS>>16,HIGH_SAMP_HK_ADDRESS>>8,HIGH_SAMP_HK_ADDRESS); 
....................    fprintf(PC,"WRITE %lx TIMES\r\n",ADDRESS_WRITING_COUNTER); 
....................    return; 
.................... } 
....................  
.................... void ERASE_EEPROM_INFO() 
.................... { 
....................    erase_program_eeprom(FLAG_ADDRESS_EEPROM);//erase 512byte(from 0x18000 to 0x181ff) 
....................    return; 
.................... } 
....................  
.................... void WRITE_FLAG_to_EEPROM()                                                      //saves the flags in the EEPROM from the address 0x18000 (75%) 
.................... { 
.................... //total programming memory size is 128KB 
.................... //start writing the important flag from 75 percent of the programming memory(from the address of 96KB --> 0x18000) 
....................    int16 DATA; 
....................    DATA = (int16)BC_ATTEMPT_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM, DATA); 
....................    DATA = (int16)PASSED_DAYS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+2, DATA); 
....................    DATA = (int16)RESERVE_CHECK; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+4, DATA); 
....................    DATA = (int16)RESERVE_MIN_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+6, DATA); 
....................    DATA = (int16)RESERVE_TARGET_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+8, DATA); 
....................    DATA = (int16)MISSION_CONTENTS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+10, DATA); 
....................    DATA = (int16)MISSION_DETAIL; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+12, DATA); 
....................    DATA = (int16)Kill_FLAG_MAIN; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+14, DATA); 
....................    DATA = (int16)Kill_FLAG_FAB; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+16, DATA); 
....................    DATA = (int16)FIRST_HSSC_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+18, DATA); 
....................    DATA = (int16)AUTO_CAM_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+20, DATA); 
....................    DATA = (int16)AUTO_MBP_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+22, DATA); 
....................    DATA = (int16)AUTO_ADCS_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+24, DATA); 
....................    DATA = (int16)ANT_DEP_STATUS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26, DATA); 
....................    DATA = (int16)UPLINK_SUCCESS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+28, DATA); 
....................    return; 
.................... } 
.................... /* 
.................... void WRITE_AD_INFO_to_EEPROM() 
.................... { 
....................    int16 DATA; 
....................    DATA = BC_ATTEMPT_FLAG >> 16; 
....................    WRITE_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM, DATA); 
....................    DATA = BC_ATTEMPT_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM+2, DATA); 
....................    return; 
.................... } 
.................... */ 
.................... void MAKE_FLAG_from_EEPROM()                                                     //toma de la eeprom la info de los flags y los carga en sus variables respectivas 
.................... { 
....................    if((READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM)!=0xffff)&&(READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26)!=0xffff)) 
....................    { 
....................       BC_ATTEMPT_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM); 
....................       PASSED_DAYS = (int16)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+2); 
....................       RESERVE_CHECK = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+4); 
....................       RESERVE_MIN_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+6); 
....................       RESERVE_TARGET_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+8); 
....................       MISSION_CONTENTS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+10); 
....................       MISSION_DETAIL = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+12); 
....................       Kill_FLAG_MAIN = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+14); 
....................       Kill_FLAG_FAB = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+16); 
....................       FIRST_HSSC_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+18); 
....................       AUTO_CAM_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+20); 
....................       AUTO_MBP_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+22); 
....................       AUTO_ADCS_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+24); 
....................       ANT_DEP_STATUS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26); 
....................       UPLINK_SUCCESS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+28); 
....................    } 
....................     
....................    fprintf(PC,"\r\nPASSED DAYS:%lx\r\n",PASSED_DAYS); 
....................    fprintf(PC,"RESERVE CHECK:%x\r\n",RESERVE_CHECK); 
....................    fprintf(PC,"Kill FLAG MAIN:%x\r\n",Kill_FLAG_MAIN); 
....................    fprintf(PC,"Kill FLAG FAB:%x\r\n",Kill_FLAG_FAB); 
....................    fprintf(PC,"AUTO HIGH SAMPLING:%x\r\n",FIRST_HSSC_DONE); 
....................    fprintf(PC,"AUTO CAM:%x\r\n",AUTO_CAM_DONE); 
....................    fprintf(PC,"AUTO MBP:%x\r\n",AUTO_MBP_DONE); 
....................    fprintf(PC,"AUTO ADCS:%x\r\n",AUTO_ADCS_DONE); 
....................    fprintf(PC,"ANTENNA DEPLOY:%x\r\n",ANT_DEP_STATUS); 
....................    fprintf(PC,"UPLINK SUCCESS:%x\r\n\r\n",UPLINK_SUCCESS); 
....................     
....................    return; 
.................... } 
....................  
.................... void TAKE_AD_INFO_from_EEPROM()                                                  //Reads address data from de program memory 
.................... { 
....................    int16 DATA_high = READ_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM);                
....................    int16 DATA_low = READ_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM+2); 
....................    int32 DATA = (((int32)DATA_high<<16) | (int32)DATA_low); 
....................    if(DATA != 0xffffffff) 
....................    { 
....................       ADD_INFO_ADDRESS = DATA;                                                    
....................    } 
....................    return; 
.................... } 
....................  
.................... void STORE_FLAG_INFO()                                                           //save flag data to flash memory 
.................... { 
....................    flag_info_bffr[0] = BC_ATTEMPT_FLAG; 
....................    flag_info_bffr[1] = PASSED_DAYS >> 8; 
....................    flag_info_bffr[2] = PASSED_DAYS; 
....................    flag_info_bffr[3] = RESERVE_CHECK; 
....................    flag_info_bffr[4] = RESERVE_TARGET_FLAG; 
....................    flag_info_bffr[5] = RESERVE_MIN_FLAG; 
....................    flag_info_bffr[6] = MISSION_CONTENTS; 
....................    flag_info_bffr[7] = MISSION_DETAIL; 
....................    flag_info_bffr[8] = Kill_FLAG_MAIN; 
....................    flag_info_bffr[9] = Kill_FLAG_FAB; 
....................    flag_info_bffr[10] = FIRST_HSSC_DONE; 
....................    flag_info_bffr[11] = AUTO_CAM_DONE; 
....................    flag_info_bffr[12] = AUTO_MBP_DONE; 
....................    flag_info_bffr[13] = AUTO_ADCS_DONE; 
....................    flag_info_bffr[14] = ANT_DEP_STATUS; 
....................    flag_info_bffr[15] = UPLINK_SUCCESS; 
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
....................    SUBSECTOR_4KB_ERASE_OF(FLAG_DATA_ADDRESS); 
....................    delay_ms(200); 
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
....................       delay_us(10); 
....................    } 
....................    delay_ms(10); 
....................    SUBSECTOR_4KB_ERASE_SCF(FLAG_DATA_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
....................       delay_us(10); 
....................    } 
....................    delay_ms(10); 
....................    SUBSECTOR_4KB_ERASE_SMF(FLAG_DATA_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
....................       delay_us(10); 
....................    } 
....................     
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
....................     
....................    fprintf(PC,"FLAG INFO STORED IN FLASH\r\n"); 
....................    return; 
....................     
.................... } 
....................  
.................... void RESET_FLAG_DATA() 
.................... { 
....................    //BC_ATTEMPT_FLAG = 0; 
....................    PASSED_DAYS = 0; 
....................    //RESERVE_CHECK = 0; 
....................    //RESERVE_MIN_FLAG = 0; 
....................    //RESERVE_TARGET_FLAG = 0; 
....................    //MISSION_CONTENTS = 0; 
....................    //MISSION_DETAIL = 0; 
....................    Kill_FLAG_MAIN = 0; 
....................    Kill_FLAG_FAB = 0; 
....................    FIRST_HSSC_DONE = 0; 
....................    AUTO_CAM_DONE = 0; 
....................    AUTO_MBP_DONE = 0; 
....................    AUTO_ADCS_DONE = 0; 
....................    ANT_DEP_STATUS = 0; 
....................    UPLINK_SUCCESS = 0; 
....................    STORE_FLAG_INFO(); 
....................    WRITE_FLAG_to_EEPROM(); 
....................    return; 
.................... } 
....................  
.................... void READ_WRTITING_ADDRESS_LOCATION()                                            //load the variable ADD_INFO_ADDRESS, look for the data in OF, SCF, SMF and EEPROM (carga la variable ADD_INFO_ADDRESS, busca el dato en OF, SCF, SMF y EEPROM) 
.................... {                                                                                //if you can't find it use the initial value (si no lo encuentra usa el valor inicial) 
....................    int i; 
....................    int8 ad_location_bfr[4]; 
....................    output_low(PIN_C4);                                                           //Main side 
....................    output_low(PIN_A5);                                                           //Main side 
....................    if(READ_DATA_BYTE_OF(0) == 0xff)                                              //this means there is no address data in OBC Flash 
....................    { 
....................       if(READ_DATA_BYTE_SCF(0) == 0xff)                                          //this means there is no address data in Shared COM Flash 
....................       { 
....................          if(READ_DATA_BYTE_SMF(0) == 0xff)                                       //if all memory was empty, location should be initial value 
....................          { 
....................             TAKE_AD_INFO_from_EEPROM();                                          //if inside of eeprom is also empty, use the initial value 
....................             ad_location_bfr[0] = ADD_INFO_ADDRESS >> 24; 
....................             ad_location_bfr[1] = ADD_INFO_ADDRESS >> 16; 
....................             ad_location_bfr[2] = ADD_INFO_ADDRESS >> 8; 
....................             ad_location_bfr[3] = ADD_INFO_ADDRESS; 
....................          }else{ 
....................             ad_location_bfr[0] = READ_DATA_BYTE_SMF(0); 
....................             ad_location_bfr[1] = READ_DATA_BYTE_SMF(1); 
....................             ad_location_bfr[2] = READ_DATA_BYTE_SMF(2); 
....................             ad_location_bfr[3] = READ_DATA_BYTE_SMF(3); 
....................             ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
....................          } 
....................       }else{ 
....................          ad_location_bfr[0] = READ_DATA_BYTE_SCF(0); 
....................          ad_location_bfr[1] = READ_DATA_BYTE_SCF(1); 
....................          ad_location_bfr[2] = READ_DATA_BYTE_SCF(2); 
....................          ad_location_bfr[3] = READ_DATA_BYTE_SCF(3); 
....................          ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
....................       } 
....................    }else{ 
....................       ad_location_bfr[0] = READ_DATA_BYTE_OF(0); 
....................       ad_location_bfr[1] = READ_DATA_BYTE_OF(1); 
....................       ad_location_bfr[2] = READ_DATA_BYTE_OF(2); 
....................       ad_location_bfr[3] = READ_DATA_BYTE_OF(3); 
....................       ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
....................    } 
....................     
....................    for(i = 0; i < 4; i++)                                                        //store the subsector(location) information 
....................    { 
....................       WRITE_DATA_BYTE_OF(i,ad_location_bfr[i]); 
....................       WRITE_DATA_BYTE_SCF(i,ad_location_bfr[i]); 
....................       WRITE_DATA_BYTE_SMF(i,ad_location_bfr[i]); 
....................    } 
....................    output_high(PIN_C4); 
....................    fprintf(PC,"\r\naddress info location:%lx\r\n",ADD_INFO_ADDRESS); 
....................    return; 
.................... } 
....................  
.................... void CHANGE_ADDRESS_WRITING_LOCATION()                                           //cambia la direccion de escritura de address locations cuando se superan los 95.000 ciclos 
.................... { 
....................    int32 AD_COUNTER = make32(READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+37),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+38),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+39),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+40));//check counter value 
....................    fprintf(PC,"AD COUNTER:%lx\r\n",AD_COUNTER); 
....................    if((AD_COUNTER > 95000) && (AD_COUNTER != 0xffffffff)) 
....................    { 
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_OF(0); 
....................       SUBSECTOR_4KB_ERASE_SCF(0); 
....................       SUBSECTOR_4KB_ERASE_SMF(0); 
....................       ADDRESS_WRITING_COUNTER = 0;                                               //reset counter 
....................       ADD_INFO_ADDRESS = ADD_INFO_ADDRESS + 0x00001000;                          //use next subsector 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       unsigned int8 address_place[4] = {}; 
....................       address_place[0] = ADD_INFO_ADDRESS >> 24; 
....................       address_place[1] = ADD_INFO_ADDRESS >> 16; 
....................       address_place[2] = ADD_INFO_ADDRESS >> 8; 
....................       address_place[3] = ADD_INFO_ADDRESS; 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       for(int i = 0; i < 4; i++)                                                 //store the new subsector(location) information 
....................       { 
....................          WRITE_DATA_BYTE_OF(i,address_place[i]);                                 //se le pasa direccion y dato 
....................          delay_us(10); 
....................          WRITE_DATA_BYTE_SCF(i,address_place[i]); 
....................          delay_us(10); 
....................          WRITE_DATA_BYTE_SMF(i,address_place[i]); 
....................          delay_us(10); 
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       fprintf(PC,"CHANGED MEMORY ADDRESS:"); 
....................       for(i = 0; i < 4; i++)                                                     //store the subsector(location) information 
....................       { 
....................          fprintf(PC,"%x",READ_DATA_BYTE_OF(i)); 
....................       } 
....................       fprintf(PC,"\r\n"); 
....................    } 
....................     
....................    return; 
.................... } 
....................  
.................... void TAKE_FLAG_INFO_FROM_OF()                                                    //Funcion que lee de memoria el dato de los FLAGS 
.................... { 
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       flag_info_bffr[num] = READ_DATA_BYTE_OF(FLAG_DATA_ADDRESS + num);          //guarda los datos en el vector flag_info_bffr[] 
....................       //delay_ms(1); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void STORE_ADRESS_DATA_TO_FLASH()                                                //save the address data in a new sector if the R / W cycle is reached 
.................... { 
....................    fprintf(PC,"\r\nStoreing Address Data in Flash\r\n"); 
....................    ADDRESS_WRITING_COUNTER++;                                                    //contador de escrituras en una direccion 
....................    CHANGE_ADDRESS_WRITING_LOCATION();                                            //cambia la direccion del lugar de escritura si se superan 95000 ciclos 
....................    sec_add_bfr[0] = FLAG_DATA_ADDRESS >> 24;                                     //se carga el array sec_add_bfr[] con los datos de las direcciones 
....................    sec_add_bfr[1] = FLAG_DATA_ADDRESS >> 16; 
....................    sec_add_bfr[2] = FLAG_DATA_ADDRESS >> 8; 
....................    sec_add_bfr[3] = FLAG_DATA_ADDRESS; 
....................        
....................    sec_add_bfr[4] = RSV_DATA_ADDRESS >> 24; 
....................    sec_add_bfr[5] = RSV_DATA_ADDRESS >> 16; 
....................    sec_add_bfr[6] = RSV_DATA_ADDRESS >> 8; 
....................    sec_add_bfr[7] = RSV_DATA_ADDRESS; 
....................     
....................    sec_add_bfr[8] = SAT_LOG >> 24; 
....................    sec_add_bfr[9] = SAT_LOG >> 16; 
....................    sec_add_bfr[10] = SAT_LOG >> 8; 
....................    sec_add_bfr[11] = SAT_LOG; 
....................     
....................    sec_add_bfr[12] = CAM_ADDRESS >> 24; 
....................    sec_add_bfr[13] = CAM_ADDRESS >> 16; 
....................    sec_add_bfr[14] = CAM_ADDRESS >> 8; 
....................    sec_add_bfr[15] = CAM_ADDRESS; 
....................     
....................    sec_add_bfr[16] = FAB_HK_ADDRESS >> 24; 
....................    sec_add_bfr[17] = FAB_HK_ADDRESS >> 16; 
....................    sec_add_bfr[18] = FAB_HK_ADDRESS >> 8; 
....................    sec_add_bfr[19] = FAB_HK_ADDRESS; 
....................     
....................    sec_add_bfr[20] = FAB_CW_ADDRESS >> 24; 
....................    sec_add_bfr[21] = FAB_CW_ADDRESS >> 16; 
....................    sec_add_bfr[22] = FAB_CW_ADDRESS >> 8; 
....................    sec_add_bfr[23] = FAB_CW_ADDRESS; 
....................     
....................    sec_add_bfr[24] = ADCS_SENSOR_ADDRESS >> 24; 
....................    sec_add_bfr[25] = ADCS_SENSOR_ADDRESS >> 16; 
....................    sec_add_bfr[26] = ADCS_SENSOR_ADDRESS >> 8; 
....................    sec_add_bfr[27] = ADCS_SENSOR_ADDRESS; 
....................     
....................    sec_add_bfr[28] = DC_STATUS_ADDRESS >> 24; 
....................    sec_add_bfr[29] = DC_STATUS_ADDRESS >> 16; 
....................    sec_add_bfr[30] = DC_STATUS_ADDRESS >> 8; 
....................    sec_add_bfr[31] = DC_STATUS_ADDRESS; 
....................     
....................    sec_add_bfr[32] = HIGH_SAMP_HK_ADDRESS >> 24; 
....................    sec_add_bfr[33] = HIGH_SAMP_HK_ADDRESS >> 16; 
....................    sec_add_bfr[34] = HIGH_SAMP_HK_ADDRESS >> 8; 
....................    sec_add_bfr[35] = HIGH_SAMP_HK_ADDRESS; 
....................     
....................    sec_add_bfr[36] = BC_ATTEMPT_FLAG; 
....................     
....................     
....................    sec_add_bfr[37] = ADDRESS_WRITING_COUNTER >> 24; 
....................    sec_add_bfr[38] = ADDRESS_WRITING_COUNTER >> 16; 
....................    sec_add_bfr[39] = ADDRESS_WRITING_COUNTER >> 8; 
....................    sec_add_bfr[40] = ADDRESS_WRITING_COUNTER; 
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
....................    int8 num = 0; 
....................    SUBSECTOR_4KB_ERASE_OF(ADD_INFO_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en OBC FLASH 
....................    { 
....................       WRITE_DATA_BYTE_OF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
....................       delay_us(10); 
....................    } 
....................    SUBSECTOR_4KB_ERASE_SCF(ADD_INFO_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en COM FLASH 
....................    { 
....................       WRITE_DATA_BYTE_SCF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
....................       delay_us(10); 
....................    } 
....................    SUBSECTOR_4KB_ERASE_SMF(ADD_INFO_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en MISSION FLASH 
....................    { 
....................       WRITE_DATA_BYTE_SMF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
....................       delay_us(10); 
....................    } 
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
....................    
....................    fprintf(PC,"ADDRESS DATA STORE DONE:%lx\r\n",ADD_INFO_ADDRESS); 
....................    return; 
.................... } 
....................  
.................... void TAKE_ADDRESS_DATA_FROM_OF()                                                 //Funcion que toma de la memoria las direcciones almacenadas en los primeros lugares 
.................... {   
....................     
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_OF(ADD_INFO_ADDRESS + num); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void TAKE_ADDRESS_DATA_FROM_SCF() 
.................... {   
....................    output_low(PIN_C4);   
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_SCF(ADD_INFO_ADDRESS + num); 
....................    } 
....................    output_high(PIN_C4); 
....................    return; 
.................... } 
....................  
.................... void TAKE_ADDRESS_DATA_FROM_SMF() 
.................... {   
....................    output_low(PIN_A5);   
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_SMF(ADD_INFO_ADDRESS + num); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void MAKE_FLAG_INFO()                                                            //Guarda en cada variable la informacion de flags recuperadas de memoria 
.................... { 
....................    BC_ATTEMPT_FLAG     = flag_info_bffr[0]; 
....................    PASSED_DAYS         = make16(flag_info_bffr[1],flag_info_bffr[2]); 
....................    RESERVE_CHECK       = flag_info_bffr[3]; 
....................    RESERVE_TARGET_FLAG = flag_info_bffr[4]; 
....................    RESERVE_MIN_FLAG    = flag_info_bffr[5]; 
....................    MISSION_CONTENTS    = flag_info_bffr[6]; 
....................    MISSION_DETAIL      = flag_info_bffr[7]; 
....................    Kill_FLAG_MAIN      = flag_info_bffr[8]; 
....................    Kill_FLAG_FAB       = flag_info_bffr[9]; 
....................    FIRST_HSSC_DONE     = flag_info_bffr[10]; 
....................    AUTO_CAM_DONE       = flag_info_bffr[11]; 
....................    AUTO_MBP_DONE       = flag_info_bffr[12]; 
....................    AUTO_ADCS_DONE      = flag_info_bffr[13]; 
....................    ANT_DEP_STATUS      = flag_info_bffr[14]; 
....................    UPLINK_SUCCESS      = flag_info_bffr[15]; 
....................    if(PASSED_DAYS == 0xffff) 
....................    { 
....................       COLLECT_RESET_DATA();                                                      //funcion que envia el comando 0x28 al reset PIC y carga reset_bffr[] 
....................       PASSED_DAYS = make16(reset_bffr[4],reset_bffr[5]); 
....................    } 
....................    return; 
.................... } 
....................                                                                              
.................... void MAKE_ADDRESS_DATA()                                                         //Funcion que separa los datos de direcciones en cada variable correspondiente 
.................... {                                                                                //sec_add_bfr[] vector que contiene los datos de direcciones 
....................  
....................  
....................    FLAG_DATA_ADDRESS = make32(sec_add_bfr[0],sec_add_bfr[1],sec_add_bfr[2],sec_add_bfr[3]);//FLAG_DATA_ADDRESS_1 | FLAG_DATA_ADDRESS_2 | FLAG_DATA_ADDRESS_3 | FLAG_DATA_ADDRESS_4; 
....................     
....................    RSV_DATA_ADDRESS = make32(sec_add_bfr[4],sec_add_bfr[5],sec_add_bfr[6],sec_add_bfr[7]);//RSV_DATA_ADDRESS_1| RSV_DATA_ADDRESS_2 | RSV_DATA_ADDRESS_3 | RSV_DATA_ADDRESS_4; 
....................     
....................    SAT_LOG = make32(sec_add_bfr[8],sec_add_bfr[9],sec_add_bfr[10],sec_add_bfr[11]);//SAT_LOG_1 | SAT_LOG_2 | SAT_LOG_3 | SAT_LOG_4; 
....................     
....................    CAM_ADDRESS = make32(sec_add_bfr[12],sec_add_bfr[13],sec_add_bfr[14],sec_add_bfr[15]);//CAM_ADDRESS_1 | CAM_ADDRESS_2 | CAM_ADDRESS_3 | CAM_ADDRESS_4; 
....................     
....................    FAB_HK_ADDRESS = make32(sec_add_bfr[16],sec_add_bfr[17],sec_add_bfr[18],sec_add_bfr[19]);//FAB_HK_ADDRESS_1 | FAB_HK_ADDRESS_2 | FAB_HK_ADDRESS_3 | FAB_HK_ADDRESS_4; 
....................  
....................    FAB_CW_ADDRESS = make32(sec_add_bfr[20],sec_add_bfr[21],sec_add_bfr[22],sec_add_bfr[23]);//FAB_CW_ADDRESS_1| FAB_CW_ADDRESS_2 | FAB_CW_ADDRESS_3 | FAB_CW_ADDRESS_4; 
....................     
....................    ADCS_SENSOR_ADDRESS = make32(sec_add_bfr[24],sec_add_bfr[25],sec_add_bfr[26],sec_add_bfr[27]);//ADCS_SENSOR_ADDRESS_1 | ADCS_SENSOR_ADDRESS_2 | ADCS_SENSOR_ADDRESS_3 | ADCS_SENSOR_ADDRESS_4; 
....................     
....................    DC_STATUS_ADDRESS = make32(sec_add_bfr[28],sec_add_bfr[29],sec_add_bfr[30],sec_add_bfr[31]);//DC_STATUS_ADDRESS_1 | DC_STATUS_ADDRESS_2 | DC_STATUS_ADDRESS_3 | DC_STATUS_ADDRESS_4; 
....................     
....................    HIGH_SAMP_HK_ADDRESS = make32(sec_add_bfr[32],sec_add_bfr[33],sec_add_bfr[34],sec_add_bfr[35]);//HIGH_SAMP_HK_ADDRESS = HIGH_SAMP_HK_ADDRESS_1 | HIGH_SAMP_HK_ADDRESS_2 | HIGH_SAMP_HK_ADDRESS_3 | HIGH_SAMP_HK_ADDRESS_4; 
....................     
....................    ADDRESS_WRITING_COUNTER = make32(sec_add_bfr[36],sec_add_bfr[37],sec_add_bfr[38],sec_add_bfr[39]);//ADDRESS_WRITING_COUNTER_1 | ADDRESS_WRITING_COUNTER_2 
....................     
....................    return; 
.................... } 
....................  
.................... void CHECK_FLAG_INFO()                                                           //funcion que imprime los datos de los flags y los separa en cada variable 
.................... { 
....................    int8 checksum = 0; 
....................    TAKE_FLAG_INFO_FROM_OF();                                                     //funcion que lee de la Main flash el estado de los flags y carga el array flag_info_bffr 
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       if(flag_info_bffr[num] == 0xff)                                            //si la informacion recuperada es 0xff (no hay informacion) incrementa el checksum 
....................       { 
....................          checksum++; 
....................       } 
....................    } 
....................    //fprintf(PC,"%d",checksum); 
....................     
....................    if((flag_info_bffr[0]!=0xff)&&(flag_info_bffr[FLAG_INFO_SIZE-1]!=0xff))       //if something stored 
....................    { 
....................       for(num = 0; num < FLAG_INFO_SIZE; num++)                                  //imprime la informacion de los flags 
....................       { 
....................          fprintf(PC,"%x",flag_info_bffr[num]); 
....................       } 
....................       MAKE_FLAG_INFO();                                                          //separa el estado de los flags en cada variable 
....................    }else{                                                                        //if nothing stored 
....................       MAKE_FLAG_from_EEPROM();                                                   //lee de la eeprom el estado de los flags 
....................    } 
....................    checksum = 0; 
....................    return; 
.................... } 
....................  
.................... void CHECK_ADDRESS_DATA()                                                        //imprime los datos de direcciones y los separa en cada variable correspondiente 
.................... { 
....................    int8 checksum = 0; 
....................    TAKE_ADDRESS_DATA_FROM_OF();                                                  //craga el array sec_add_bfr[] con address location info y lo imprime                                                   
....................    for(int8 num = 37; num < 41; num++)                                           //check the data of last 4 byte 
....................    { 
....................       if(sec_add_bfr[num] == 0xff)                                               //if nothing, count checksum 
....................       { 
....................          checksum++; 
....................       } 
....................    } 
....................     
....................    if(checksum != 4)                                                             //if something stored (if last 4 byte were not 0xff) 
....................    { 
....................       for(num = 0; num < FLASH_ADD_SIZE; num++) 
....................       { 
....................          fprintf(PC,"%x",sec_add_bfr[num]);                                      //imprime el contenido de sec_add_bfr[] que contiene las direcciones 
....................       } 
....................       fprintf(PC,"\r\n"); 
....................       MAKE_ADDRESS_DATA();                                                       //los separa en las variables correspondientes a cada direccion 
....................    }else{                                                                        //if there is nothing, check from SCF 
....................       output_low(PIN_C4); 
....................       TAKE_ADDRESS_DATA_FROM_SCF(); 
....................       output_high(PIN_C4); 
....................       checksum = 0; 
....................       for(num = 37; num < 41; num++)                                             //check the data of last 4 byte 
....................       { 
....................          if(sec_add_bfr[num] == 0xff)                                            //if nothing, count checksum 
....................          { 
....................             checksum++; 
....................          } 
....................       } 
....................       if(checksum != 4) 
....................       { 
....................          for(num = 0; num < FLASH_ADD_SIZE; num++) 
....................          { 
....................             fprintf(PC,"%x",sec_add_bfr[num]); 
....................          } 
....................          fprintf(PC,"\r\n"); 
....................          MAKE_ADDRESS_DATA(); 
....................       }else{                                                                     //if there is nothing, check from SMF 
....................          output_low(PIN_A5); 
....................          TAKE_ADDRESS_DATA_FROM_SMF(); 
....................          checksum = 0; 
....................          for(num = 37; num < 41; num++)                                          //check the data of last 4 byte 
....................          { 
....................             if(sec_add_bfr[num] == 0xff)                                         //if nothing, count checksum 
....................             { 
....................                checksum++; 
....................             } 
....................          } 
....................          if(checksum != 4) 
....................          { 
....................             for(num = 0; num < FLASH_ADD_SIZE; num++) 
....................             { 
....................                fprintf(PC,"%x",sec_add_bfr[num]); 
....................             } 
....................             fprintf(PC,"\r\n"); 
....................             MAKE_ADDRESS_DATA(); 
....................          } 
....................       } 
....................    }   
....................    checksum = 0;   
....................    return; 
.................... } 
....................  
.................... ////////////////////////// 
.................... //FAB_HK_ADDRESS        // 
.................... //FAB_CW_ADDRESS        // 
.................... //ADCS_SENSOR_ADDRESS   // 
.................... //CAM_ADDRESS           // 
.................... //DC_STATUS_ADDRESS     // 
.................... ////////////////////////// 
.................... void MEMORY_ERASE() 
.................... { 
....................    fprintf(PC,"FLASH MEMORY ERASE START\r\n"); 
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
....................     
....................    sector_erase_OF(0); 
....................    sector_erase_SCF(0); 
....................    sector_erase_SMF(0); 
....................     
....................    sector_erase_OF(FAB_CW_ADDRESS); 
....................    sector_erase_SCF(FAB_CW_ADDRESS); 
....................    sector_erase_SMF(FAB_CW_ADDRESS); 
....................     
....................     
....................    for(int8 num = 0; num < 5; num++) 
....................    { 
....................       sector_erase_OF(FLAG_DATA_ADDRESS + SECT*num);                             //65536*num 
....................       sector_erase_OF(CAM_ADDRESS + SECT*num);                                   //65536*num 
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT*num);                                //65536*num 
....................       sector_erase_OF(ADCS_SENSOR_ADDRESS + SECT*num);                           //65536*num 
....................       sector_erase_OF(DC_STATUS_ADDRESS + SECT*num);                             //65536*num 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*num);                          //65536*num 
....................        
....................       sector_erase_SCF(FLAG_DATA_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SCF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SCF(ADCS_SENSOR_ADDRESS + SECT*num);                          //65536*num 
....................       sector_erase_SCF(DC_STATUS_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................        
....................       sector_erase_SMF(FLAG_DATA_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SMF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SMF(ADCS_SENSOR_ADDRESS + SECT*num);                          //65536*num 
....................       sector_erase_SMF(DC_STATUS_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................    } 
....................    for(num = 5; num < 10; num++) 
....................    { 
....................       sector_erase_OF(CAM_ADDRESS + SECT*num);                                   //65536*num 
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT*num);                                //65536*num 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*num);                          //65536*num 
....................        
....................       sector_erase_SCF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................        
....................       sector_erase_SMF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................    } 
....................     
....................    sector_erase_OF(0x06650000);                                                  //erase ADCS TLE address 
....................    sector_erase_SCF(0x06650000); 
....................    sector_erase_SMF(0x06650000); 
....................     
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
....................    delay_ms(10000); 
....................    fprintf(PC,"FLASH MEMORY ERASE DONE\r\n"); 
....................    for(int t=60; t>0; t--){ 
....................    fprintf(PC,"Remaining time: %d  \r", t); 
....................    delay_ms(1000); 
....................    } 
....................    //delay_ms(60000); 
....................    return; 
.................... } 
.................... /* 
.................... //@@@@@@@@@@@@@@@@@@MISSION LOOP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... void LOOP_FLAG_DATA_ADDRESS() 
.................... { 
....................     
....................    if(FLAG_DATA_ADDRESS > FLAG_DATA_ADDRESS_END) 
....................    { 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_RSV_DATA_ADDRESS() 
.................... { 
....................    if(RSV_DATA_ADDRESS > RSV_DATA_ADDRESS_END) 
....................    { 
....................        
....................    } 
....................    return; 
.................... } 
.................... */ 
.................... void LOOP_SAT_LOG()                                                              //hace un loop en las posiciones de memoria para almacenar SAT_LOG 
.................... { 
....................    if(SAT_LOG >= SAT_LOG_END)                                                    //si la posicion de escritura de SAT_LOG alcanza a SAT_LOG_END 
....................    { 
....................       sector_erase_OF(SECT*7);                                                   //borra un sector de la MAIN flash, 65536*7 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*7);                                                  //borra un sector de la COM flash,65536*7 
....................       output_high(PIN_C4);                                                       //CAM_MUX MAINSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*7);                                                  //borra un sector de la MISSION flash,65536*7 
....................       SAT_LOG = SECT*7;                                                          //Cambia la direccion de SAT_LOG y mantiene el primer sector,65536*7 
....................       STORE_ADRESS_DATA_TO_FLASH();                                              //guarda los datos de direcciones, sera en un nuevo sector si se cumple el ciclo de R/W 
....................    } 
....................    //output_high(PIN_C4);//COM_MUX COMSIDE 
....................    return; 
.................... } 
....................  
.................... void LOOP_CAM_ADDRESS()                                                          //hace un loop en las posiciones de memoria para almacenar CAM data 
.................... { 
....................    if(CAM_ADDRESS >= CAM_ADDRESS_END)                                            //si la posicion de escritura de CAM alcanza a CAM_ADDRESS_END 
....................    { 
....................       sector_erase_OF(SECT*9);                                                   //borra 1 sector de la MAIN flash, 65536*9 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*9);                                                  //borra 1 sector de la COM flash, 65536*9 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*9);                                                  //borra 1 sector de la MISSION flash, 65536*9 
....................        
....................       CAM_ADDRESS = SECT*9;                                                      //CAM address se ubica ahora en el comienzo del espacio designado a CAM 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_FAB_HK_ADDRESS()                                                       //Rota las posiciones de guardado de los datos si llega al final del espacio asignado                                                        
.................... { 
....................    int32 checksum = FAB_HK_ADDRESS && 0x0000ffff; 
....................    if(FAB_HK_ADDRESS >= FAB_HK_ADDRESS_END)                                       
....................    { 
....................       sector_erase_OF(SECT*98); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*98); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*98); 
....................        
....................       FAB_HK_ADDRESS = 65536*8;                                                  //la nueva direccion vuelve a ser el comienzo del espacio asignado 
....................       STORE_ADRESS_DATA_TO_FLASH();                                              //guarda los datos de direcciones y en un nuevo sector si se cumple el ciclo de R/W 
....................    }else if(65536 - checksum < 119){                                             //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT);                                    //erase next sector in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_FAB_CW_ADDRESS()                                                       //Rota las posiciones de guardado de los datos si llega al final del espacio asignado  
.................... { 
....................    int32 checksum = FAB_CW_ADDRESS && 0x0000ffff; 
....................    if(FAB_CW_ADDRESS >= FAB_CW_ADDRESS_END) 
....................    {   
....................       sector_erase_OF(SECT*1098); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*1098); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*1098); 
....................        
....................       FAB_CW_ADDRESS = SECT*1098; 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    }else if(SECT - checksum < 5){                                                //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       sector_erase_OF(FAB_CW_ADDRESS + SECT);                                    //erase next sector in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(FAB_CW_ADDRESS + SECT);                                   //erase next sector in advance 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(FAB_CW_ADDRESS + SECT);                                   //erase next sector in advance 
....................        
....................    } 
....................    return; 
.................... } 
....................  
....................  
.................... void LOOP_ADCS_SENSOR_ADDRESS() 
.................... { 
....................    if(ADCS_SENSOR_ADDRESS >= ADCS_SENSOR_ADDRESS_END)                            //for 15min operation, data size will be more than 1sector 
....................    { 
....................       sector_erase_OF(SECT*1140); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*1140); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*1140); 
....................        
....................       ADCS_SENSOR_ADDRESS = SECT*1140;                                           //keep first 2 sector forever 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    }else{                                                                        //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       int i; 
....................       for(i = 1; i < 10; i++) 
....................       { 
....................          sector_erase_OF(ADCS_SENSOR_ADDRESS + SECT*i);                          //erase next sector in advance 
....................       } 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       for(i = 1; i < 10; i++) 
....................       { 
....................          sector_erase_SCF(ADCS_SENSOR_ADDRESS + SECT*i);                         //erase next sector in advance 
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       for(i = 1; i < 10; i++) 
....................       { 
....................          sector_erase_SMF(ADCS_SENSOR_ADDRESS + SECT*i);                         //erase next sector in advance 
....................       } 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_DC_STATUS_ADDRESS() 
.................... { 
....................    int32 checksum = DC_STATUS_ADDRESS && 0x00000fff; 
....................    if(DC_STATUS_ADDRESS >= DC_STATUS_ADDRESS_END) 
....................    { 
....................       SUBSECTOR_4KB_ERASE_OF(SECT*1639+4096); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SCF(SECT*16394096); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SMF(SECT*1639+4096); 
....................        
....................       DC_STATUS_ADDRESS = SECT*1639+4096;                                        //keep first 1 SUBSECTOR forever 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    }else if(4096 - checksum < 800){                                              //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       SUBSECTOR_4KB_ERASE_OF(DC_STATUS_ADDRESS + 4096);                          //erase next SUBSECTOR in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SCF(DC_STATUS_ADDRESS + 4096);                         //erase next SUBSECTOR in advance 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SMF(DC_STATUS_ADDRESS + 4096);                         //erase next SUBSECTOR in advance 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_HIGH_SAMP_HK_ADDRESS() 
.................... { 
....................    if(HIGH_SAMP_HK_ADDRESS >= HIGH_SAMP_HK_ADDRESS_END)                          //for 15min operation, data size will be more than 2sector 
....................    { 
....................       sector_erase_OF(SECT*1642);                                                //delet from 066A0000 (keep first 3 sectors) 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*1642); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*1642); 
....................        
....................       HIGH_SAMP_HK_ADDRESS = SECT*1642;                                          //keep first 3 sector forever 
....................    }else{                                                                        //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT);                              //erase next sector in advance 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*2);                            //erase next sector in advance 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*3);                            //erase next sector in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT);                             //erase next sector in advance 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*2);                           //erase next sector in advance 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*3);                           //erase next sector in advance 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT);                             //erase next sector in advance 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*2);                           //erase next sector in advance 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*3);                           //erase next sector in advance 
....................    } 
....................    return; 
.................... } 
....................  
....................  
....................  
.................... #include<mainpic_function.c> 
....................  
.................... int8 MISSION_STATUS = 0;                                                         //MISSION STATUS FLAGS 
.................... static int16 currenttime = 0; 
.................... BYTE command[9]; 
.................... int8 reset_time_data[11] = {}; 
.................... BYTE PINO_DATA[39] = {0x00}; 
.................... int8 test_data[11] = {0}; 
.................... unsigned int32 address_data[4]; 
.................... unsigned int32 packet_data[2]; 
.................... unsigned int32 address; 
.................... unsigned int32 packet; 
.................... BYTE RTUC[8]; 
.................... BYTE Down[81]; 
.................... BYTE RTDC[9]; 
.................... BYTE dummy[1]; 
.................... BYTE Finish_sign[1]; 
.................... int i; 
.................... void Turn_On_CAM() 
.................... { 
....................    output_high (PIN_D7); 
....................    return; 
.................... } 
.................... void Turn_Off_CAM() 
.................... { 
....................    output_low (PIN_D7); 
....................    return; 
.................... } 
.................... void Flash_Memory_Access() 
.................... { 
....................    sector_erase_OF (0x00000000); 
....................    WRITE_DATA_BYTE_OF (0x00000000, 0x01) ; 
....................    TRANSFER_DATA_NBYTE_TOPC_OF (0x00000000, 1) ; 
....................    delay_ms (1000); 
....................     
....................    sector_erase_OF (0x00000000); 
....................    WRITE_DATA_BYTE_OF (0x00000000, 0x02) ; 
....................    TRANSFER_DATA_NBYTE_TOPC_OF (0x00000000, 1) ; 
....................    delay_ms (1000); 
....................     
....................    sector_erase_OF (0x00000000); 
....................    WRITE_DATA_BYTE_OF (0x00000000, 0x03) ; 
....................    TRANSFER_DATA_NBYTE_TOPC_OF (0x00000000, 1) ; 
....................    delay_ms (1000); 
.................... } 
....................  
.................... void ten_sec_counter(){ 
....................    int counter=0; 
....................    int sec=0; 
....................  
....................  
....................       counter++; //16.384ms for one increment 
....................       if(counter>60) 
....................       { 
....................          counter = 0; 
....................          sec++; 
....................       } 
....................       else if(sec>9){ 
....................          break; 
....................       } 
.................... } 
....................  
.................... void PINO_Test() 
.................... { 
....................    dummy[0] = 0x01; 
*
00E2C:  MOVLW  01
00E2E:  MOVLB  2
00E30:  MOVWF  x00
....................    int32 num; 
....................    while (TRUE) 
....................    { 
....................       command[0] = 0x00; 
00E32:  MOVLB  1
00E34:  CLRF   x38
....................        
....................       for (num = 0; num < 100; num++) 
00E36:  MOVLB  2
00E38:  CLRF   x11
00E3A:  CLRF   x10
00E3C:  CLRF   x0F
00E3E:  CLRF   x0E
00E40:  MOVF   x11,F
00E42:  BNZ   0E9E
00E44:  MOVF   x10,F
00E46:  BNZ   0E9E
00E48:  MOVF   x0F,F
00E4A:  BNZ   0E9E
00E4C:  MOVF   x0E,W
00E4E:  SUBLW  63
00E50:  BNC   0E9E
....................       { 
....................          if (kbhit (fab)) 
00E52:  BTFSS  FA6.5
00E54:  BRA    0E8C
....................          { 
....................  
....................             for (int i = 0; i < 9; i++) 
00E56:  CLRF   x12
00E58:  MOVF   x12,W
00E5A:  SUBLW  08
00E5C:  BNC   0E8A
....................             { 
....................                //fprintf (fab, "Get command\r\n") ; 
....................                command[i] = fgetc (fab); 
00E5E:  CLRF   03
00E60:  MOVF   x12,W
00E62:  ADDLW  38
00E64:  MOVWF  FE9
00E66:  MOVLW  01
00E68:  ADDWFC 03,W
00E6A:  MOVWF  FEA
00E6C:  MOVFF  FEA,217
00E70:  MOVFF  FE9,216
00E74:  MOVLB  0
00E76:  BRA    07DC
00E78:  MOVFF  217,FEA
00E7C:  MOVFF  216,FE9
00E80:  MOVFF  01,FEF
00E84:  MOVLB  2
00E86:  INCF   x12,F
00E88:  BRA    0E58
....................             } 
....................             break; 
00E8A:  BRA    0E9E
....................          } 
00E8C:  MOVLW  01
00E8E:  ADDWF  x0E,F
00E90:  BTFSC  FD8.0
00E92:  INCF   x0F,F
00E94:  BTFSC  FD8.2
00E96:  INCF   x10,F
00E98:  BTFSC  FD8.2
00E9A:  INCF   x11,F
00E9C:  BRA    0E40
....................       } 
....................       switch (command[0]) 
00E9E:  MOVLB  1
00EA0:  MOVF   x38,W
00EA2:  XORLW  12
00EA4:  MOVLB  0
00EA6:  BZ    0EE0
00EA8:  XORLW  06
00EAA:  BTFSC  FD8.2
00EAC:  BRA    1026
00EAE:  XORLW  02
00EB0:  BTFSC  FD8.2
00EB2:  BRA    11B8
00EB4:  XORLW  86
00EB6:  BTFSC  FD8.2
00EB8:  BRA    12E8
00EBA:  XORLW  01
00EBC:  BTFSC  FD8.2
00EBE:  BRA    1316
00EC0:  XORLW  03
00EC2:  BTFSC  FD8.2
00EC4:  BRA    139A
00EC6:  XORLW  0C
00EC8:  BTFSC  FD8.2
00ECA:  BRA    1488
00ECC:  XORLW  0A
00ECE:  BTFSC  FD8.2
00ED0:  BRA    14B2
00ED2:  XORLW  0F
00ED4:  BTFSC  FD8.2
00ED6:  BRA    14FE
00ED8:  XORLW  04
00EDA:  BTFSC  FD8.2
00EDC:  BRA    152C
00EDE:  BRA    157E
....................       { 
....................          case 0x12: 
....................          fprintf (fab, "Start 0x12\r\n") ; 
00EE0:  MOVLW  22
00EE2:  MOVWF  FF6
00EE4:  MOVLW  05
00EE6:  MOVWF  FF7
00EE8:  MOVLW  00
00EEA:  MOVWF  FF8
00EEC:  RCALL  0784
....................          output_low (PIN_A5); 
00EEE:  BCF    F92.5
00EF0:  BCF    F89.5
....................          address_data[0] = command[1]<<24; 
00EF2:  MOVFF  139,181
00EF6:  MOVLB  1
00EF8:  CLRF   x7E
00EFA:  CLRF   x7F
00EFC:  CLRF   x80
....................          address_data[1] = command[2]<<16; 
00EFE:  MOVFF  13A,184
00F02:  CLRF   x82
00F04:  CLRF   x83
00F06:  CLRF   x85
....................          address_data[2] = command[3]<<8; 
00F08:  MOVFF  13B,187
00F0C:  CLRF   x86
00F0E:  CLRF   x88
00F10:  CLRF   x89
....................          address_data[3] = command[4]; 
00F12:  CLRF   x8D
00F14:  CLRF   x8C
00F16:  CLRF   x8B
00F18:  MOVFF  13C,18A
....................          address = address_data[0] + address_data[1] + address_data[2] + address_data[3]; 
00F1C:  MOVF   x82,W
00F1E:  ADDWF  x7E,W
00F20:  MOVLB  2
00F22:  MOVWF  x14
00F24:  MOVLB  1
00F26:  MOVF   x83,W
00F28:  ADDWFC x7F,W
00F2A:  MOVLB  2
00F2C:  MOVWF  x15
00F2E:  MOVLB  1
00F30:  MOVF   x84,W
00F32:  ADDWFC x80,W
00F34:  MOVLB  2
00F36:  MOVWF  x16
00F38:  MOVLB  1
00F3A:  MOVF   x85,W
00F3C:  ADDWFC x81,W
00F3E:  MOVLB  2
00F40:  MOVWF  x17
00F42:  MOVLB  1
00F44:  MOVF   x86,W
00F46:  MOVLB  2
00F48:  ADDWF  x14,F
00F4A:  MOVLB  1
00F4C:  MOVF   x87,W
00F4E:  MOVLB  2
00F50:  ADDWFC x15,F
00F52:  MOVLB  1
00F54:  MOVF   x88,W
00F56:  MOVLB  2
00F58:  ADDWFC x16,F
00F5A:  MOVLB  1
00F5C:  MOVF   x89,W
00F5E:  MOVLB  2
00F60:  ADDWFC x17,F
00F62:  MOVLB  1
00F64:  MOVF   x8A,W
00F66:  MOVLB  2
00F68:  ADDWF  x14,W
00F6A:  MOVLB  1
00F6C:  MOVWF  x96
00F6E:  MOVF   x8B,W
00F70:  MOVLB  2
00F72:  ADDWFC x15,W
00F74:  MOVLB  1
00F76:  MOVWF  x97
00F78:  MOVF   x8C,W
00F7A:  MOVLB  2
00F7C:  ADDWFC x16,W
00F7E:  MOVLB  1
00F80:  MOVWF  x98
00F82:  MOVF   x8D,W
00F84:  MOVLB  2
00F86:  ADDWFC x17,W
00F88:  MOVLB  1
00F8A:  MOVWF  x99
....................          packet_data[0] = command[5]<<8; 
00F8C:  MOVFF  13D,18F
00F90:  CLRF   x8E
00F92:  CLRF   x90
00F94:  CLRF   x91
....................          packet_data[1] = command[6]; 
00F96:  CLRF   x95
00F98:  CLRF   x94
00F9A:  CLRF   x93
00F9C:  MOVFF  13E,192
....................          packet = (packet_data[0] + packet_data[1])*81; 
00FA0:  MOVF   x92,W
00FA2:  ADDWF  x8E,W
00FA4:  MOVLB  2
00FA6:  MOVWF  x14
00FA8:  MOVLB  1
00FAA:  MOVF   x93,W
00FAC:  ADDWFC x8F,W
00FAE:  MOVLB  2
00FB0:  MOVWF  x15
00FB2:  MOVLB  1
00FB4:  MOVF   x94,W
00FB6:  ADDWFC x90,W
00FB8:  MOVLB  2
00FBA:  MOVWF  x16
00FBC:  MOVLB  1
00FBE:  MOVF   x95,W
00FC0:  ADDWFC x91,W
00FC2:  MOVLB  2
00FC4:  MOVWF  x17
00FC6:  MOVWF  x1B
00FC8:  MOVFF  216,21A
00FCC:  MOVFF  215,219
00FD0:  MOVFF  214,218
00FD4:  CLRF   x1F
00FD6:  CLRF   x1E
00FD8:  CLRF   x1D
00FDA:  MOVLW  51
00FDC:  MOVWF  x1C
00FDE:  MOVLB  0
00FE0:  BRA    07F8
00FE2:  MOVFF  03,19D
00FE6:  MOVFF  02,19C
00FEA:  MOVFF  01,19B
00FEE:  MOVFF  00,19A
....................  
....................          //fputc(command[5] + command[6], fab); 
....................          TRANSFER_DATA_NBYTE_TOFAB_SMF(address, packet); 
00FF2:  MOVFF  199,217
00FF6:  MOVFF  198,216
00FFA:  MOVFF  197,215
00FFE:  MOVFF  196,214
01002:  MOVFF  19D,21B
01006:  MOVFF  19C,21A
0100A:  MOVFF  19B,219
0100E:  MOVFF  19A,218
01012:  BRA    091C
....................          //TRANSFER_DATA_NBYTE_TOFAB_SMF(address,81); 
....................           
....................          fprintf (fab, "Finish 0x12\r\n") ; 
01014:  MOVLW  30
01016:  MOVWF  FF6
01018:  MOVLW  05
0101A:  MOVWF  FF7
0101C:  MOVLW  00
0101E:  MOVWF  FF8
01020:  CALL   0784
....................          break; 
01024:  BRA    157E
....................           
....................           
....................          /*case 0x13://Get the data from Flash Memory 2 
....................          fprintf (fab, "Start 0x13\r\n") ; 
....................          output_low (PIN_A5); 
....................          address_data[0] = command[1]<<24; 
....................          address_data[1] = command[2]<<16; 
....................          address_data[2] = command[3]<<8; 
....................          address_data[3] = command[4]; 
....................          address = address_data[0] + address_data[1] + address_data[2] + address_data[3]; 
....................          TRANSFER_DATA_NBYTE_TOFAB_SMF(address, command[5] + command[6]); 
....................          fprintf (fab, "Finish 0x13\r\n") ; 
....................           
....................          break;*/ 
....................           
....................          case 0x14://Uplink command to write the data on Flash Memory 2 
....................          output_low (PIN_A5) ;//Main side 
01026:  BCF    F92.5
01028:  BCF    F89.5
....................          fprintf (fab, "Start 0x14\r\n") ; 
0102A:  MOVLW  3E
0102C:  MOVWF  FF6
0102E:  MOVLW  05
01030:  MOVWF  FF7
01032:  MOVLW  00
01034:  MOVWF  FF8
01036:  CALL   0784
....................          address_data[0] = command[1]<<24; 
0103A:  MOVFF  139,181
0103E:  MOVLB  1
01040:  CLRF   x7E
01042:  CLRF   x7F
01044:  CLRF   x80
....................          address_data[1] = command[2]<<16; 
01046:  MOVFF  13A,184
0104A:  CLRF   x82
0104C:  CLRF   x83
0104E:  CLRF   x85
....................          address_data[2] = command[3]<<8; 
01050:  MOVFF  13B,187
01054:  CLRF   x86
01056:  CLRF   x88
01058:  CLRF   x89
....................          address_data[3] = command[4]; 
0105A:  CLRF   x8D
0105C:  CLRF   x8C
0105E:  CLRF   x8B
01060:  MOVFF  13C,18A
....................          address = address_data[0] + address_data[1] + address_data[2] + address_data[3]; 
01064:  MOVF   x82,W
01066:  ADDWF  x7E,W
01068:  MOVLB  2
0106A:  MOVWF  x14
0106C:  MOVLB  1
0106E:  MOVF   x83,W
01070:  ADDWFC x7F,W
01072:  MOVLB  2
01074:  MOVWF  x15
01076:  MOVLB  1
01078:  MOVF   x84,W
0107A:  ADDWFC x80,W
0107C:  MOVLB  2
0107E:  MOVWF  x16
01080:  MOVLB  1
01082:  MOVF   x85,W
01084:  ADDWFC x81,W
01086:  MOVLB  2
01088:  MOVWF  x17
0108A:  MOVLB  1
0108C:  MOVF   x86,W
0108E:  MOVLB  2
01090:  ADDWF  x14,F
01092:  MOVLB  1
01094:  MOVF   x87,W
01096:  MOVLB  2
01098:  ADDWFC x15,F
0109A:  MOVLB  1
0109C:  MOVF   x88,W
0109E:  MOVLB  2
010A0:  ADDWFC x16,F
010A2:  MOVLB  1
010A4:  MOVF   x89,W
010A6:  MOVLB  2
010A8:  ADDWFC x17,F
010AA:  MOVLB  1
010AC:  MOVF   x8A,W
010AE:  MOVLB  2
010B0:  ADDWF  x14,W
010B2:  MOVLB  1
010B4:  MOVWF  x96
010B6:  MOVF   x8B,W
010B8:  MOVLB  2
010BA:  ADDWFC x15,W
010BC:  MOVLB  1
010BE:  MOVWF  x97
010C0:  MOVF   x8C,W
010C2:  MOVLB  2
010C4:  ADDWFC x16,W
010C6:  MOVLB  1
010C8:  MOVWF  x98
010CA:  MOVF   x8D,W
010CC:  MOVLB  2
010CE:  ADDWFC x17,W
010D0:  MOVLB  1
010D2:  MOVWF  x99
....................          //sector_erase_SMF (address); 
....................          WRITE_DATA_BYTE_SMF (address, command[5]) ; 
010D4:  MOVFF  199,21B
010D8:  MOVFF  198,21A
010DC:  MOVFF  197,219
010E0:  MOVFF  196,218
010E4:  MOVFF  13D,21C
010E8:  MOVLB  0
010EA:  RCALL  09A6
....................          WRITE_DATA_BYTE_SMF (address + 1, command[6]) ; 
010EC:  MOVLW  01
010EE:  MOVLB  1
010F0:  ADDWF  x96,W
010F2:  MOVLB  2
010F4:  MOVWF  x14
010F6:  MOVLW  00
010F8:  MOVLB  1
010FA:  ADDWFC x97,W
010FC:  MOVLB  2
010FE:  MOVWF  x15
01100:  MOVLW  00
01102:  MOVLB  1
01104:  ADDWFC x98,W
01106:  MOVLB  2
01108:  MOVWF  x16
0110A:  MOVLW  00
0110C:  MOVLB  1
0110E:  ADDWFC x99,W
01110:  MOVLB  2
01112:  MOVWF  x17
01114:  MOVWF  x1B
01116:  MOVFF  216,21A
0111A:  MOVFF  215,219
0111E:  MOVFF  214,218
01122:  MOVFF  13E,21C
01126:  MOVLB  0
01128:  RCALL  09A6
....................          WRITE_DATA_BYTE_SMF (address + 2, command[7]) ; 
0112A:  MOVLW  02
0112C:  MOVLB  1
0112E:  ADDWF  x96,W
01130:  MOVLB  2
01132:  MOVWF  x14
01134:  MOVLW  00
01136:  MOVLB  1
01138:  ADDWFC x97,W
0113A:  MOVLB  2
0113C:  MOVWF  x15
0113E:  MOVLW  00
01140:  MOVLB  1
01142:  ADDWFC x98,W
01144:  MOVLB  2
01146:  MOVWF  x16
01148:  MOVLW  00
0114A:  MOVLB  1
0114C:  ADDWFC x99,W
0114E:  MOVLB  2
01150:  MOVWF  x17
01152:  MOVWF  x1B
01154:  MOVFF  216,21A
01158:  MOVFF  215,219
0115C:  MOVFF  214,218
01160:  MOVFF  13F,21C
01164:  MOVLB  0
01166:  RCALL  09A6
....................          WRITE_DATA_BYTE_SMF (address + 3, command[8]) ; 
01168:  MOVLW  03
0116A:  MOVLB  1
0116C:  ADDWF  x96,W
0116E:  MOVLB  2
01170:  MOVWF  x14
01172:  MOVLW  00
01174:  MOVLB  1
01176:  ADDWFC x97,W
01178:  MOVLB  2
0117A:  MOVWF  x15
0117C:  MOVLW  00
0117E:  MOVLB  1
01180:  ADDWFC x98,W
01182:  MOVLB  2
01184:  MOVWF  x16
01186:  MOVLW  00
01188:  MOVLB  1
0118A:  ADDWFC x99,W
0118C:  MOVLB  2
0118E:  MOVWF  x17
01190:  MOVWF  x1B
01192:  MOVFF  216,21A
01196:  MOVFF  215,219
0119A:  MOVFF  214,218
0119E:  MOVFF  140,21C
011A2:  MOVLB  0
011A4:  RCALL  09A6
....................          fprintf (fab, "Finish 0x14\r\n"); 
011A6:  MOVLW  4C
011A8:  MOVWF  FF6
011AA:  MOVLW  05
011AC:  MOVWF  FF7
011AE:  MOVLW  00
011B0:  MOVWF  FF8
011B2:  CALL   0784
....................          break; 
011B6:  BRA    157E
....................           
....................          case 0x16://Erase the data on Flash Memory 2 
....................          output_low (PIN_A5); 
011B8:  BCF    F92.5
011BA:  BCF    F89.5
....................          fprintf(fab, "Start 0x16\r\n"); 
011BC:  MOVLW  5A
011BE:  MOVWF  FF6
011C0:  MOVLW  05
011C2:  MOVWF  FF7
011C4:  MOVLW  00
011C6:  MOVWF  FF8
011C8:  CALL   0784
....................          address_data[0] = command[1]<<24; 
011CC:  MOVFF  139,181
011D0:  MOVLB  1
011D2:  CLRF   x7E
011D4:  CLRF   x7F
011D6:  CLRF   x80
....................          address_data[1] = command[2]<<16; 
011D8:  MOVFF  13A,184
011DC:  CLRF   x82
011DE:  CLRF   x83
011E0:  CLRF   x85
....................          address_data[2] = command[3]<<8; 
011E2:  MOVFF  13B,187
011E6:  CLRF   x86
011E8:  CLRF   x88
011EA:  CLRF   x89
....................          address_data[3] = command[4]; 
011EC:  CLRF   x8D
011EE:  CLRF   x8C
011F0:  CLRF   x8B
011F2:  MOVFF  13C,18A
....................          address = address_data[0] + address_data[1] + address_data[2] + address_data[3]; 
011F6:  MOVF   x82,W
011F8:  ADDWF  x7E,W
011FA:  MOVLB  2
011FC:  MOVWF  x14
011FE:  MOVLB  1
01200:  MOVF   x83,W
01202:  ADDWFC x7F,W
01204:  MOVLB  2
01206:  MOVWF  x15
01208:  MOVLB  1
0120A:  MOVF   x84,W
0120C:  ADDWFC x80,W
0120E:  MOVLB  2
01210:  MOVWF  x16
01212:  MOVLB  1
01214:  MOVF   x85,W
01216:  ADDWFC x81,W
01218:  MOVLB  2
0121A:  MOVWF  x17
0121C:  MOVLB  1
0121E:  MOVF   x86,W
01220:  MOVLB  2
01222:  ADDWF  x14,F
01224:  MOVLB  1
01226:  MOVF   x87,W
01228:  MOVLB  2
0122A:  ADDWFC x15,F
0122C:  MOVLB  1
0122E:  MOVF   x88,W
01230:  MOVLB  2
01232:  ADDWFC x16,F
01234:  MOVLB  1
01236:  MOVF   x89,W
01238:  MOVLB  2
0123A:  ADDWFC x17,F
0123C:  MOVLB  1
0123E:  MOVF   x8A,W
01240:  MOVLB  2
01242:  ADDWF  x14,W
01244:  MOVLB  1
01246:  MOVWF  x96
01248:  MOVF   x8B,W
0124A:  MOVLB  2
0124C:  ADDWFC x15,W
0124E:  MOVLB  1
01250:  MOVWF  x97
01252:  MOVF   x8C,W
01254:  MOVLB  2
01256:  ADDWFC x16,W
01258:  MOVLB  1
0125A:  MOVWF  x98
0125C:  MOVF   x8D,W
0125E:  MOVLB  2
01260:  ADDWFC x17,W
01262:  MOVLB  1
01264:  MOVWF  x99
....................             switch(command[5]){ 
01266:  MOVF   x3D,W
01268:  XORLW  04
0126A:  MOVLB  0
0126C:  BZ    1278
0126E:  XORLW  36
01270:  BZ    129E
01272:  XORLW  CD
01274:  BZ    12C4
01276:  BRA    12E6
....................                case 0x04: 
....................                   SUBSECTOR_4KB_ERASE_SMF(address); 
01278:  MOVFF  199,217
0127C:  MOVFF  198,216
01280:  MOVFF  197,215
01284:  MOVFF  196,214
01288:  GOTO   0A1A
....................                   fprintf(fab, "Finish 0x16\r\n"); 
0128C:  MOVLW  68
0128E:  MOVWF  FF6
01290:  MOVLW  05
01292:  MOVWF  FF7
01294:  MOVLW  00
01296:  MOVWF  FF8
01298:  CALL   0784
....................                   break; 
0129C:  BRA    12E6
....................                case 0x32: 
....................                   SUBSECTOR_32KB_ERASE_SMF(address); 
0129E:  MOVFF  199,217
012A2:  MOVFF  198,216
012A6:  MOVFF  197,215
012AA:  MOVFF  196,214
012AE:  GOTO   0AAC
....................                   fprintf(fab, "Finish 0x16\r\n"); 
012B2:  MOVLW  76
012B4:  MOVWF  FF6
012B6:  MOVLW  05
012B8:  MOVWF  FF7
012BA:  MOVLW  00
012BC:  MOVWF  FF8
012BE:  CALL   0784
....................                   break; 
012C2:  BRA    12E6
....................                case 0xFF: 
....................                   SECTOR_ERASE_SMF(address); 
012C4:  MOVFF  199,217
012C8:  MOVFF  198,216
012CC:  MOVFF  197,215
012D0:  MOVFF  196,214
012D4:  BRA    0B3E
....................                   fprintf(fab, "Finish 0x16\r\n"); 
012D6:  MOVLW  84
012D8:  MOVWF  FF6
012DA:  MOVLW  05
012DC:  MOVWF  FF7
012DE:  MOVLW  00
012E0:  MOVWF  FF8
012E2:  CALL   0784
....................                   break; 
....................             } 
....................             break; 
012E6:  BRA    157E
....................           
....................          /* case 0x91: 
....................          reset_time_data[0] = 0x82; 
....................          //fprintf (PC, "Command 2 Recieved\r\n") ; 
....................          //fputc (reset_time_data[0], PC) ; 
....................          fputc (0x91, reset); 
....................          break; */ 
....................  
....................          case 0x90://Turn off PINO 
....................          fprintf (fab, "Start 0x90\r\n") ; 
012E8:  MOVLW  92
012EA:  MOVWF  FF6
012EC:  MOVLW  05
012EE:  MOVWF  FF7
012F0:  MOVLW  00
012F2:  MOVWF  FF8
012F4:  CALL   0784
....................          output_high (hvs); 
012F8:  BCF    F95.7
012FA:  BSF    F8C.7
....................          fprintf (fab, "Finish 0x90\r\n"); 
012FC:  MOVLW  A0
012FE:  MOVWF  FF6
01300:  MOVLW  05
01302:  MOVWF  FF7
01304:  MOVLW  00
01306:  MOVWF  FF8
01308:  CALL   0784
....................          output_low (PINO_power); 
0130C:  BCF    F95.5
0130E:  BCF    F8C.5
....................          output_low (sel); 
01310:  BCF    F95.6
01312:  BCF    F8C.6
....................          break; 
01314:  BRA    157E
....................           
....................          case 0x91://PINO Real Time Uplink Command 
....................          fprintf (fab, "Start 0x91\r\n"); 
01316:  MOVLW  AE
01318:  MOVWF  FF6
0131A:  MOVLW  05
0131C:  MOVWF  FF7
0131E:  MOVLW  00
01320:  MOVWF  FF8
01322:  CALL   0784
....................          for (i = 0; i < 9; i++) 
01326:  MOVLB  2
01328:  CLRF   x02
0132A:  MOVF   x02,W
0132C:  SUBLW  08
0132E:  BNC   1362
....................          { 
....................             PINO_DATA[i] = command[i]; 
01330:  CLRF   03
01332:  MOVF   x02,W
01334:  ADDLW  4C
01336:  MOVWF  01
01338:  MOVLW  01
0133A:  ADDWFC 03,F
0133C:  MOVFF  03,215
01340:  CLRF   03
01342:  MOVF   x02,W
01344:  ADDLW  38
01346:  MOVWF  FE9
01348:  MOVLW  01
0134A:  ADDWFC 03,W
0134C:  MOVWF  FEA
0134E:  MOVFF  FEF,216
01352:  MOVFF  215,FEA
01356:  MOVFF  01,FE9
0135A:  MOVFF  216,FEF
0135E:  INCF   x02,F
01360:  BRA    132A
....................          } 
....................           
....................          for (i = 0; i<39; i++) 
01362:  CLRF   x02
01364:  MOVF   x02,W
01366:  SUBLW  26
01368:  BNC   1386
....................          { 
....................             fputc (PINO_DATA[i], DC); 
0136A:  CLRF   03
0136C:  MOVF   x02,W
0136E:  ADDLW  4C
01370:  MOVWF  FE9
01372:  MOVLW  01
01374:  ADDWFC 03,W
01376:  MOVWF  FEA
01378:  MOVFF  FEF,21D
0137C:  MOVLB  0
0137E:  RCALL  0BD0
01380:  MOVLB  2
01382:  INCF   x02,F
01384:  BRA    1364
....................          } 
....................          fprintf (fab, "Finish 0x91\r\n") ; 
01386:  MOVLW  BC
01388:  MOVWF  FF6
0138A:  MOVLW  05
0138C:  MOVWF  FF7
0138E:  MOVLW  00
01390:  MOVWF  FF8
01392:  MOVLB  0
01394:  CALL   0784
....................          break; 
01398:  BRA    157E
....................           
....................          case 0x92://PINO Real Time Downlink Command 
....................          fprintf (fab, "Start 0x92\r\n") ; 
0139A:  MOVLW  CA
0139C:  MOVWF  FF6
0139E:  MOVLW  05
013A0:  MOVWF  FF7
013A2:  MOVLW  00
013A4:  MOVWF  FF8
013A6:  CALL   0784
....................          for (i = 0; i < 9; i++) 
013AA:  MOVLB  2
013AC:  CLRF   x02
013AE:  MOVF   x02,W
013B0:  SUBLW  08
013B2:  BNC   13E6
....................          { 
....................             PINO_data[i] = command[i]; 
013B4:  CLRF   03
013B6:  MOVF   x02,W
013B8:  ADDLW  4C
013BA:  MOVWF  01
013BC:  MOVLW  01
013BE:  ADDWFC 03,F
013C0:  MOVFF  03,215
013C4:  CLRF   03
013C6:  MOVF   x02,W
013C8:  ADDLW  38
013CA:  MOVWF  FE9
013CC:  MOVLW  01
013CE:  ADDWFC 03,W
013D0:  MOVWF  FEA
013D2:  MOVFF  FEF,216
013D6:  MOVFF  215,FEA
013DA:  MOVFF  01,FE9
013DE:  MOVFF  216,FEF
013E2:  INCF   x02,F
013E4:  BRA    13AE
....................          } 
....................           
....................          for (i = 0; i<39; i++) 
013E6:  CLRF   x02
013E8:  MOVF   x02,W
013EA:  SUBLW  26
013EC:  BNC   140C
....................          { 
....................             fputc (PINO_DATA[i], DC); 
013EE:  CLRF   03
013F0:  MOVF   x02,W
013F2:  ADDLW  4C
013F4:  MOVWF  FE9
013F6:  MOVLW  01
013F8:  ADDWFC 03,W
013FA:  MOVWF  FEA
013FC:  MOVFF  FEF,21D
01400:  MOVLB  0
01402:  CALL   0BD0
01406:  MOVLB  2
01408:  INCF   x02,F
0140A:  BRA    13E8
....................          } 
....................           
....................          while (1) 
....................          { 
....................             if (kbhit (DC)) 
0140C:  BTFSC  F86.1
0140E:  BRA    1484
....................             { 
....................                for (i = 0; i < 10; i++) 
01410:  CLRF   x02
01412:  MOVF   x02,W
01414:  SUBLW  09
01416:  BNC   1446
....................                { 
....................                   Down[i] = fgetc (DC); 
01418:  CLRF   03
0141A:  MOVF   x02,W
0141C:  ADDLW  A6
0141E:  MOVWF  FE9
01420:  MOVLW  01
01422:  ADDWFC 03,W
01424:  MOVWF  FEA
01426:  MOVFF  FEA,217
0142A:  MOVFF  FE9,216
0142E:  MOVLB  0
01430:  GOTO   0C16
01434:  MOVFF  217,FEA
01438:  MOVFF  216,FE9
0143C:  MOVFF  01,FEF
01440:  MOVLB  2
01442:  INCF   x02,F
01444:  BRA    1412
....................                } 
....................                //fprintf (fab, "Finish transmitting\r\n") ; 
....................                for (i = 0; i < 10; i++) 
01446:  CLRF   x02
01448:  MOVF   x02,W
0144A:  SUBLW  09
0144C:  BNC   146E
....................                { 
....................                   fputc (Down[i], fab); 
0144E:  CLRF   03
01450:  MOVF   x02,W
01452:  ADDLW  A6
01454:  MOVWF  FE9
01456:  MOVLW  01
01458:  ADDWFC 03,W
0145A:  MOVWF  FEA
0145C:  MOVFF  FEF,214
01460:  MOVF   x14,W
01462:  MOVLB  0
01464:  CALL   0910
01468:  MOVLB  2
0146A:  INCF   x02,F
0146C:  BRA    1448
....................                } 
....................                fprintf (fab, "Finish 0x92\r\n") ; 
0146E:  MOVLW  D8
01470:  MOVWF  FF6
01472:  MOVLW  05
01474:  MOVWF  FF7
01476:  MOVLW  00
01478:  MOVWF  FF8
0147A:  MOVLB  0
0147C:  CALL   0784
....................                break; 
01480:  BRA    1488
01482:  MOVLB  2
....................             } 
01484:  BRA    140C
01486:  MOVLB  0
....................          } 
....................           
....................          case 0x9E: //Turn on PINO 
....................          fprintf(fab, "Start 0x93\r\n"); 
01488:  MOVLW  E6
0148A:  MOVWF  FF6
0148C:  MOVLW  05
0148E:  MOVWF  FF7
01490:  MOVLW  00
01492:  MOVWF  FF8
01494:  CALL   0784
....................          output_high (PINO_power); 
01498:  BCF    F95.5
0149A:  BSF    F8C.5
....................          output_high (sel); 
0149C:  BCF    F95.6
0149E:  BSF    F8C.6
....................          fprintf(fab, "Finish 0x93\r\n"); 
014A0:  MOVLW  F4
014A2:  MOVWF  FF6
014A4:  MOVLW  05
014A6:  MOVWF  FF7
014A8:  MOVLW  00
014AA:  MOVWF  FF8
014AC:  CALL   0784
....................  
....................          break; 
014B0:  BRA    157E
....................     
....................          case 0x94: 
....................          fprintf (fab, "Start 0x94\r\n") ; 
014B2:  MOVLW  02
014B4:  MOVWF  FF6
014B6:  MOVLW  06
014B8:  MOVWF  FF7
014BA:  MOVLW  00
014BC:  MOVWF  FF8
014BE:  CALL   0784
....................          for (i = 0; i < 5; i++) 
014C2:  MOVLB  2
014C4:  CLRF   x02
014C6:  MOVF   x02,W
014C8:  SUBLW  04
014CA:  BNC   14EA
....................          { 
....................             GET_RESET_DATA (); 
014CC:  MOVLB  0
014CE:  RCALL  0D1C
....................             delay_ms(5000); 
014D0:  MOVLW  14
014D2:  MOVLB  2
014D4:  MOVWF  x14
014D6:  MOVLW  FA
014D8:  MOVWF  x1D
014DA:  MOVLB  0
014DC:  CALL   07B2
014E0:  MOVLB  2
014E2:  DECFSZ x14,F
014E4:  BRA    14D6
014E6:  INCF   x02,F
014E8:  BRA    14C6
....................          } 
....................          fprintf (fab, "Finish 0x94\r\n") ; 
014EA:  MOVLW  10
014EC:  MOVWF  FF6
014EE:  MOVLW  06
014F0:  MOVWF  FF7
014F2:  MOVLW  00
014F4:  MOVWF  FF8
014F6:  MOVLB  0
014F8:  CALL   0784
....................          break; 
014FC:  BRA    157E
....................           
....................          case 0x9B: 
....................          fprintf (fab, "Start 0x9B\r\n") ; 
014FE:  MOVLW  1E
01500:  MOVWF  FF6
01502:  MOVLW  06
01504:  MOVWF  FF7
01506:  MOVLW  00
01508:  MOVWF  FF8
0150A:  CALL   0784
....................          output_high (hvs); 
0150E:  BCF    F95.7
01510:  BSF    F8C.7
....................          fprintf (fab, "Finish 0x9B\r\n"); 
01512:  MOVLW  2C
01514:  MOVWF  FF6
01516:  MOVLW  06
01518:  MOVWF  FF7
0151A:  MOVLW  00
0151C:  MOVWF  FF8
0151E:  CALL   0784
....................          output_low (PINO_power); 
01522:  BCF    F95.5
01524:  BCF    F8C.5
....................          output_low (sel); 
01526:  BCF    F95.6
01528:  BCF    F8C.6
....................          break; 
0152A:  BRA    157E
....................           
....................          case 0x9F://Time and attitude information 
....................           
....................          int a=0; 
0152C:  MOVLB  2
0152E:  CLRF   x13
....................          fprintf (fab, "Start 0x9F\r\n") ; 
01530:  MOVLW  3A
01532:  MOVWF  FF6
01534:  MOVLW  06
01536:  MOVWF  FF7
01538:  MOVLW  00
0153A:  MOVWF  FF8
0153C:  MOVLB  0
0153E:  CALL   0784
....................           
....................          for(a=0; a<12; a++){ 
01542:  MOVLB  2
01544:  CLRF   x13
01546:  MOVF   x13,W
01548:  SUBLW  0B
0154A:  BNC   156C
....................             GET_RESET_DATA(); 
0154C:  MOVLB  0
0154E:  CALL   0D1C
....................             delay_ms(10000); 
01552:  MOVLW  28
01554:  MOVLB  2
01556:  MOVWF  x14
01558:  MOVLW  FA
0155A:  MOVWF  x1D
0155C:  MOVLB  0
0155E:  CALL   07B2
01562:  MOVLB  2
01564:  DECFSZ x14,F
01566:  BRA    1558
01568:  INCF   x13,F
0156A:  BRA    1546
....................          } 
....................           
....................          /*GET_RESET_DATA (); 
....................          while(a<12){//Do "GET_RESET_DATA()" during 2mins; 
....................             a = a + ten_sec_counter(); 
....................             GET_RESET_DATA (); 
....................          }*/ 
....................          fprintf (fab, "Finish 0x9F\r\n") ; 
0156C:  MOVLW  48
0156E:  MOVWF  FF6
01570:  MOVLW  06
01572:  MOVWF  FF7
01574:  MOVLW  00
01576:  MOVWF  FF8
01578:  MOVLB  0
0157A:  CALL   0784
....................          break; 
....................           
....................  
....................       } 
0157E:  MOVLB  2
01580:  BRA    0E32
....................    } 
01582:  MOVLB  0
01584:  GOTO   1800 (RETURN)
.................... } 
....................  
....................  
....................  
.................... void GET_RESET_DATA()                                                            //funcion que carga el array HKDATA con los datos del Reset PIC 
.................... { 
....................    dummy[0] = 0x11; 
*
00D1C:  MOVLW  11
00D1E:  MOVLB  2
00D20:  MOVWF  x00
....................    Finish_sign[0] = 0xFF; 
00D22:  SETF   x01
....................    RESET_DATA = 0; 
00D24:  MOVLB  0
00D26:  CLRF   xED
....................    int8 dayh; 
....................    int8 dayl; 
....................    int8 hr; 
....................    int8 min; 
....................    int8 sec; 
....................    int8 j; 
....................    for (int i = 0; i < 6; i++) 
00D28:  MOVLB  2
00D2A:  CLRF   x1A
00D2C:  MOVF   x1A,W
00D2E:  SUBLW  05
00D30:  BNC   0D48
....................    { 
....................       COLLECT_RESET_DATA (); 
00D32:  MOVLB  0
00D34:  BRA    0CD4
....................       if (reset_bffr[0] == 0x8e) 
00D36:  MOVF   xEE,W
00D38:  SUBLW  8E
00D3A:  BNZ   0D42
....................       { 
....................          break; 
00D3C:  MOVLB  2
00D3E:  BRA    0D48
00D40:  MOVLB  0
....................       } 
00D42:  MOVLB  2
00D44:  INCF   x1A,F
00D46:  BRA    0D2C
....................    } 
....................    if (RESET_bffr[0] == 0x8e) 
00D48:  MOVLB  0
00D4A:  MOVF   xEE,W
00D4C:  SUBLW  8E
00D4E:  BNZ   0E18
....................    { 
....................       // fprintf (PC, "\r\nRESET DATA OBTAINED\r\n") ; 
....................       for (int num = 0; num < 5; num++)   //carga el array HKDATA con timedata en las posiciones 2 al 6 
00D50:  MOVLB  2
00D52:  CLRF   x1B
00D54:  MOVF   x1B,W
00D56:  SUBLW  04
00D58:  BNC   0D8E
....................       { 
....................          reset_time_data[num] = reset_bffr[num + 1]; 
00D5A:  CLRF   03
00D5C:  MOVF   x1B,W
00D5E:  ADDLW  41
00D60:  MOVWF  01
00D62:  MOVLW  01
00D64:  ADDWFC 03,F
00D66:  MOVFF  03,21D
00D6A:  MOVLW  01
00D6C:  ADDWF  x1B,W
00D6E:  CLRF   03
00D70:  ADDLW  EE
00D72:  MOVWF  FE9
00D74:  MOVLW  00
00D76:  ADDWFC 03,W
00D78:  MOVWF  FEA
00D7A:  MOVFF  FEF,21E
00D7E:  MOVFF  21D,FEA
00D82:  MOVFF  01,FE9
00D86:  MOVFF  21E,FEF
00D8A:  INCF   x1B,F
00D8C:  BRA    0D54
....................          //fputc (reset_bffr[num + 1], DC); 
....................          //fprintf (PC, " % x, ", reset_bffr[num + 1]) ; 
....................       } 
....................       //fputc (dummy[0], DC); 
....................       sec = reset_time_data[0]; 
00D8E:  MOVFF  141,218
....................       min = reset_time_data[1]; 
00D92:  MOVFF  142,217
....................       hr = reset_time_data[2]; 
00D96:  MOVFF  143,216
....................       dayl = reset_time_data[3]; 
00D9A:  MOVFF  144,215
....................       dayh = reset_time_data[4]; 
00D9E:  MOVFF  145,214
....................       fprintf (fab, "\r\n") ; 
00DA2:  MOVLW  0D
00DA4:  BTFSS  FA6.4
00DA6:  BRA    0DA4
00DA8:  MOVLB  F
00DAA:  MOVWF  x29
00DAC:  MOVLW  0A
00DAE:  BTFSS  FA6.4
00DB0:  BRA    0DAE
00DB2:  MOVWF  x29
....................        
....................       PINO_DATA[0] = 0x81; 
00DB4:  MOVLW  81
00DB6:  MOVLB  1
00DB8:  MOVWF  x4C
....................        
....................       PINO_DATA[1] = reset_time_data[0]; 
00DBA:  MOVFF  141,14D
....................       PINO_DATA[2] = reset_time_data[1]; 
00DBE:  MOVFF  142,14E
....................       PINO_DATA[3] = reset_time_data[2]; 
00DC2:  MOVFF  143,14F
....................       PINO_DATA[4] = reset_time_data[3]; 
00DC6:  MOVFF  144,150
....................       PINO_DATA[5] = reset_time_data[4]; 
00DCA:  MOVFF  145,151
....................        
....................       for(i=6; i<39; i++) 
00DCE:  MOVLW  06
00DD0:  MOVLB  2
00DD2:  MOVWF  x1A
00DD4:  MOVF   x1A,W
00DD6:  SUBLW  26
00DD8:  BNC   0DF0
....................       { 
....................          PINO_DATA[i] = 0x01; 
00DDA:  CLRF   03
00DDC:  MOVF   x1A,W
00DDE:  ADDLW  4C
00DE0:  MOVWF  FE9
00DE2:  MOVLW  01
00DE4:  ADDWFC 03,W
00DE6:  MOVWF  FEA
00DE8:  MOVLW  01
00DEA:  MOVWF  FEF
00DEC:  INCF   x1A,F
00DEE:  BRA    0DD4
....................  
....................       } 
....................  
....................       for (j = 0; j < 39; j++) 
00DF0:  CLRF   x19
00DF2:  MOVF   x19,W
00DF4:  SUBLW  26
00DF6:  BNC   0E14
....................       { 
....................          //fprintf (fab, " % x, ", PINO_DATA[j]) ; 
....................           
....................          fputc (PINO_DATA[j], DC); 
00DF8:  CLRF   03
00DFA:  MOVF   x19,W
00DFC:  ADDLW  4C
00DFE:  MOVWF  FE9
00E00:  MOVLW  01
00E02:  ADDWFC 03,W
00E04:  MOVWF  FEA
00E06:  MOVFF  FEF,21D
00E0A:  MOVLB  0
00E0C:  RCALL  0BD0
00E0E:  MOVLB  2
00E10:  INCF   x19,F
00E12:  BRA    0DF2
....................       } 
....................       //fputc (Finish_sign[0], DC); 
....................        
....................       //fprintf (fab, "\r\n") ; 
....................        
....................       }else{ 
00E14:  BRA    0E28
00E16:  MOVLB  0
....................       fprintf (fab, "\r\nRESET DATA NOT OBTAINED\r\n") ; 
00E18:  MOVLW  56
00E1A:  MOVWF  FF6
00E1C:  MOVLW  06
00E1E:  MOVWF  FF7
00E20:  MOVLW  00
00E22:  MOVWF  FF8
00E24:  RCALL  0784
00E26:  MOVLB  2
....................    } 
....................    return; 
00E28:  MOVLB  0
00E2A:  RETURN 0
.................... } 
....................  
....................  
.................... #include<SATELLITE_LOG.c> 
.................... void waiting(int32 counterval)                                                   //about 200000 : 1s 
.................... { 
....................    for(int32 num = 0; num < counterval; num++) 
*
00C94:  MOVLB  2
00C96:  CLRF   x24
00C98:  CLRF   x23
00C9A:  CLRF   x22
00C9C:  CLRF   x21
00C9E:  MOVF   x24,W
00CA0:  SUBWF  x20,W
00CA2:  BNC   0CCE
00CA4:  BNZ   0CBC
00CA6:  MOVF   x23,W
00CA8:  SUBWF  x1F,W
00CAA:  BNC   0CCE
00CAC:  BNZ   0CBC
00CAE:  MOVF   x22,W
00CB0:  SUBWF  x1E,W
00CB2:  BNC   0CCE
00CB4:  BNZ   0CBC
00CB6:  MOVF   x1D,W
00CB8:  SUBWF  x21,W
00CBA:  BC    0CCE
....................    {} 
00CBC:  MOVLW  01
00CBE:  ADDWF  x21,F
00CC0:  BTFSC  FD8.0
00CC2:  INCF   x22,F
00CC4:  BTFSC  FD8.2
00CC6:  INCF   x23,F
00CC8:  BTFSC  FD8.2
00CCA:  INCF   x24,F
00CCC:  BRA    0C9E
....................    return; 
00CCE:  MOVLB  0
00CD0:  GOTO   0D04 (RETURN)
.................... } 
....................  
.................... //--------RESET Function--------------------------------------------- 
....................  
....................  
.................... void DELETE_RESET()                                                              //funcion que pone a cero el vector reset_bffr[] 
.................... { 
....................    for(int8 num = 0; num < Reset_size; num++) 
*
00C62:  MOVLB  2
00C64:  CLRF   x1D
00C66:  MOVF   x1D,W
00C68:  SUBLW  0A
00C6A:  BNC   0C80
....................    { 
....................       reset_bffr[num] = 0; 
00C6C:  CLRF   03
00C6E:  MOVF   x1D,W
00C70:  ADDLW  EE
00C72:  MOVWF  FE9
00C74:  MOVLW  00
00C76:  ADDWFC 03,W
00C78:  MOVWF  FEA
00C7A:  CLRF   FEF
00C7C:  INCF   x1D,F
00C7E:  BRA    0C66
....................    } 
....................    return; 
00C80:  MOVLB  0
00C82:  GOTO   0CD6 (RETURN)
.................... } 
....................  
.................... void SEND_CMD_FOR_RESET_SATELLITE() 
.................... {   
....................    STORE_FLAG_INFO();                                                            //save flag data to flash memory 
....................    //Save_RSV();                                                                   //save in flash memory reserve_table[] content 
....................    STORE_ADRESS_DATA_TO_FLASH(); 
.................... // while(true) 
.................... // { 
....................       //fputc(0x27,PC); 
....................       fprintf(PC,"%x,",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-122));                   //sec 
....................       fprintf(PC,"%x,",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-121));                   //min 
....................       fprintf(PC,"%x,",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-120));                   //hou 
....................       fprintf(PC,"%x",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-119));                    //day H 
....................       fprintf(PC,"%x\r\n",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-118));                //day L 
....................         for(int i = 0; i<100; i++) 
....................         { 
....................          fputc(0x27,reset);                                                      //send command for satellite reset 
....................          delay_ms(10); 
....................         } 
....................       //delay_ms(100);//if it is needed 
.................... //!      fputc(READ_DATA_BYTE_OF(FAB_HK_ADDRESS-122),reset); 
.................... //!      fputc(READ_DATA_BYTE_OF(FAB_HK_ADDRESS-121),reset); 
.................... //!      fputc(READ_DATA_BYTE_OF(FAB_HK_ADDRESS-120),reset); 
.................... //!      fputc(READ_DATA_BYTE_OF(FAB_HK_ADDRESS-119),reset); 
.................... //!      fputc(READ_DATA_BYTE_OF(FAB_HK_ADDRESS-118),reset); 
....................       RESET_DATA = 0; 
....................       fprintf(PC,"Ready for reset"); 
....................       delay_ms(1000); 
.................... // } 
....................    return; 
.................... } 
....................  
.................... void RESET_SATELLITE()                                                           //if get reset command from reset, prepare for resetting 
.................... { 
....................    if(reset_flag == 1)                                                           //get ready for reset satellite 
....................    { 
....................       SEND_CMD_FOR_RESET_SATELLITE();                                            //store flag, save RSV, store Address, send command and wait for reset 
....................    } 
....................    DELETE_RESET();                                                               //load zero in reset_bffr[] 
....................    RESET_DATA = 0; 
....................    return; 
.................... } 
....................  
.................... void COLLECT_RESET_DATA()                                                        //funcion que envia el comando 0x28 al reset PIC y carga reset_bffr[] 
.................... { 
....................    DELETE_RESET();                                                               //pone a cero todas las posiciones del vector 
*
00CD4:  BRA    0C62
....................    RESET_DATA = 0; 
00CD6:  CLRF   xED
....................    for(int m=0; m<10; m++) 
00CD8:  MOVLB  2
00CDA:  CLRF   x1C
00CDC:  MOVF   x1C,W
00CDE:  SUBLW  09
00CE0:  BNC   0D16
....................    { 
....................       fputc(0x28,reset);                                                            //Envia el comando 0x28 en el puerto del reset PIC 
00CE2:  MOVLW  28
00CE4:  MOVLB  0
00CE6:  BRA    0C86
....................       delay_ms(10); 
00CE8:  MOVLW  0A
00CEA:  MOVLB  2
00CEC:  MOVWF  x1D
00CEE:  MOVLB  0
00CF0:  RCALL  07B2
....................       waiting(10000);                                                               //wait aprox 0.5s para que el RESET PIC envie los datos por el UART (interrupcion) 
00CF2:  MOVLB  2
00CF4:  CLRF   x20
00CF6:  CLRF   x1F
00CF8:  MOVLW  27
00CFA:  MOVWF  x1E
00CFC:  MOVLW  10
00CFE:  MOVWF  x1D
00D00:  MOVLB  0
00D02:  BRA    0C94
....................          if(RESET_bffr[0] == 0x8e) 
00D04:  MOVF   xEE,W
00D06:  SUBLW  8E
00D08:  BNZ   0D10
....................          { 
....................          break; 
00D0A:  MOVLB  2
00D0C:  BRA    0D16
00D0E:  MOVLB  0
....................          } 
00D10:  MOVLB  2
00D12:  INCF   x1C,F
00D14:  BRA    0CDC
....................    } 
....................    return; 
00D16:  MOVLB  0
00D18:  GOTO   0D36 (RETURN)
.................... } 
....................  
....................  
.................... //@@@@@@@@@@@for satellite log@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... #define logdata_size 11 
.................... int8 satellitelog[logdata_size] = {}; 
....................  
.................... void SAVE_SAT_LOG(int8 data1, int8 data2, int8 data3) 
.................... { 
....................    LOOP_SAT_LOG();                                                               //hace un loop en las posiciones de memoria para almacenar SAT_LOG 
....................    RESET_DATA = 0; 
....................    COLLECT_RESET_DATA();                                                         //carga el RESET_bffr[] con los datos del reset PIC 
....................    if(RESET_bffr[0] == 0x8e) 
....................    { 
....................       satellitelog[0] = 0xda;                                                    //header of the satellite log 
....................       satellitelog[1] = 0xda;                                                    //header of the satellite log 
....................     
....................       satellitelog[2] = RESET_bffr[1]; 
....................       satellitelog[3] = RESET_bffr[2]; 
....................       satellitelog[4] = RESET_bffr[3]; 
....................       satellitelog[5] = RESET_bffr[4]; 
....................       satellitelog[6] = RESET_bffr[5]; 
....................        
....................       satellitelog[7] = data1; 
....................       satellitelog[8] = data2; 
....................       satellitelog[9] = data3; 
....................       satellitelog[10] = 0xef;                                                   //footer, fin del array 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX main side 
....................       output_low(PIN_C4);                                                        //COM_MUX main side 
....................       for(int i = 0; i < logdata_size; i++)                                      //guarda el dato en las tres Flash en la posicion de memoria indicada por SAT_LOG  
....................       { 
....................          WRITE_DATA_BYTE_OF(SAT_LOG + i,satellitelog[i]); 
....................          WRITE_DATA_BYTE_SCF(SAT_LOG + i,satellitelog[i]); 
....................          WRITE_DATA_BYTE_SMF(SAT_LOG + i,satellitelog[i]); 
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COM side 
....................       SAT_LOG = SAT_LOG + logdata_size; 
....................       fprintf(PC,"LOG saving done\r\n"); 
....................    } 
....................     
....................    return; 
.................... } 
....................  
....................  
....................  
....................  
.................... //----------Flash_memory_MT25QL01GBBB_OF.c------------------------------------- 
....................  
.................... void WRITE_ENABLE_OF(); 
.................... void WRITE_ENABLE_SCF(); 
.................... void WRITE_ENABLE_SMF(); 
....................  
.................... void sector_erase_OF(unsigned int32 sector_address); 
.................... void sector_erase_SCF(unsigned int32 sector_address); 
.................... void sector_erase_SMF(unsigned int32 sector_address); 
....................  
.................... void SUBSECTOR_4KB_ERASE_OF(unsigned int32 sector_address); 
.................... void SUBSECTOR_4KB_ERASE_SCF(unsigned int32 sector_address); 
.................... void SUBSECTOR_4KB_ERASE_SMF(unsigned int32 sector_address); 
....................  
.................... void SUBSECTOR_32KB_ERASE_OF(unsigned int32 sector_address); 
.................... void SUBSECTOR_32KB_ERASE_SCF(unsigned int32 sector_address); 
.................... void SUBSECTOR_32KB_ERASE_SMF(unsigned int32 sector_address); 
....................  
.................... void WRITE_DATA_BYTE_OF(unsigned int32 page_address, int8 data); 
.................... void WRITE_DATA_BYTE_SCF(unsigned int32 page_address, int8 data); 
.................... void WRITE_DATA_BYTE_SMF(unsigned int32 page_address, int8 data); 
....................  
.................... int8 READ_CHIP_ID_OF(); 
.................... int8 READ_CHIP_ID_SCF(); 
.................... int8 READ_CHIP_ID_SMF(); 
....................  
.................... int8 READ_STATUS_REGISTER_OF(); 
.................... int8 READ_STATUS_REGISTER_SCF(); 
.................... int8 READ_STATUS_REGISTER_SMF(); 
....................  
.................... int8 READ_DATA_BYTE_OF(unsigned INT32 ADDRESS); 
.................... int8 READ_DATA_BYTE_SCF(unsigned INT32 ADDRESS); 
.................... int8 READ_DATA_BYTE_SMF(unsigned INT32 ADDRESS); 
....................  
.................... void TRANSFER_DATA_256byte_OF(unsigned INT32 ADRESS, int PORT_NUM); 
.................... void TRANSFER_DATA_256byte_SCF(unsigned INT32 ADRESS, int PORT_NUM); 
.................... void TRANSFER_DATA_256byte_SMF(unsigned INT32 ADRESS, int PORT_NUM); 
....................  
.................... void WRITE_DATA_NBYTE_OF(unsigned INT32 ADDRES,int32 data_byte); 
.................... void WRITE_DATA_NBYTE_SCF(unsigned INT32 ADDRES,int32 data_byte); 
.................... void WRITE_DATA_NBYTE_SMF(unsigned INT32 ADDRES,int32 data_byte); 
....................  
.................... void TRANSFER_DATA_NBYTE_TOPC_OF(unsigned INT32 ADRESS,int32 data_byte); //for testing 
.................... void TRANSFER_DATA_NBYTE_TOPC_SCF(unsigned INT32 ADRESS,int32 data_byte); //for testing 
.................... void TRANSFER_DATA_NBYTE_TOPC_SMF(unsigned INT32 ADRESS,int32 data_byte); //for testing 
....................  
.................... void TRANSFER_DATA_NBYTE_OFtoSCF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //transfer data from MAIN FLASH to COM FLASH 
.................... void TRANSFER_DATA_NBYTE_SCFtoOF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //transfer data from COM FLASH to MAIN FLASH 
.................... void TRANSFER_DATA_NBYTE_OFtoSMF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //transfer data from MAIN FLASH to MISSION FLASH 
.................... void TRANSFER_DATA_NBYTE_SMFtoOF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //transfer data from MISSION FLASH to MAIN FLASH 
.................... void TRANSFER_DATA_NBYTE_SMFtoSCF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //transfer data from MISSION FLASH to COM FLASH 
.................... void TRANSFER_DATA_NBYTE_SCFtoSMF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //transfer data from COM FLASH to MISSION FLASH 
....................  
.................... void TRANSFER_DATA_NBYTE_OF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //for testing 
....................  
.................... //void sector_erase(unsigned int32 sector_address);  //this is for sector erase 
....................  
....................  
.................... //----------------------------------------------------------------------------- 
....................  
....................  
....................  
....................  
.................... #INT_rda4                                                                        //Reset PIC Interrupt, RS232 receive data available in buffer 4 
.................... void UART4_RXD(void) 
.................... { 
....................    reset_bffr[RESET_DATA] = fgetc(reset);                                        //loads the reset_bffr array with the data sent by the Reset PIC (carga el array reset_bffr con los datos enviados por el Reset PIC) 
*
006DE:  CLRF   03
006E0:  MOVF   xED,W
006E2:  ADDLW  EE
006E4:  MOVWF  FE9
006E6:  MOVLW  00
006E8:  ADDWFC 03,W
006EA:  MOVWF  FEA
006EC:  MOVFF  FEA,231
006F0:  MOVFF  FE9,230
006F4:  BRA    0694
006F6:  MOVFF  231,FEA
006FA:  MOVFF  230,FE9
006FE:  MOVFF  01,FEF
....................    RESET_DATA = ((RESET_DATA + 1) % RESET_size);                                 //when the data is obtained in position 11 RESET_DATA = 0 (cuando se obtenga el dato en la posicion 11 RESET_DATA=0) 
00702:  MOVLW  01
00704:  ADDWF  xED,W
00706:  MOVLB  2
00708:  MOVWF  x2F
0070A:  MOVWF  x30
0070C:  MOVLW  0B
0070E:  MOVWF  x31
00710:  MOVLB  0
00712:  BRA    06B0
00714:  MOVFF  00,ED
....................    if(reset_bffr[0] == 0xaa)                                                     //get ready for reset satellite 
00718:  MOVF   xEE,W
0071A:  SUBLW  AA
0071C:  BNZ   0724
....................    { 
....................       reset_flag = 1;                                                            //raise flag to reset (pone a alto bandera para reseteo) 
0071E:  MOVLW  01
00720:  MOVWF  xF9
....................       RESET_DATA = 0;                                                            //position indicator within reset_data vector (indicador de posicion dentro del vector reset_data) 
00722:  CLRF   xED
....................    } 
....................     
00724:  BCF    FA6.7
00726:  GOTO   0078
.................... }  
....................  
.................... void main() 
*
01588:  CLRF   FF8
0158A:  BCF    FA9.7
0158C:  BSF    FD0.7
0158E:  BSF    07.7
01590:  MOVLB  E
01592:  MOVLW  55
01594:  MOVWF  F7E
01596:  MOVLW  AA
01598:  MOVWF  F7E
0159A:  BCF    F66.6
0159C:  MOVLW  F4
0159E:  MOVWF  x2A
015A0:  MOVLW  F5
015A2:  MOVWF  x2B
015A4:  MOVLW  F8
015A6:  MOVWF  x2C
015A8:  MOVLW  F9
015AA:  MOVWF  x2D
015AC:  MOVLW  01
015AE:  MOVWF  x1B
015B0:  MOVLW  20
015B2:  MOVWF  x1D
015B4:  MOVLW  30
015B6:  MOVWF  x22
015B8:  MOVLW  20
015BA:  MOVWF  x24
015BC:  MOVLW  55
015BE:  MOVWF  F7E
015C0:  MOVLW  AA
015C2:  MOVWF  F7E
015C4:  BSF    F66.6
015C6:  CLRF   F9B
015C8:  CLRF   F64
015CA:  CLRF   F65
015CC:  CLRF   F66
015CE:  MOVLW  02
015D0:  MOVWF  FD3
015D2:  BSF    F67.3
015D4:  MOVLW  22
015D6:  MOVWF  FAF
015D8:  MOVLW  00
015DA:  MOVLB  F
015DC:  MOVWF  x30
015DE:  MOVLW  A6
015E0:  MOVWF  FAC
015E2:  MOVLW  90
015E4:  MOVWF  FAB
015E6:  CLRF   1B
015E8:  BSF    x31.3
015EA:  MOVLW  A0
015EC:  MOVWF  x1F
015EE:  MOVLW  01
015F0:  MOVWF  x20
015F2:  MOVLW  A6
015F4:  MOVWF  x32
015F6:  MOVLW  90
015F8:  MOVWF  x33
015FA:  MOVLB  E
015FC:  BSF    xFD.3
015FE:  MOVLW  A0
01600:  MOVWF  xFB
01602:  MOVLW  01
01604:  MOVWF  xFC
01606:  MOVLW  A6
01608:  MOVWF  xFE
0160A:  MOVLW  90
0160C:  MOVWF  xFF
0160E:  MOVLB  F
01610:  BSF    x2D.3
01612:  MOVLW  A0
01614:  MOVWF  x2B
01616:  MOVLW  01
01618:  MOVWF  x2C
0161A:  MOVLW  A6
0161C:  MOVWF  x2E
0161E:  MOVLW  90
01620:  MOVWF  x2F
01622:  BCF    F98.2
01624:  BSF    F8F.2
01626:  BCF    F98.0
01628:  BSF    F8F.0
0162A:  BSF    F96.0
0162C:  BCF    F96.6
0162E:  BCF    F96.1
01630:  BCF    F8D.1
01632:  BSF    F93.5
01634:  BCF    F93.4
01636:  BCF    F93.2
01638:  BCF    F8A.2
0163A:  BSF    F92.0
0163C:  BCF    F92.1
0163E:  BCF    F92.3
01640:  BCF    F89.3
01642:  CLRF   1F
01644:  CLRF   1E
01646:  MOVLW  10
01648:  MOVWF  1D
0164A:  CLRF   1C
0164C:  CLRF   23
0164E:  CLRF   22
01650:  CLRF   21
01652:  CLRF   20
01654:  CLRF   27
01656:  MOVLW  04
01658:  MOVWF  26
0165A:  CLRF   25
0165C:  CLRF   24
0165E:  CLRF   2B
01660:  MOVLW  05
01662:  MOVWF  2A
01664:  CLRF   29
01666:  CLRF   28
01668:  CLRF   2F
0166A:  MOVLW  06
0166C:  MOVWF  2E
0166E:  CLRF   2D
01670:  CLRF   2C
01672:  CLRF   33
01674:  MOVLW  08
01676:  MOVWF  32
01678:  CLRF   31
0167A:  CLRF   30
0167C:  CLRF   37
0167E:  MOVLW  62
01680:  MOVWF  36
01682:  CLRF   35
01684:  CLRF   34
01686:  MOVLW  04
01688:  MOVWF  3B
0168A:  MOVLW  4A
0168C:  MOVWF  3A
0168E:  CLRF   39
01690:  CLRF   38
01692:  MOVLW  04
01694:  MOVWF  3F
01696:  MOVLW  72
01698:  MOVWF  3E
0169A:  CLRF   3D
0169C:  CLRF   3C
0169E:  MOVLW  06
016A0:  MOVWF  43
016A2:  MOVLW  65
016A4:  MOVWF  42
016A6:  CLRF   41
016A8:  CLRF   40
016AA:  MOVLW  06
016AC:  MOVWF  47
016AE:  MOVLW  66
016B0:  MOVWF  46
016B2:  CLRF   45
016B4:  CLRF   44
016B6:  MOVLW  06
016B8:  MOVWF  4B
016BA:  MOVLW  67
016BC:  MOVWF  4A
016BE:  CLRF   49
016C0:  CLRF   48
016C2:  CLRF   4F
016C4:  MOVLW  01
016C6:  MOVWF  4E
016C8:  MOVLW  80
016CA:  MOVWF  4D
016CC:  CLRF   4C
016CE:  CLRF   53
016D0:  MOVLW  01
016D2:  MOVWF  52
016D4:  MOVLW  80
016D6:  MOVWF  51
016D8:  MOVLW  1C
016DA:  MOVWF  50
016DC:  CLRF   54
016DE:  CLRF   56
016E0:  CLRF   55
016E2:  CLRF   57
016E4:  CLRF   58
016E6:  CLRF   59
016E8:  CLRF   5A
016EA:  CLRF   5B
016EC:  CLRF   5C
016EE:  CLRF   5D
016F0:  CLRF   5E
016F2:  CLRF   5F
016F4:  MOVLB  0
016F6:  CLRF   x60
016F8:  CLRF   x61
016FA:  CLRF   x62
016FC:  CLRF   x63
016FE:  CLRF   x64
01700:  CLRF   x65
01702:  CLRF   x66
01704:  CLRF   x67
01706:  CLRF   x68
01708:  CLRF   x69
0170A:  CLRF   x82
0170C:  CLRF   x83
0170E:  CLRF   x84
01710:  CLRF   x85
01712:  CLRF   x86
01714:  CLRF   xEB
01716:  CLRF   xEC
01718:  CLRF   xED
0171A:  CLRF   xF9
0171C:  MOVLB  1
0171E:  CLRF   x34
01720:  CLRF   x33
01722:  CLRF   x35
01724:  CLRF   x37
01726:  CLRF   x36
01728:  MOVLB  E
0172A:  CLRF   xD9
0172C:  CLRF   xDA
0172E:  CLRF   x45
01730:  CLRF   x46
01732:  CLRF   x47
01734:  BCF    x8D.7
01736:  BCF    x8D.6
01738:  BCF    x8D.5
0173A:  MOVLB  1
0173C:  CLRF   x88
0173E:  MOVLB  F
01740:  CLRF   x53
01742:  CLRF   x38
01744:  CLRF   x37
01746:  BRA    1762
01748:  DATA 18,40
0174A:  DATA 6A,00
0174C:  DATA 64,40
0174E:  DATA 87,00
01750:  DATA 0B,40
01752:  DATA EE,00
01754:  DATA 39,40
01756:  DATA FA,00
01758:  DATA 3D,41
0175A:  DATA 41,00
0175C:  DATA 0B,42
0175E:  DATA 03,00
01760:  DATA 00,00
01762:  MOVLW  00
01764:  MOVWF  FF8
01766:  MOVLW  17
01768:  MOVWF  FF7
0176A:  MOVLW  48
0176C:  MOVWF  FF6
0176E:  TBLRD*+
01770:  MOVF   FF5,W
01772:  MOVWF  00
01774:  XORLW  00
01776:  BZ    179E
01778:  TBLRD*+
0177A:  MOVF   FF5,W
0177C:  MOVWF  01
0177E:  BTFSC  FE8.7
01780:  BRA    178C
01782:  ANDLW  0F
01784:  MOVWF  FEA
01786:  TBLRD*+
01788:  MOVFF  FF5,FE9
0178C:  BTFSC  01.6
0178E:  TBLRD*+
01790:  BTFSS  01.6
01792:  TBLRD*+
01794:  MOVFF  FF5,FEE
01798:  DCFSNZ 00,F
0179A:  BRA    176E
0179C:  BRA    1790
0179E:  CLRF   FF8
.................... { 
....................    //settings(); 
....................    set_tris_b(0b11010000); 
017A0:  MOVLW  D0
017A2:  MOVWF  F93
....................    enable_interrupts(global); 
017A4:  MOVLW  C0
017A6:  IORWF  FF2,F
....................    enable_interrupts(INT_rda4); 
017A8:  BSF    F61.7
....................    fprintf(PC,"Start Operating\r\n"); 
017AA:  MOVLW  2A
017AC:  MOVWF  FF6
017AE:  MOVLW  07
017B0:  MOVWF  FF7
017B2:  MOVLW  00
017B4:  MOVWF  FF8
017B6:  MOVLB  0
017B8:  GOTO   0758
....................    output_high(PIN_A5);  //MUX MISSION SIDE 
017BC:  BCF    F92.5
017BE:  BSF    F89.5
....................    //output_low(PIN_A5); //MUX MAIN SIDE 
....................    output_high(sel); 
017C0:  BCF    F95.6
017C2:  BSF    F8C.6
....................    while(TRUE) 
....................    { 
....................       fprintf(fab,"\r\nHello World\r\n"); 
017C4:  MOVLW  3C
017C6:  MOVWF  FF6
017C8:  MOVLW  07
017CA:  MOVWF  FF7
017CC:  MOVLW  00
017CE:  MOVWF  FF8
017D0:  CALL   0784
....................       fprintf(fab,"Operating\r\n"); 
017D4:  MOVLW  4C
017D6:  MOVWF  FF6
017D8:  MOVLW  07
017DA:  MOVWF  FF7
017DC:  MOVLW  00
017DE:  MOVWF  FF8
017E0:  CALL   0784
....................       delay_ms(2500); 
017E4:  MOVLW  0A
017E6:  MOVLB  2
017E8:  MOVWF  x0E
017EA:  MOVLW  FA
017EC:  MOVWF  x1D
017EE:  MOVLB  0
017F0:  CALL   07B2
017F4:  MOVLB  2
017F6:  DECFSZ x0E,F
017F8:  BRA    17EA
....................       PINO_Test(); 
017FA:  MOVLB  0
017FC:  GOTO   0E2C
01800:  BRA    17C4
....................    } 
....................  
.................... } 
01802:  SLEEP 

Configuration Fuses:
   Word  1: F6A0   STVREN NOXINST NODEBUG NOBROWNOUT BORV18 NOPROTECT
   Word  2: FFA2   PR SOSC_DIG CLOCKOUT IESO NOPLL
   Word  3: F032   HS
   Word  4: F7FF   WPFP WPDIS WPEND NOWPCFG
   Word  5: FF03   T5G_IS_T5G CINA_DEFAULT IOL1WAY LS48MHZ MSSP2MSK7 MSSPMSK7
   Word  6: FCFF   WDTWIN_25% WDTCLK_FRC WDT32768 NOWDT WINDIS WPRES128
   Word  7: F01D   NOVREGSLEEP VBATBOR DSBOR DS_SW
   Word  8: F3F8   DSWDT_25DAYS DSWDT DSWDTOSC_INT
