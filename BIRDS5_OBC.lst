CCS PCH C Compiler, Version 5.050, 5967               30-Jun-21 17:16

               Filename:   C:\Users\keena\Dropbox\BIRDS5_Project\BIRDS5_OBC.lst

               ROM used:   5650 bytes (4%)
                           Largest free fragment is 65520
               RAM used:   515 (14%) at main() level
                           551 (15%) worst case
               Stack used: 0 locations
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   1398
*
00008:  NOP   
0000A:  NOP   
0000C:  NOP   
0000E:  NOP   
00010:  NOP   
00012:  NOP   
00014:  NOP   
00016:  NOP   
00018:  MOVWF  04
0001A:  MOVFF  FD8,05
0001E:  MOVFF  FE0,06
00022:  MOVLB  0
00024:  MOVFF  FE9,0C
00028:  MOVFF  FEA,07
0002C:  MOVFF  FE1,08
00030:  MOVFF  FE2,09
00034:  MOVFF  FD9,0A
00038:  MOVFF  FDA,0B
0003C:  MOVFF  FF3,12
00040:  MOVFF  FF4,13
00044:  MOVFF  FFA,14
00048:  MOVFF  FF5,15
0004C:  MOVFF  FF6,16
00050:  MOVFF  FF7,17
00054:  MOVFF  FF8,18
00058:  MOVFF  FFB,19
0005C:  MOVFF  00,0E
00060:  MOVFF  01,0F
00064:  MOVFF  02,10
00068:  MOVFF  03,11
0006C:  BTFSS  F61.7
0006E:  GOTO   0078
00072:  BTFSC  FA6.7
00074:  GOTO   068A
00078:  MOVFF  0E,00
0007C:  MOVFF  0F,01
00080:  MOVFF  10,02
00084:  MOVFF  11,03
00088:  MOVFF  0C,FE9
0008C:  MOVFF  07,FEA
00090:  BSF    07.7
00092:  MOVFF  08,FE1
00096:  MOVFF  09,FE2
0009A:  MOVFF  0A,FD9
0009E:  MOVFF  0B,FDA
000A2:  MOVFF  12,FF3
000A6:  MOVFF  13,FF4
000AA:  MOVFF  14,FFA
000AE:  MOVFF  15,FF5
000B2:  MOVFF  16,FF6
000B6:  MOVFF  17,FF7
000BA:  MOVFF  18,FF8
000BE:  MOVFF  19,FFB
000C2:  MOVF   04,W
000C4:  MOVFF  06,FE0
000C8:  MOVFF  05,FD8
000CC:  RETFIE 0
.................... #include <BIRDS5_OBC.h> 
.................... #include <18F67J94.h> 
.................... //////////// Standard Header file for the PIC18F67J94 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F67J94 
000CE:  DATA 0D,0A
000D0:  DATA 50,41
000D2:  DATA 53,53
000D4:  DATA 45,44
000D6:  DATA 20,44
000D8:  DATA 41,59
000DA:  DATA 53,3A
000DC:  DATA 25,78
000DE:  DATA 0D,0A
000E0:  DATA 00,00
000E2:  DATA 52,45
000E4:  DATA 53,45
000E6:  DATA 52,56
000E8:  DATA 45,20
000EA:  DATA 43,48
000EC:  DATA 45,43
000EE:  DATA 4B,3A
000F0:  DATA 25,78
000F2:  DATA 0D,0A
000F4:  DATA 00,00
000F6:  DATA 4B,69
000F8:  DATA 6C,6C
000FA:  DATA 20,46
000FC:  DATA 4C,41
000FE:  DATA 47,20
00100:  DATA 4D,41
00102:  DATA 49,4E
00104:  DATA 3A,25
00106:  DATA 78,0D
00108:  DATA 0A,00
0010A:  DATA 4B,69
0010C:  DATA 6C,6C
0010E:  DATA 20,46
00110:  DATA 4C,41
00112:  DATA 47,20
00114:  DATA 46,41
00116:  DATA 42,3A
00118:  DATA 25,78
0011A:  DATA 0D,0A
0011C:  DATA 00,00
0011E:  DATA 41,55
00120:  DATA 54,4F
00122:  DATA 20,48
00124:  DATA 49,47
00126:  DATA 48,20
00128:  DATA 53,41
0012A:  DATA 4D,50
0012C:  DATA 4C,49
0012E:  DATA 4E,47
00130:  DATA 3A,25
00132:  DATA 78,0D
00134:  DATA 0A,00
00136:  DATA 41,55
00138:  DATA 54,4F
0013A:  DATA 20,43
0013C:  DATA 41,4D
0013E:  DATA 3A,25
00140:  DATA 78,0D
00142:  DATA 0A,00
00144:  DATA 41,55
00146:  DATA 54,4F
00148:  DATA 20,4D
0014A:  DATA 42,50
0014C:  DATA 3A,25
0014E:  DATA 78,0D
00150:  DATA 0A,00
00152:  DATA 41,55
00154:  DATA 54,4F
00156:  DATA 20,41
00158:  DATA 44,43
0015A:  DATA 53,3A
0015C:  DATA 25,78
0015E:  DATA 0D,0A
00160:  DATA 00,00
00162:  DATA 41,4E
00164:  DATA 54,45
00166:  DATA 4E,4E
00168:  DATA 41,20
0016A:  DATA 44,45
0016C:  DATA 50,4C
0016E:  DATA 4F,59
00170:  DATA 3A,25
00172:  DATA 78,0D
00174:  DATA 0A,00
00176:  DATA 41,4E
00178:  DATA 54,45
0017A:  DATA 4E,4E
0017C:  DATA 41,20
0017E:  DATA 44,45
00180:  DATA 50,4C
00182:  DATA 4F,59
00184:  DATA 20,41
00186:  DATA 54,54
00188:  DATA 45,4D
0018A:  DATA 50,54
0018C:  DATA 3A,25
0018E:  DATA 78,0D
00190:  DATA 0A,00
00192:  DATA 55,50
00194:  DATA 4C,49
00196:  DATA 4E,4B
00198:  DATA 20,53
0019A:  DATA 55,43
0019C:  DATA 43,45
0019E:  DATA 53,53
001A0:  DATA 3A,25
001A2:  DATA 78,0D
001A4:  DATA 0A,0D
001A6:  DATA 0A,00
001A8:  DATA 0D,0A
001AA:  DATA 41,44
001AC:  DATA 44,20
001AE:  DATA 49,4E
001B0:  DATA 46,4F
001B2:  DATA 20,41
001B4:  DATA 44,44
001B6:  DATA 52,45
001B8:  DATA 53,53
001BA:  DATA 3A,25
001BC:  DATA 6C,78
001BE:  DATA 0D,0A
001C0:  DATA 0D,0A
001C2:  DATA 00,00
001C4:  DATA 46,4C
001C6:  DATA 41,47
001C8:  DATA 20,44
001CA:  DATA 41,54
001CC:  DATA 41,20
001CE:  DATA 41,44
001D0:  DATA 44,52
001D2:  DATA 45,53
001D4:  DATA 53,3A
001D6:  DATA 25,78
001D8:  DATA 25,78
001DA:  DATA 25,78
001DC:  DATA 25,78
001DE:  DATA 0D,0A
001E0:  DATA 00,00
001E2:  DATA 52,45
001E4:  DATA 53,45
001E6:  DATA 52,56
001E8:  DATA 41,54
001EA:  DATA 49,4F
001EC:  DATA 4E,20
001EE:  DATA 54,41
001F0:  DATA 42,4C
001F2:  DATA 45,20
001F4:  DATA 41,44
001F6:  DATA 44,52
001F8:  DATA 45,53
001FA:  DATA 53,3A
001FC:  DATA 25,78
001FE:  DATA 25,78
00200:  DATA 25,78
00202:  DATA 25,78
00204:  DATA 0D,0A
00206:  DATA 00,00
00208:  DATA 53,41
0020A:  DATA 54,45
0020C:  DATA 4C,4C
0020E:  DATA 49,54
00210:  DATA 45,20
00212:  DATA 4C,4F
00214:  DATA 47,20
00216:  DATA 41,44
00218:  DATA 44,52
0021A:  DATA 45,53
0021C:  DATA 53,3A
0021E:  DATA 25,78
00220:  DATA 25,78
00222:  DATA 25,78
00224:  DATA 25,78
00226:  DATA 0D,0A
00228:  DATA 00,00
0022A:  DATA 43,41
0022C:  DATA 4D,20
0022E:  DATA 41,44
00230:  DATA 44,52
00232:  DATA 45,53
00234:  DATA 53,3A
00236:  DATA 25,78
00238:  DATA 25,78
0023A:  DATA 25,78
0023C:  DATA 25,78
0023E:  DATA 0D,0A
00240:  DATA 00,00
00242:  DATA 46,41
00244:  DATA 42,20
00246:  DATA 48,4B
00248:  DATA 20,41
0024A:  DATA 44,44
0024C:  DATA 52,45
0024E:  DATA 53,53
00250:  DATA 3A,25
00252:  DATA 78,25
00254:  DATA 78,25
00256:  DATA 78,25
00258:  DATA 78,0D
0025A:  DATA 0A,00
0025C:  DATA 46,41
0025E:  DATA 42,20
00260:  DATA 43,57
00262:  DATA 20,41
00264:  DATA 44,44
00266:  DATA 52,45
00268:  DATA 53,53
0026A:  DATA 3A,25
0026C:  DATA 78,25
0026E:  DATA 78,25
00270:  DATA 78,25
00272:  DATA 78,0D
00274:  DATA 0A,00
00276:  DATA 41,44
00278:  DATA 43,53
0027A:  DATA 20,53
0027C:  DATA 45,4E
0027E:  DATA 53,4F
00280:  DATA 52,20
00282:  DATA 41,44
00284:  DATA 44,52
00286:  DATA 45,53
00288:  DATA 53,3A
0028A:  DATA 25,78
0028C:  DATA 25,78
0028E:  DATA 25,78
00290:  DATA 25,78
00292:  DATA 0D,0A
00294:  DATA 00,00
00296:  DATA 41,44
00298:  DATA 43,53
0029A:  DATA 20,54
0029C:  DATA 4C,45
0029E:  DATA 20,41
002A0:  DATA 44,44
002A2:  DATA 52,45
002A4:  DATA 53,53
002A6:  DATA 3A,25
002A8:  DATA 78,25
002AA:  DATA 78,25
002AC:  DATA 78,25
002AE:  DATA 78,0D
002B0:  DATA 0A,00
002B2:  DATA 4D,49
002B4:  DATA 53,53
002B6:  DATA 49,4F
002B8:  DATA 4E,20
002BA:  DATA 42,4F
002BC:  DATA 53,53
002BE:  DATA 20,41
002C0:  DATA 44,44
002C2:  DATA 52,45
002C4:  DATA 53,53
002C6:  DATA 3A,25
002C8:  DATA 78,25
002CA:  DATA 78,25
002CC:  DATA 78,25
002CE:  DATA 78,0D
002D0:  DATA 0A,00
002D2:  DATA 48,49
002D4:  DATA 47,48
002D6:  DATA 20,53
002D8:  DATA 41,4D
002DA:  DATA 50,20
002DC:  DATA 48,4B
002DE:  DATA 20,41
002E0:  DATA 44,44
002E2:  DATA 52,45
002E4:  DATA 53,53
002E6:  DATA 3A,25
002E8:  DATA 78,25
002EA:  DATA 78,25
002EC:  DATA 78,25
002EE:  DATA 78,0D
002F0:  DATA 0A,00
002F2:  DATA 57,52
002F4:  DATA 49,54
002F6:  DATA 45,20
002F8:  DATA 25,6C
002FA:  DATA 78,20
002FC:  DATA 54,49
002FE:  DATA 4D,45
00300:  DATA 53,0D
00302:  DATA 0A,00
00304:  DATA 0D,0A
00306:  DATA 50,41
00308:  DATA 53,53
0030A:  DATA 45,44
0030C:  DATA 20,44
0030E:  DATA 41,59
00310:  DATA 53,3A
00312:  DATA 25,6C
00314:  DATA 78,0D
00316:  DATA 0A,00
00318:  DATA 52,45
0031A:  DATA 53,45
0031C:  DATA 52,56
0031E:  DATA 45,20
00320:  DATA 43,48
00322:  DATA 45,43
00324:  DATA 4B,3A
00326:  DATA 25,78
00328:  DATA 0D,0A
0032A:  DATA 00,00
0032C:  DATA 4B,69
0032E:  DATA 6C,6C
00330:  DATA 20,46
00332:  DATA 4C,41
00334:  DATA 47,20
00336:  DATA 4D,41
00338:  DATA 49,4E
0033A:  DATA 3A,25
0033C:  DATA 78,0D
0033E:  DATA 0A,00
00340:  DATA 4B,69
00342:  DATA 6C,6C
00344:  DATA 20,46
00346:  DATA 4C,41
00348:  DATA 47,20
0034A:  DATA 46,41
0034C:  DATA 42,3A
0034E:  DATA 25,78
00350:  DATA 0D,0A
00352:  DATA 00,00
00354:  DATA 41,55
00356:  DATA 54,4F
00358:  DATA 20,48
0035A:  DATA 49,47
0035C:  DATA 48,20
0035E:  DATA 53,41
00360:  DATA 4D,50
00362:  DATA 4C,49
00364:  DATA 4E,47
00366:  DATA 3A,25
00368:  DATA 78,0D
0036A:  DATA 0A,00
0036C:  DATA 41,55
0036E:  DATA 54,4F
00370:  DATA 20,43
00372:  DATA 41,4D
00374:  DATA 3A,25
00376:  DATA 78,0D
00378:  DATA 0A,00
0037A:  DATA 41,55
0037C:  DATA 54,4F
0037E:  DATA 20,4D
00380:  DATA 42,50
00382:  DATA 3A,25
00384:  DATA 78,0D
00386:  DATA 0A,00
00388:  DATA 41,55
0038A:  DATA 54,4F
0038C:  DATA 20,41
0038E:  DATA 44,43
00390:  DATA 53,3A
00392:  DATA 25,78
00394:  DATA 0D,0A
00396:  DATA 00,00
00398:  DATA 41,4E
0039A:  DATA 54,45
0039C:  DATA 4E,4E
0039E:  DATA 41,20
003A0:  DATA 44,45
003A2:  DATA 50,4C
003A4:  DATA 4F,59
003A6:  DATA 3A,25
003A8:  DATA 78,0D
003AA:  DATA 0A,00
003AC:  DATA 55,50
003AE:  DATA 4C,49
003B0:  DATA 4E,4B
003B2:  DATA 20,53
003B4:  DATA 55,43
003B6:  DATA 43,45
003B8:  DATA 53,53
003BA:  DATA 3A,25
003BC:  DATA 78,0D
003BE:  DATA 0A,0D
003C0:  DATA 0A,00
003C2:  DATA 46,4C
003C4:  DATA 41,47
003C6:  DATA 20,49
003C8:  DATA 4E,46
003CA:  DATA 4F,20
003CC:  DATA 53,54
003CE:  DATA 4F,52
003D0:  DATA 45,44
003D2:  DATA 20,49
003D4:  DATA 4E,20
003D6:  DATA 46,4C
003D8:  DATA 41,53
003DA:  DATA 48,0D
003DC:  DATA 0A,00
003DE:  DATA 0D,0A
003E0:  DATA 61,64
003E2:  DATA 64,72
003E4:  DATA 65,73
003E6:  DATA 73,20
003E8:  DATA 69,6E
003EA:  DATA 66,6F
003EC:  DATA 20,6C
003EE:  DATA 6F,63
003F0:  DATA 61,74
003F2:  DATA 69,6F
003F4:  DATA 6E,3A
003F6:  DATA 25,6C
003F8:  DATA 78,0D
003FA:  DATA 0A,00
003FC:  DATA 41,44
003FE:  DATA 20,43
00400:  DATA 4F,55
00402:  DATA 4E,54
00404:  DATA 45,52
00406:  DATA 3A,25
00408:  DATA 6C,78
0040A:  DATA 0D,0A
0040C:  DATA 00,00
0040E:  DATA 43,48
00410:  DATA 41,4E
00412:  DATA 47,45
00414:  DATA 44,20
00416:  DATA 4D,45
00418:  DATA 4D,4F
0041A:  DATA 52,59
0041C:  DATA 20,41
0041E:  DATA 44,44
00420:  DATA 52,45
00422:  DATA 53,53
00424:  DATA 3A,00
00426:  DATA 0D,0A
00428:  DATA 53,74
0042A:  DATA 6F,72
0042C:  DATA 65,69
0042E:  DATA 6E,67
00430:  DATA 20,41
00432:  DATA 64,64
00434:  DATA 72,65
00436:  DATA 73,73
00438:  DATA 20,44
0043A:  DATA 61,74
0043C:  DATA 61,20
0043E:  DATA 69,6E
00440:  DATA 20,46
00442:  DATA 6C,61
00444:  DATA 73,68
00446:  DATA 0D,0A
00448:  DATA 00,00
0044A:  DATA 41,44
0044C:  DATA 44,52
0044E:  DATA 45,53
00450:  DATA 53,20
00452:  DATA 44,41
00454:  DATA 54,41
00456:  DATA 20,53
00458:  DATA 54,4F
0045A:  DATA 52,45
0045C:  DATA 20,44
0045E:  DATA 4F,4E
00460:  DATA 45,3A
00462:  DATA 25,6C
00464:  DATA 78,0D
00466:  DATA 0A,00
00468:  DATA 46,4C
0046A:  DATA 41,53
0046C:  DATA 48,20
0046E:  DATA 4D,45
00470:  DATA 4D,4F
00472:  DATA 52,59
00474:  DATA 20,45
00476:  DATA 52,41
00478:  DATA 53,45
0047A:  DATA 20,53
0047C:  DATA 54,41
0047E:  DATA 52,54
00480:  DATA 0D,0A
00482:  DATA 00,00
00484:  DATA 46,4C
00486:  DATA 41,53
00488:  DATA 48,20
0048A:  DATA 4D,45
0048C:  DATA 4D,4F
0048E:  DATA 52,59
00490:  DATA 20,45
00492:  DATA 52,41
00494:  DATA 53,45
00496:  DATA 20,44
00498:  DATA 4F,4E
0049A:  DATA 45,0D
0049C:  DATA 0A,00
0049E:  DATA 52,65
004A0:  DATA 6D,61
004A2:  DATA 69,6E
004A4:  DATA 69,6E
004A6:  DATA 67,20
004A8:  DATA 74,69
004AA:  DATA 6D,65
004AC:  DATA 3A,20
004AE:  DATA 25,64
004B0:  DATA 20,20
004B2:  DATA 0D,00
004B4:  DATA 65,72
004B6:  DATA 61,73
004B8:  DATA 69,6E
004BA:  DATA 67,20
004BC:  DATA 6E,65
004BE:  DATA 78,74
004C0:  DATA 20,73
004C2:  DATA 65,63
004C4:  DATA 74,6F
004C6:  DATA 72,0D
004C8:  DATA 0A,00
004CA:  DATA 65,72
004CC:  DATA 61,73
004CE:  DATA 69,6E
004D0:  DATA 67,20
004D2:  DATA 6E,65
004D4:  DATA 78,74
004D6:  DATA 20,73
004D8:  DATA 65,63
004DA:  DATA 74,6F
004DC:  DATA 72,0D
004DE:  DATA 0A,00
004E0:  DATA 65,72
004E2:  DATA 61,73
004E4:  DATA 69,6E
004E6:  DATA 67,20
004E8:  DATA 6E,65
004EA:  DATA 78,74
004EC:  DATA 20,73
004EE:  DATA 65,63
004F0:  DATA 74,6F
004F2:  DATA 72,0D
004F4:  DATA 0A,00
004F6:  DATA 65,72
004F8:  DATA 61,73
004FA:  DATA 69,6E
004FC:  DATA 67,20
004FE:  DATA 6E,65
00500:  DATA 78,74
00502:  DATA 20,73
00504:  DATA 65,63
00506:  DATA 74,6F
00508:  DATA 72,0D
0050A:  DATA 0A,00
0050C:  DATA 65,72
0050E:  DATA 61,73
00510:  DATA 69,6E
00512:  DATA 67,20
00514:  DATA 6E,65
00516:  DATA 78,74
00518:  DATA 20,73
0051A:  DATA 65,63
0051C:  DATA 74,6F
0051E:  DATA 72,0D
00520:  DATA 0A,00
00522:  DATA 47,65
00524:  DATA 74,20
00526:  DATA 63,6F
00528:  DATA 6D,6D
0052A:  DATA 61,6E
0052C:  DATA 64,0D
0052E:  DATA 0A,00
00530:  DATA 53,74
00532:  DATA 61,72
00534:  DATA 74,20
00536:  DATA 30,78
00538:  DATA 31,33
0053A:  DATA 0D,0A
0053C:  DATA 00,00
0053E:  DATA 46,69
00540:  DATA 6E,69
00542:  DATA 73,68
00544:  DATA 20,30
00546:  DATA 78,31
00548:  DATA 33,0D
0054A:  DATA 0A,00
0054C:  DATA 53,74
0054E:  DATA 61,72
00550:  DATA 74,20
00552:  DATA 30,78
00554:  DATA 31,34
00556:  DATA 0D,0A
00558:  DATA 00,00
0055A:  DATA 46,69
0055C:  DATA 6E,69
0055E:  DATA 73,68
00560:  DATA 20,30
00562:  DATA 78,31
00564:  DATA 34,0D
00566:  DATA 0A,00
00568:  DATA 53,74
0056A:  DATA 61,72
0056C:  DATA 74,20
0056E:  DATA 30,78
00570:  DATA 31,36
00572:  DATA 0D,0A
00574:  DATA 00,00
00576:  DATA 53,74
00578:  DATA 61,72
0057A:  DATA 74,20
0057C:  DATA 30,78
0057E:  DATA 39,31
00580:  DATA 0D,0A
00582:  DATA 00,00
00584:  DATA 46,69
00586:  DATA 6E,69
00588:  DATA 73,68
0058A:  DATA 20,30
0058C:  DATA 78,39
0058E:  DATA 31,0D
00590:  DATA 0A,00
00592:  DATA 53,74
00594:  DATA 61,72
00596:  DATA 74,20
00598:  DATA 30,78
0059A:  DATA 39,32
0059C:  DATA 0D,0A
0059E:  DATA 00,00
005A0:  DATA 46,69
005A2:  DATA 6E,69
005A4:  DATA 73,68
005A6:  DATA 20,30
005A8:  DATA 78,39
005AA:  DATA 32,0D
005AC:  DATA 0A,00
005AE:  DATA 53,74
005B0:  DATA 61,72
005B2:  DATA 74,20
005B4:  DATA 30,78
005B6:  DATA 39,33
005B8:  DATA 0D,0A
005BA:  DATA 00,00
005BC:  DATA 46,69
005BE:  DATA 6E,69
005C0:  DATA 73,68
005C2:  DATA 20,30
005C4:  DATA 78,39
005C6:  DATA 33,0D
005C8:  DATA 0A,00
005CA:  DATA 53,74
005CC:  DATA 61,72
005CE:  DATA 74,20
005D0:  DATA 30,78
005D2:  DATA 39,42
005D4:  DATA 0D,0A
005D6:  DATA 00,00
005D8:  DATA 46,69
005DA:  DATA 6E,69
005DC:  DATA 73,68
005DE:  DATA 20,30
005E0:  DATA 78,39
005E2:  DATA 42,0D
005E4:  DATA 0A,00
005E6:  DATA 53,74
005E8:  DATA 61,72
005EA:  DATA 74,20
005EC:  DATA 30,78
005EE:  DATA 39,46
005F0:  DATA 0D,0A
005F2:  DATA 00,00
005F4:  DATA 46,69
005F6:  DATA 6E,69
005F8:  DATA 73,68
005FA:  DATA 20,30
005FC:  DATA 78,39
005FE:  DATA 46,0D
00600:  DATA 0A,00
00602:  DATA 0D,0A
00604:  DATA 52,45
00606:  DATA 53,45
00608:  DATA 54,20
0060A:  DATA 44,41
0060C:  DATA 54,41
0060E:  DATA 20,4E
00610:  DATA 4F,20
00612:  DATA 4F,42
00614:  DATA 54,41
00616:  DATA 49,4E
00618:  DATA 45,44
0061A:  DATA 0D,0A
0061C:  DATA 00,00
0061E:  DATA 52,65
00620:  DATA 61,64
00622:  DATA 79,20
00624:  DATA 66,6F
00626:  DATA 72,20
00628:  DATA 72,65
0062A:  DATA 73,65
0062C:  DATA 74,00
0062E:  DATA 4C,4F
00630:  DATA 47,20
00632:  DATA 73,61
00634:  DATA 76,69
00636:  DATA 6E,67
00638:  DATA 20,64
0063A:  DATA 6F,6E
0063C:  DATA 65,0D
0063E:  DATA 0A,00
*
0065C:  MOVLB  2
0065E:  MOVF   x25,W
00660:  CLRF   01
00662:  SUBWF  x24,W
00664:  BC    066C
00666:  MOVFF  224,00
0066A:  BRA    0684
0066C:  CLRF   00
0066E:  MOVLW  08
00670:  MOVWF  x26
00672:  RLCF   x24,F
00674:  RLCF   00,F
00676:  MOVF   x25,W
00678:  SUBWF  00,W
0067A:  BTFSC  FD8.0
0067C:  MOVWF  00
0067E:  RLCF   01,F
00680:  DECFSZ x26,F
00682:  BRA    0672
00684:  MOVLB  0
00686:  GOTO   06C0 (RETURN)
*
006D6:  DATA 53,74
006D8:  DATA 61,72
006DA:  DATA 74,20
006DC:  DATA 4F,70
006DE:  DATA 65,72
006E0:  DATA 61,74
006E2:  DATA 69,6E
006E4:  DATA 67,0D
006E6:  DATA 0A,00
006E8:  DATA 0D,0A
006EA:  DATA 48,65
006EC:  DATA 6C,6C
006EE:  DATA 6F,20
006F0:  DATA 57,6F
006F2:  DATA 72,6C
006F4:  DATA 64,0D
006F6:  DATA 0A,00
006F8:  DATA 4F,70
006FA:  DATA 65,72
006FC:  DATA 61,74
006FE:  DATA 69,6E
00700:  DATA 67,0D
00702:  DATA 0A,00
00704:  TBLRD*+
00706:  MOVF   FF5,F
00708:  BZ    072C
0070A:  MOVFF  FF6,202
0070E:  MOVFF  FF7,203
00712:  MOVFF  FF8,204
00716:  MOVF   FF5,W
00718:  BTFSS  F9E.4
0071A:  BRA    0718
0071C:  MOVWF  FAD
0071E:  MOVFF  202,FF6
00722:  MOVFF  203,FF7
00726:  MOVFF  204,FF8
0072A:  BRA    0704
0072C:  RETURN 0
*
00758:  TBLRD*+
0075A:  MOVF   FF5,F
0075C:  BZ    0784
0075E:  MOVFF  FF6,20F
00762:  MOVFF  FF7,210
00766:  MOVFF  FF8,211
0076A:  MOVF   FF5,W
0076C:  BTFSS  FA6.4
0076E:  BRA    076C
00770:  MOVLB  F
00772:  MOVWF  x29
00774:  MOVFF  20F,FF6
00778:  MOVFF  210,FF7
0077C:  MOVFF  211,FF8
00780:  MOVLB  0
00782:  BRA    0758
00784:  RETURN 0
....................  
.................... #list 
....................  
.................... #FUSES NOWDT, NOBROWNOUT, NOPROTECT 
.................... #use delay(crystal=16Mhz, clock=16Mhz) 
*
0072E:  MOVLW  02
00730:  MOVWF  FEA
00732:  MOVLW  10
00734:  MOVWF  FE9
00736:  MOVF   FEF,W
00738:  BZ    0756
0073A:  MOVLW  05
0073C:  MOVWF  01
0073E:  CLRF   00
00740:  DECFSZ 00,F
00742:  BRA    0740
00744:  DECFSZ 01,F
00746:  BRA    073E
00748:  MOVLW  2E
0074A:  MOVWF  00
0074C:  DECFSZ 00,F
0074E:  BRA    074C
00750:  BRA    0752
00752:  DECFSZ FEF,F
00754:  BRA    073A
00756:  RETURN 0
.................... #include<PIC18F67J94_registers.h> 
.................... #byte ADCBUF0H = 0xFC3 
.................... #byte ADCBUF0L = 0xFC2 
.................... #byte ADCON1H = 0xFC1 
.................... #bit    FORM0 = ADCON1H.0 
.................... #bit    FORM1 = ADCON1H.1 
.................... #bit    MODE12 = ADCON1H.2 
.................... #bit    DMAEN = ADCON1H.3 
.................... #bit    DMABM = ADCON1H.4 
.................... #bit    ADSIDL = ADCON1H.5 
.................... #bit    ADFRZ = ADCON1H.6 
.................... #bit    ADON = ADCON1H.7 
.................... #byte ADCON1L = 0xFC0 
.................... #bit    DONE = ADCON1L.0 
.................... #bit    SAMP = ADCON1L.1 
.................... #bit    ASAM = ADCON1L.2 
.................... #bit    SIMSAM = ADCON1L.3 
.................... #bit    SSRC0 = ADCON1L.4 
.................... #bit    SSRC1 = ADCON1L.5 
.................... #bit    SSRC2 = ADCON1L.6 
.................... #bit    SSRC3 = ADCON1L.7 
.................... #byte TRISG = 0xF98 
.................... #byte TRISF = 0xF97 
.................... #byte TRISE = 0xF96 
.................... #byte TRISD = 0xF95 
.................... #byte TRISC = 0xF94 
.................... #byte TRISB = 0xF93 
....................  
.................... #byte TRISA = 0xF92 
.................... #bit    TRISA0 = TRISA.0 
.................... #bit    TRISA1 = TRISA.1 
.................... #bit    TRISA2 = TRISA.2 
....................  
....................  
.................... #byte LATG = 0xF8F 
.................... #byte LATF = 0xF8E 
.................... #byte LATE = 0xF8D 
.................... #byte LATD = 0xF8C 
.................... #byte LATC = 0xF8B 
.................... #byte LATB = 0xF8A 
....................  
.................... #byte LATA = 0xF89 
.................... #bit    LATA0 = LATA.0 
.................... #bit    LATA1 = LATA.1 
.................... #bit    LATA2 = LATA.2 
.................... #bit    LATA3 = LATA.3 
....................  
.................... #byte PORTG = 0xF86 
.................... #bit    RG0 = PORTG.0 
.................... #bit    RG1 = PORTG.1 
.................... #bit    RG2 = PORTG.2 
.................... #bit    RG3 = PORTG.3 
.................... #bit    RG4 = PORTG.4 
.................... #bit    RG6 = PORTG.6 
.................... #bit    RG7 = PORTG.7 
.................... #byte PORTF = 0xF85 
.................... #bit    RF2 = PORTF.2 
.................... #bit    RF3 = PORTF.3 
.................... #bit    RF4 = PORTF.4 
.................... #bit    RF5 = PORTF.5 
.................... #bit    RF6 = PORTF.6 
.................... #bit    RF7 = PORTF.7 
.................... #byte PORTE = 0xF84 
.................... #byte PORTD = 0xF83 
.................... #byte PORTC = 0xF82 
.................... #bit    RC0 = PORTC.0 
.................... #bit    RC1 = PORTC.1 
.................... #bit    RC2 = PORTC.2 
.................... #bit    RC3 = PORTC.3 
.................... #bit    RC4 = PORTC.4 
.................... #bit    RC5 = PORTC.5 
.................... #bit    RC6 = PORTC.6 
.................... #bit    RC7 = PORTC.7 
.................... #byte PORTB = 0xF81 
.................... #byte PORTA = 0xF80 
.................... #bit    RA0 = PORTA.0 
.................... #bit    RA1 = PORTA.1 
.................... #bit    RA2 = PORTA.2 
.................... #bit    RA3 = PORTA.3 
.................... #bit    RA4 = PORTA.4 
.................... #bit    RA5 = PORTA.5 
.................... #bit    RA6 = PORTA.6 
.................... #bit    RA7 = PORTA.7 
.................... #byte TRISVP = 0xF73 
.................... #byte LATVP = 0xF72 
.................... #byte PORTVP = 0xF71 
.................... #byte WPUB = 0xF62 
.................... #byte ALRMVALH = 0xF59 
.................... #byte ALRMVALL = 0xF58 
.................... #byte ANCFG = 0xF01 
.................... #bit    VBGEN = ANCFG.0 
.................... #bit    VBG2EN = ANCFG.1 
.................... #bit    VBG6EN = ANCFG.2 
.................... #byte ODCON1 = 0xEEB 
.................... #bit    SSP1OD = ODCON1.0 
.................... #bit    SSP2OD = ODCON1.1 
.................... #bit    USART1OD = ODCON1.2 
.................... #bit    USART2OD = ODCON1.3 
.................... #bit    USART3OD = ODCON1.4 
.................... #bit    USART4OD = ODCON1.5 
.................... #bit    ECCP1OD = ODCON1.6 
.................... #bit    ECCP2OD = ODCON1.7 
.................... #byte ODCON2 = 0xEEA 
.................... #bit    ECCP3OD = ODCON2.0 
.................... #bit    CCP4OD = ODCON2.1 
.................... #bit    CCP5OD = ODCON2.2 
.................... #bit    CCP6OD = ODCON2.3 
.................... #bit    CCP7OD = ODCON2.4 
.................... #bit    CCP8OD = ODCON2.5 
.................... #bit    CCP9OD = ODCON2.6 
.................... #bit    CCP10OD = ODCON2.7 
.................... #byte ADCON2H = 0xE8D 
.................... #bit    CHPS0 = ADCON2H.0 
.................... #bit    CHPS1 = ADCON2H.1 
.................... #bit    CSCNA = ADCON2H.2 
.................... #bit    BUFREGEN = ADCON2H.3 
.................... #bit    OFFCAL = ADCON2H.4 
.................... #bit    NVCFG0 = ADCON2H.5 
.................... #bit    PVCFG0 = ADCON2H.6 
.................... #bit    PVCFG1 = ADCON2H.7 
.................... #byte ADCON2L = 0xE8C 
.................... #bit    ALTS = ADCON2L.0 
.................... #bit    BUFM = ADCON2L.1 
.................... #bit    SMPI0 = ADCON2L.2 
.................... #bit    SMPI1 = ADCON2L.3 
.................... #bit    SMPI2 = ADCON2L.4 
.................... #bit    SMPI3 = ADCON2L.5 
.................... #bit    SMPI4 = ADCON2L.6 
.................... #bit    BUFS = ADCON2L.7 
.................... #byte ADCON3H = 0xE8B 
.................... #bit    SAMC0 = ADCON3H.0 
.................... #bit    SAMC1 = ADCON3H.1 
.................... #bit    SAMC2 = ADCON3H.2 
.................... #bit    SAMC3 = ADCON3H.3 
.................... #bit    SAMC4 = ADCON3H.4 
.................... #bit    PUMPEN = ADCON3H.5 
.................... #bit    EXTSAM = ADCON3H.6 
.................... #bit    ADRC = ADCON3H.7 
.................... #byte ADCON3L = 0xE8A 
.................... #byte ADCON5H = 0xE89 
.................... #bit    ASINTMD0 = ADCON5H.0 
.................... #bit    ASINTMD1 = ADCON5H.1 
.................... #bit    VREGSREQ = ADCON5H.3 
.................... #bit    BGREQ = ADCON5H.4 
.................... #bit    CTMUREQ = ADCON5H.5 
.................... #bit    LPENA = ADCON5H.6 
.................... #bit    ASENA = ADCON5H.7 
.................... #byte ADCON5L = 0xE88 
.................... #bit    CM0 = ADCON5L.0 
.................... #bit    CM1 = ADCON5L.1 
.................... #bit    WM0 = ADCON5L.2 
.................... #bit    WM1 = ADCON5L.3 
.................... #byte ADCHS0H = 0xE87 
.................... #bit    CH0SB0 = ADCHS0H.0 
.................... #bit    CH0SB1 = ADCHS0H.1 
.................... #bit    CH0SB2 = ADCHS0H.2 
.................... #bit    CH0SB3 = ADCHS0H.3 
.................... #bit    CH0SB4 = ADCHS0H.4 
.................... #bit    CH0NB0 = ADCHS0H.5 
.................... #bit    CH0NB1 = ADCHS0H.6 
.................... #bit    CH0NB2 = ADCHS0H.7 
.................... #byte ADCHS0L = 0xE86 
.................... #bit    CH0SA0 = ADCHS0L.0 
.................... #bit    CH0SA1 = ADCHS0L.1 
.................... #bit    CH0SA2 = ADCHS0L.2 
.................... #bit    CH0SA3 = ADCHS0L.3 
.................... #bit    CH0SA4 = ADCHS0L.4 
.................... #bit    CH0NA0 = ADCHS0L.5 
.................... #bit    CH0NA1 = ADCHS0L.6 
.................... #bit    CH0NA2 = ADCHS0L.7 
.................... #byte ADCSS1H = 0xE85 
.................... #bit    CSS24 = ADCSS1H.0 
.................... #bit    CSS25 = ADCSS1H.1 
.................... #bit    CSS26 = ADCSS1H.2 
.................... #bit    CSS27 = ADCSS1H.3 
.................... #bit    CSS28 = ADCSS1H.4 
.................... #bit    CSS29 = ADCSS1H.5 
.................... #bit    CSS30 = ADCSS1H.6 
.................... #bit    CSS31 = ADCSS1H.7 
.................... #byte ADCSS1L = 0xE84 
.................... #bit    CSS16 = ADCSS1L.0 
.................... #bit    CSS17 = ADCSS1L.1 
.................... #bit    CSS18 = ADCSS1L.2 
.................... #bit    CSS19 = ADCSS1L.3 
.................... #bit    CSS20 = ADCSS1L.4 
.................... #bit    CSS21 = ADCSS1L.5 
.................... #bit    CSS22 = ADCSS1L.6 
.................... #bit    CSS23 = ADCSS1L.7 
.................... #byte ADCSS0H = 0xE83 
.................... #bit    CSS8 = ADCSS0H.0 
.................... #bit    CSS9 = ADCSS0H.1 
.................... #bit    CSS10 = ADCSS0H.2 
.................... #bit    CSS11 = ADCSS0H.3 
.................... #bit    CSS12 = ADCSS0H.4 
.................... #bit    CSS13 = ADCSS0H.5 
.................... #bit    CSS14 = ADCSS0H.6 
.................... #bit    CSS15 = ADCSS0H.7 
.................... #byte ADCSS0L = 0xE82 
.................... #byte ADCHIT1H = 0xE81 
.................... #bit    CHH24 = ADCHIT1H.0 
.................... #bit    CHH25 = ADCHIT1H.1 
.................... #bit    CHH26 = ADCHIT1H.2 
.................... #bit    CHH27 = ADCHIT1H.3 
.................... #bit    CHH28 = ADCHIT1H.4 
.................... #bit    CHH29 = ADCHIT1H.5 
.................... #bit    CHH30 = ADCHIT1H.6 
.................... #bit    CHH31 = ADCHIT1H.7 
.................... #byte ADCHIT1L = 0xE80 
.................... #bit    CHH16 = ADCHIT1L.0 
.................... #bit    CHH17 = ADCHIT1L.1 
.................... #bit    CHH18 = ADCHIT1L.2 
.................... #bit    CHH19 = ADCHIT1L.3 
.................... #bit    CHH20 = ADCHIT1L.4 
.................... #bit    CHH21 = ADCHIT1L.5 
.................... #bit    CHH22 = ADCHIT1L.6 
.................... #bit    CHH23 = ADCHIT1L.7 
.................... #byte ADCHIT0H = 0xE7F 
.................... #bit    CHH8 = ADCHIT0H.0 
.................... #bit    CHH9 = ADCHIT0H.1 
.................... #bit    CHH10 = ADCHIT0H.2 
.................... #bit    CHH11 = ADCHIT0H.3 
.................... #bit    CHH12 = ADCHIT0H.4 
.................... #bit    CHH13 = ADCHIT0H.5 
.................... #bit    CHH14 = ADCHIT0H.6 
.................... #bit    CHH15 = ADCHIT0H.7 
.................... #byte ADCHIT0L = 0xE7E 
.................... #byte ADCTMUEN1H = 0xE7D 
.................... #bit    CTUMEN24 = ADCTMUEN1H.0 
.................... #bit    CTUMEN25 = ADCTMUEN1H.1 
.................... #bit    CTUMEN26 = ADCTMUEN1H.2 
.................... #bit    CTUMEN27 = ADCTMUEN1H.3 
.................... #bit    CTUMEN28 = ADCTMUEN1H.4 
.................... #bit    CTUMEN29 = ADCTMUEN1H.5 
.................... #bit    CTMUEN30 = ADCTMUEN1H.6 
.................... #bit    CTMUEN31 = ADCTMUEN1H.7 
.................... #byte ADCTMUEN1L = 0xE7C 
.................... #bit    CTUMEN16 = ADCTMUEN1L.0 
.................... #bit    CTUMEN17 = ADCTMUEN1L.1 
.................... #bit    CTUMEN18 = ADCTMUEN1L.2 
.................... #bit    CTUMEN19 = ADCTMUEN1L.3 
.................... #bit    CTMUEN20 = ADCTMUEN1L.4 
.................... #bit    CTMUEN21 = ADCTMUEN1L.5 
.................... #bit    CTMUEN22 = ADCTMUEN1L.6 
.................... #bit    CTMUEN23 = ADCTMUEN1L.7 
.................... #byte ADCTMUEN0H = 0xE7B 
.................... #bit    CTMUEN8 = ADCTMUEN0H.0 
.................... #bit    CTMUEN9 = ADCTMUEN0H.1 
.................... #bit    CTMUEN10 = ADCTMUEN0H.2 
.................... #bit    CTMUEN11 = ADCTMUEN0H.3 
.................... #bit    CTMUEN12 = ADCTMUEN0H.4 
.................... #bit    CTMUEN13 = ADCTMUEN0H.5 
.................... #bit    CTMUEN14 = ADCTMUEN0H.6 
.................... #bit    CTMUEN15 = ADCTMUEN0H.7 
.................... #byte ADCTMUEN0L = 0xE7A 
.................... #byte ADCBUF25H = 0xE79 
.................... #byte ADCBUF25L = 0xE78 
.................... #byte ADCBUF24H = 0xE77 
.................... #byte ADCBUF24L = 0xE76 
.................... #byte ADCBUF23H = 0xE75 
.................... #byte ADCBUF23L = 0xE74 
.................... #byte ADCBUF22H = 0xE73 
.................... #byte ADCBUF22L = 0xE72 
.................... #byte ADCBUF21H = 0xE71 
.................... #byte ADCBUF21L = 0xE70 
.................... #byte ADCBUF20H = 0xE6F 
.................... #byte ADCBUF20L = 0xE6E 
.................... #byte ADCBUF19H = 0xE6D 
.................... #byte ADCBUF19L = 0xE6C 
.................... #byte ADCBUF18H = 0xE6B 
.................... #byte ADCBUF18L = 0xE6A 
.................... #byte ADCBUF17H = 0xE69 
.................... #byte ADCBUF17L = 0xE68 
.................... #byte ADCBUF16H = 0xE67 
.................... #byte ADCBUF16L = 0xE66 
.................... #byte ADCBUF15H = 0xE65 
.................... #byte ADCBUF15L = 0xE64 
.................... #byte ADCBUF14H = 0xE63 
.................... #byte ADCBUF14L = 0xE62 
.................... #byte ADCBUF13H = 0xE61 
.................... #byte ADCBUF13L = 0xE60 
.................... #byte ADCBUF12H = 0xE5F 
.................... #byte ADCBUF12L = 0xE5E 
.................... #byte ADCBUF11H = 0xE5D 
.................... #byte ADCBUF11L = 0xE5C 
.................... #byte ADCBUF10H = 0xE5B 
.................... #byte ADCBUF10L = 0xE5A 
.................... #byte ADCBUF9H = 0xE59 
.................... #byte ADCBUF9L = 0xE58 
.................... #byte ADCBUF8H = 0xE57 
.................... #byte ADCBUF8L = 0xE56 
.................... #byte ADCBUF7H = 0xE55 
.................... #byte ADCBUF7L = 0xE54 
.................... #byte ADCBUF6H = 0xE53 
.................... #byte ADCBUF6L = 0xE52 
.................... #byte ADCBUF5H = 0xE51 
.................... #byte ADCBUF5L = 0xE50 
.................... #byte ADCBUF4H = 0xE4F 
.................... #byte ADCBUF4L = 0xE4E 
.................... #byte ADCBUF3H = 0xE4D 
.................... #byte ADCBUF3L = 0xE4C 
.................... #byte ADCBUF2H = 0xE4B 
.................... #byte ADCBUF2L = 0xE4A 
.................... #byte ADCBUF1H = 0xE49 
.................... #byte ADCBUF1L = 0xE48 
.................... #byte ANCON1 = 0xE47 
.................... #byte ANCON2 = 0xE46 
.................... #bit    ANSEL8 = ANCON2.0 
.................... #bit    ANSEL9 = ANCON2.1 
.................... #bit    ANSEL10 = ANCON2.2 
.................... #bit    ANSEL11 = ANCON2.3 
.................... #bit    ANSEL12 = ANCON2.4 
.................... #bit    ANSEL13 = ANCON2.5 
.................... #bit    ANSEL14 = ANCON2.6 
.................... #bit    ANSEL15 = ANCON2.7 
.................... #byte ANCON3 = 0xE45 
.................... #bit    ANSEL16 = ANCON3.0 
.................... #bit    ANSEL17 = ANCON3.1 
.................... #bit    ANSEL18 = ANCON3.2 
.................... #bit    ANSEL19 = ANCON3.3 
.................... #bit    ANSEL20 = ANCON3.4 
.................... #bit    ANSEL21 = ANCON3.5 
.................... #bit    ANSEL22 = ANCON3.6 
.................... #bit    ANSEL23 = ANCON3.7 
....................  
....................  
.................... #device HIGH_INTS=TRUE 
....................  
.................... //-------------UART and SPI Setting-------------------------------------------------------------------------------------- 
....................  
.................... #pin_select TX1=PIN_C6                                                           //TX PIN EXT +/- 6v 
.................... #pin_select RX1=PIN_C7                                                           //RX PIN EXT +/- 6V 
.................... #use rs232(baud=115200,parity=N,UART1,bits=8,stream=pc)                      // MAIN to Ext +/- 6v 
....................  
.................... #pin_select TX2=PIN_D3 
.................... #pin_select RX2=PIN_D2 
.................... #use rs232(baud=9600,parity=N,UART2,bits=8,stream=com,ERRORS)                           //UART Main to COM PIC 
....................  
.................... #pin_select TX4=PIN_E3   
.................... #pin_select RX4=PIN_F2 
.................... #use rs232(baud=9600,parity=N,UART4,bits=8,stream=reset,ERRORS)                         //UART MAIN to RESET PIC 
*
00640:  BTFSS  FA6.7
00642:  BRA    0640
00644:  MOVLB  E
00646:  MOVFF  EFF,1B
0064A:  MOVFF  EFA,01
0064E:  BTFSS  1B.1
00650:  BRA    0656
00652:  BCF    xFF.4
00654:  BSF    xFF.4
00656:  MOVLB  0
00658:  GOTO   06A2 (RETURN)
*
00BD2:  BTFSS  FA6.6
00BD4:  BRA    0BD2
00BD6:  MOVLB  E
00BD8:  MOVWF  xF9
00BDA:  MOVLB  0
00BDC:  GOTO   0C34 (RETURN)
....................  
.................... #pin_select TX3=PIN_E5   
.................... #pin_select RX3=PIN_E4 
.................... #use rs232(baud=9600,parity=N,UART3,bits=8,stream=fab,ERRORS)                           //UART MAIN to FAB PIC 
*
00786:  BTFSS  FA6.5
00788:  BRA    0786
0078A:  MOVLB  F
0078C:  MOVFF  F2F,1B
00790:  MOVFF  F2A,01
00794:  BTFSS  1B.1
00796:  BRA    079C
00798:  BCF    x2F.4
0079A:  BSF    x2F.4
0079C:  MOVLB  0
0079E:  GOTO   0DD8 (RETURN)
*
0085C:  BTFSS  FA6.4
0085E:  BRA    085C
00860:  MOVLB  F
00862:  MOVWF  x29
00864:  MOVLB  0
00866:  RETURN 0
....................  
....................  
.................... #use rs232(baud=9600,parity=N,xmit=pin_G2,rcv=pin_G3,bits=8,stream=IMGCLS,ERRORS)       //UART MAIN to IMGCLS 
.................... #use rs232(baud=9600,parity=N,xmit=pin_G0,rcv=pin_G1,bits=8,stream=DC,ERRORS)           //UART MAIN to MB DCM 
*
00B1C:  BCF    F98.0
00B1E:  BCF    F8F.0
00B20:  MOVLW  08
00B22:  MOVWF  01
00B24:  BRA    0B26
00B26:  NOP   
00B28:  BSF    01.7
00B2A:  BRA    0B4C
00B2C:  BCF    01.7
00B2E:  MOVLB  2
00B30:  RRCF   x10,F
00B32:  MOVLB  0
00B34:  BTFSC  FD8.0
00B36:  BSF    F8F.0
00B38:  BTFSS  FD8.0
00B3A:  BCF    F8F.0
00B3C:  BSF    01.6
00B3E:  BRA    0B4C
00B40:  BCF    01.6
00B42:  DECFSZ 01,F
00B44:  BRA    0B2E
00B46:  BRA    0B48
00B48:  NOP   
00B4A:  BSF    F8F.0
00B4C:  MOVLW  84
00B4E:  MOVWF  FE9
00B50:  DECFSZ FE9,F
00B52:  BRA    0B50
00B54:  BRA    0B56
00B56:  NOP   
00B58:  BTFSC  01.7
00B5A:  BRA    0B2C
00B5C:  BTFSC  01.6
00B5E:  BRA    0B40
00B60:  RETURN 0
00B62:  BSF    F98.1
00B64:  BTFSC  F86.1
00B66:  BRA    0B64
00B68:  MOVLW  08
00B6A:  MOVWF  00
00B6C:  MOVLB  2
00B6E:  CLRF   x0B
00B70:  BSF    00.7
00B72:  BRA    0B90
00B74:  BCF    00.7
00B76:  BRA    0B90
00B78:  BCF    FD8.0
00B7A:  BTFSC  F86.1
00B7C:  BSF    FD8.0
00B7E:  RRCF   x0B,F
00B80:  BSF    00.6
00B82:  BRA    0B90
00B84:  BCF    00.6
00B86:  DECFSZ 00,F
00B88:  BRA    0B78
00B8A:  MOVFF  20B,01
00B8E:  BRA    0BA8
00B90:  MOVLW  84
00B92:  BTFSC  00.7
00B94:  MOVLW  24
00B96:  MOVWF  01
00B98:  DECFSZ 01,F
00B9A:  BRA    0B98
00B9C:  BRA    0B9E
00B9E:  BTFSC  00.7
00BA0:  BRA    0B74
00BA2:  BTFSC  00.6
00BA4:  BRA    0B84
00BA6:  BRA    0B78
00BA8:  MOVLB  0
00BAA:  GOTO   12C0 (RETURN)
....................  
....................  
.................... #use spi(MASTER, CLK=PIN_E1, DI=PIN_E0, DO=PIN_E6,  BAUD=1000000, BITS=8, STREAM=MAIN_FM, MODE=0)        //MAIN flash memory port 
.................... #use spi(MASTER, CLK=PIN_B2, DI=PIN_B5, DO=PIN_B4,  BAUD=1000000, BITS=8, STREAM=COM_FM, MODE=0)         //COM flash memory port 
.................... #use spi(MASTER, CLK=PIN_A3, DI=PIN_A0, DO=PIN_A1,  BAUD=1000000, BITS=8, STREAM=MISSION_FM, MODE=0)     //MISSION flash memory port 
*
007A2:  MOVLB  2
007A4:  MOVF   x1E,W
007A6:  SUBLW  08
007A8:  BZ    07B2
007AA:  MOVWF  x1F
007AC:  RLCF   x1D,F
007AE:  DECFSZ x1F,F
007B0:  BRA    07AC
007B2:  BSF    F92.0
007B4:  BCF    F92.1
007B6:  BCF    F92.3
007B8:  BCF    F89.3
007BA:  MOVFF  21E,21F
007BE:  BTFSS  x1D.7
007C0:  BCF    F89.1
007C2:  BTFSC  x1D.7
007C4:  BSF    F89.1
007C6:  RLCF   x1D,F
007C8:  BSF    F89.3
007CA:  RLCF   01,F
007CC:  BTFSS  F80.0
007CE:  BCF    01.0
007D0:  BTFSC  F80.0
007D2:  BSF    01.0
007D4:  BCF    F89.3
007D6:  DECFSZ x1F,F
007D8:  BRA    07BE
007DA:  MOVLB  0
007DC:  RETURN 0
....................  
.................... //--------------Pin Assignment--------------------------------------------------------------------------------------------- 
.................... #define sel PIN_D6 
.................... #define hvs PIN_D7 
.................... #define PINO_POWER PIN_D5 
....................  
....................  
.................... //-------------mainpic_function.c----------------------------------------------------------------------------------------- 
....................  
.................... void Check_UART(); 
.................... void waiting(int32 counterval); 
....................  
.................... /////////////CAM MISSION///////////// 
.................... void Turn_On_CAM(); 
.................... void Turn_Off_CAM(); 
....................  
.................... /////////////RESET SENSOR collection///////////// 
.................... void COLLECT_RESET_DATA(); 
....................  
.................... /////////////Testing Stuff///////////// 
.................... void Flash_Memory_Access(); 
.................... void PINO_test(); 
.................... void GET_RESET_DATA(); 
....................  
....................  
.................... #include <mainpic_function.h> 
.................... #include<flash_ memory_ MT25QL01GBBB_OF.c> //all flash memory 
.................... #define SPIPORT MAIN_FM 
.................... #define SPIPORT_2 COM_FM 
.................... #define SPIPORT_3 MISSION_FM 
....................  
.................... #define CS_PIN PIN_E2 
.................... #define CS_PIN_2 PIN_B3 
.................... #define CS_PIN_3 PIN_A2 
....................  
.................... #define READ_ID              0x9F 
.................... #define READ_STATUS_REG      0x05  
.................... #define READ_DATA_BYTES      0x13  //0x03 for byte 
.................... #define ENABLE_WRITE         0x06 
.................... #define WRITE_PAGE           0x12  //0x02 for 3byte 
.................... #define ERASE_SECTOR         0xDC  //0xD8 for 3byte 
.................... #define ERASE_4KB_SUBSECTOR  0x21 
.................... #define ERASE_32KB_SUBSECTOR 0x5C 
.................... #define DIE_ERASE            0xC4 
....................  
....................  
....................  
.................... void WRITE_ENABLE_OF(){ 
....................  output_low(CS_PIN); 
....................   
....................  ///////////////////////////////////////////////////////////// 
....................  //delay_ms(2); 
....................  spi_xfer(SPIPORT,ENABLE_WRITE);                //Send 0x06 
....................  ///////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN);   
....................  return; 
.................... } 
....................  
....................  
.................... void WRITE_ENABLE_SCF(){ 
....................  output_low(CS_PIN_2); 
....................   
....................  ///////////////////////////////////////////////////////////// 
....................  //delay_ms(2); 
....................  spi_xfer(SPIPORT_2,ENABLE_WRITE);                //Send 0x06 
....................  ///////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_2);   
....................  return; 
.................... } 
....................  
....................  
.................... void WRITE_ENABLE_SMF(){ 
....................  output_low(CS_PIN_3); 
*
008DA:  BCF    F92.2
008DC:  BCF    F89.2
....................   
....................  ///////////////////////////////////////////////////////////// 
....................  //delay_ms(2); 
....................  spi_xfer(SPIPORT_3,ENABLE_WRITE);                //Send 0x06 
008DE:  MOVLW  06
008E0:  MOVLB  2
008E2:  MOVWF  x1D
008E4:  MOVLW  08
008E6:  MOVWF  x1E
008E8:  MOVLB  0
008EA:  RCALL  07A2
....................  ///////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_3);   
008EC:  BCF    F92.2
008EE:  BSF    F89.2
....................  return; 
008F0:  RETURN 0
.................... } 
....................  
....................  
.................... void sector_erase_OF(unsigned int32 sector_address)                              //borra un sector de la flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_OF(); 
....................    output_low(CS_PIN);                                                           //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT,ERASE_SECTOR);                                               //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT,adsress[0]);    
....................    spi_xfer(SPIPORT,adsress[1]);     
....................    spi_xfer(SPIPORT,adsress[2]);     
....................    spi_xfer(SPIPORT,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN);                                                          //take CS PIN higher back 
....................    //delay_ms(1000); 
....................    delay_ms(750); 
....................     
....................    return; 
.................... } 
....................  
....................  
.................... void sector_erase_SCF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_SCF(); 
....................    output_low(CS_PIN_2);                                                         //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_2,ERASE_SECTOR);                                             //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT_2,adsress[0]);    
....................    spi_xfer(SPIPORT_2,adsress[1]);     
....................    spi_xfer(SPIPORT_2,adsress[2]);     
....................    spi_xfer(SPIPORT_2,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN_2);                                                        //take CS PIN higher back 
....................    //delay_ms(1000); 
....................    delay_ms(750); 
....................     
....................    return; 
.................... } 
....................  
....................  
.................... void sector_erase_SMF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
008F2:  MOVLB  2
008F4:  MOVFF  20A,20B
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
008F8:  MOVFF  209,20C
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
008FC:  MOVFF  208,20D
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);       // 0x 00 00 00 _ _ 
00900:  MOVFF  207,20E
....................     
....................     
....................    WRITE_ENABLE_SMF(); 
00904:  MOVLB  0
00906:  RCALL  08DA
....................    output_low(CS_PIN_3);             //lower the CS PIN 
00908:  BCF    F92.2
0090A:  BCF    F89.2
....................    delay_us(2); 
0090C:  MOVLW  02
0090E:  MOVWF  00
00910:  DECFSZ 00,F
00912:  BRA    0910
00914:  NOP   
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,ERASE_SECTOR); //SECTOR ERASE COMAND   (0xDC) 
00916:  MOVLW  DC
00918:  MOVLB  2
0091A:  MOVWF  x1D
0091C:  MOVLW  08
0091E:  MOVWF  x1E
00920:  MOVLB  0
00922:  RCALL  07A2
....................     
....................    spi_xfer(SPIPORT_3,adsress[0]);    
00924:  MOVFF  20B,21D
00928:  MOVLW  08
0092A:  MOVLB  2
0092C:  MOVWF  x1E
0092E:  MOVLB  0
00930:  RCALL  07A2
....................    spi_xfer(SPIPORT_3,adsress[1]);     
00932:  MOVFF  20C,21D
00936:  MOVLW  08
00938:  MOVLB  2
0093A:  MOVWF  x1E
0093C:  MOVLB  0
0093E:  RCALL  07A2
....................    spi_xfer(SPIPORT_3,adsress[2]);     
00940:  MOVFF  20D,21D
00944:  MOVLW  08
00946:  MOVLB  2
00948:  MOVWF  x1E
0094A:  MOVLB  0
0094C:  RCALL  07A2
....................    spi_xfer(SPIPORT_3,adsress[3]); 
0094E:  MOVFF  20E,21D
00952:  MOVLW  08
00954:  MOVLB  2
00956:  MOVWF  x1E
00958:  MOVLB  0
0095A:  RCALL  07A2
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
0095C:  MOVLW  02
0095E:  MOVWF  00
00960:  DECFSZ 00,F
00962:  BRA    0960
00964:  NOP   
....................    output_high(CS_PIN_3);           //take CS PIN higher back 
00966:  BCF    F92.2
00968:  BSF    F89.2
....................    //delay_ms(1000);   
....................    delay_ms(750); 
0096A:  MOVLW  03
0096C:  MOVLB  2
0096E:  MOVWF  x0F
00970:  MOVLW  FA
00972:  MOVWF  x10
00974:  MOVLB  0
00976:  RCALL  072E
00978:  MOVLB  2
0097A:  DECFSZ x0F,F
0097C:  BRA    0970
....................    return; 
0097E:  MOVLB  0
00980:  GOTO   0FD4 (RETURN)
.................... } 
....................  
....................  
.................... void SUBSECTOR_4KB_ERASE_OF(unsigned int32 sector_address)                       //Funcion que borra un sector de 4KB de la Main Flash 
.................... {                                                                                //Recibe la direccion del sector que se quiere borrar 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_OF();                                                            //Funcion que habilita escritura en Own Flash 
....................    output_low(CS_PIN);                                                           //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT,ERASE_4KB_SUBSECTOR);                                        //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT,adsress[0]);                                                 //Se le pasa la direccion del sector a borrar 
....................    spi_xfer(SPIPORT,adsress[1]);     
....................    spi_xfer(SPIPORT,adsress[2]);     
....................    spi_xfer(SPIPORT,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN);                                                          //take CS PIN higher back 
....................    delay_ms(100);   
....................     
....................    return; 
.................... } 
....................  
....................  
.................... void SUBSECTOR_4KB_ERASE_SCF(unsigned int32 sector_address)                      //Funcion que borra un sector de 4KB de la COM Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_SCF();                                                           //Funcion que habilita escritura en COM Flash 
....................    output_low(CS_PIN_2);                                                         //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_2,ERASE_4KB_SUBSECTOR); //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT_2,adsress[0]);    
....................    spi_xfer(SPIPORT_2,adsress[1]);     
....................    spi_xfer(SPIPORT_2,adsress[2]);     
....................    spi_xfer(SPIPORT_2,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN_2);                                                        //take CS PIN higher back 
....................    delay_ms(10);   
....................     
....................    return; 
.................... } 
....................  
....................  
.................... void SUBSECTOR_4KB_ERASE_SMF(unsigned int32 sector_address)                      //Funcion que borra un sector de 4KB de la Mission Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);                   // 0x _ _ 00 00 00 
*
009F8:  MOVLB  2
009FA:  MOVFF  20A,20B
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);                   // 0x 00 _ _ 00 00 
009FE:  MOVFF  209,20C
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);                    // 0x 00 00 _ _ 00 
00A02:  MOVFF  208,20D
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);                       // 0x 00 00 00 _ _ 
00A06:  MOVFF  207,20E
....................     
....................     
....................    WRITE_ENABLE_SMF();                                                           //Funcion que habilita escritura en Mission Flash 
00A0A:  MOVLB  0
00A0C:  RCALL  08DA
....................    output_low(CS_PIN_3);                                                         //lower the CS PIN 
00A0E:  BCF    F92.2
00A10:  BCF    F89.2
....................    delay_us(2); 
00A12:  MOVLW  02
00A14:  MOVWF  00
00A16:  DECFSZ 00,F
00A18:  BRA    0A16
00A1A:  NOP   
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,ERASE_4KB_SUBSECTOR);                                      //SECTOR ERASE COMAND   (0xDC) 
00A1C:  MOVLW  21
00A1E:  MOVLB  2
00A20:  MOVWF  x1D
00A22:  MOVLW  08
00A24:  MOVWF  x1E
00A26:  MOVLB  0
00A28:  RCALL  07A2
....................     
....................    spi_xfer(SPIPORT_3,adsress[0]);    
00A2A:  MOVFF  20B,21D
00A2E:  MOVLW  08
00A30:  MOVLB  2
00A32:  MOVWF  x1E
00A34:  MOVLB  0
00A36:  RCALL  07A2
....................    spi_xfer(SPIPORT_3,adsress[1]);     
00A38:  MOVFF  20C,21D
00A3C:  MOVLW  08
00A3E:  MOVLB  2
00A40:  MOVWF  x1E
00A42:  MOVLB  0
00A44:  RCALL  07A2
....................    spi_xfer(SPIPORT_3,adsress[2]);     
00A46:  MOVFF  20D,21D
00A4A:  MOVLW  08
00A4C:  MOVLB  2
00A4E:  MOVWF  x1E
00A50:  MOVLB  0
00A52:  RCALL  07A2
....................    spi_xfer(SPIPORT_3,adsress[3]); 
00A54:  MOVFF  20E,21D
00A58:  MOVLW  08
00A5A:  MOVLB  2
00A5C:  MOVWF  x1E
00A5E:  MOVLB  0
00A60:  RCALL  07A2
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
00A62:  MOVLW  02
00A64:  MOVWF  00
00A66:  DECFSZ 00,F
00A68:  BRA    0A66
00A6A:  NOP   
....................    output_high(CS_PIN_3);                                                        //take CS PIN higher back 
00A6C:  BCF    F92.2
00A6E:  BSF    F89.2
....................    delay_ms(1000);   
00A70:  MOVLW  04
00A72:  MOVLB  2
00A74:  MOVWF  x0F
00A76:  MOVLW  FA
00A78:  MOVWF  x10
00A7A:  MOVLB  0
00A7C:  RCALL  072E
00A7E:  MOVLB  2
00A80:  DECFSZ x0F,F
00A82:  BRA    0A76
....................     
....................    return; 
00A84:  MOVLB  0
00A86:  GOTO   1184 (RETURN)
.................... } 
....................  
....................  
.................... void SUBSECTOR_32KB_ERASE_OF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_OF(); 
....................    output_low(CS_PIN);             //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT,ERASE_32KB_SUBSECTOR); //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT,adsress[0]);    
....................    spi_xfer(SPIPORT,adsress[1]);     
....................    spi_xfer(SPIPORT,adsress[2]);     
....................    spi_xfer(SPIPORT,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN);           //take CS PIN higher back 
....................    delay_ms(1000);   
....................     
....................    return; 
.................... } 
....................  
....................  
.................... void SUBSECTOR_32KB_ERASE_SCF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);       // 0x 00 00 00 _ _ 
....................     
....................     
....................    WRITE_ENABLE_SCF(); 
....................    output_low(CS_PIN_2);             //lower the CS PIN 
....................    delay_us(2); 
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_2,ERASE_32KB_SUBSECTOR); //SECTOR ERASE COMAND   (0xDC) 
....................     
....................    spi_xfer(SPIPORT_2,adsress[0]);    
....................    spi_xfer(SPIPORT_2,adsress[1]);     
....................    spi_xfer(SPIPORT_2,adsress[2]);     
....................    spi_xfer(SPIPORT_2,adsress[3]); 
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
....................    output_high(CS_PIN_2);           //take CS PIN higher back 
....................    delay_ms(1000);   
....................     
....................    return; 
.................... } 
....................  
....................  
.................... void SUBSECTOR_32KB_ERASE_SMF(unsigned int32 sector_address) 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    adsress[0]  = (unsigned int8)((sector_address>>24) & 0xFF);   // 0x _ _ 00 00 00 
00A8A:  MOVLB  2
00A8C:  MOVFF  20A,20B
....................    adsress[1]  = (unsigned int8)((sector_address>>16) & 0xFF);   // 0x 00 _ _ 00 00 
00A90:  MOVFF  209,20C
....................    adsress[2]  = (unsigned int8)((sector_address>>8) & 0xFF);    // 0x 00 00 _ _ 00 
00A94:  MOVFF  208,20D
....................    adsress[3]  = (unsigned int8)((sector_address) & 0xFF);       // 0x 00 00 00 _ _ 
00A98:  MOVFF  207,20E
....................     
....................     
....................    WRITE_ENABLE_SMF(); 
00A9C:  MOVLB  0
00A9E:  RCALL  08DA
....................    output_low(CS_PIN_3);             //lower the CS PIN 
00AA0:  BCF    F92.2
00AA2:  BCF    F89.2
....................    delay_us(2); 
00AA4:  MOVLW  02
00AA6:  MOVWF  00
00AA8:  DECFSZ 00,F
00AAA:  BRA    0AA8
00AAC:  NOP   
....................     
....................    /////////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,ERASE_32KB_SUBSECTOR); //SECTOR ERASE COMAND   (0xDC) 
00AAE:  MOVLW  5C
00AB0:  MOVLB  2
00AB2:  MOVWF  x1D
00AB4:  MOVLW  08
00AB6:  MOVWF  x1E
00AB8:  MOVLB  0
00ABA:  RCALL  07A2
....................     
....................    spi_xfer(SPIPORT_3,adsress[0]);    
00ABC:  MOVFF  20B,21D
00AC0:  MOVLW  08
00AC2:  MOVLB  2
00AC4:  MOVWF  x1E
00AC6:  MOVLB  0
00AC8:  RCALL  07A2
....................    spi_xfer(SPIPORT_3,adsress[1]);     
00ACA:  MOVFF  20C,21D
00ACE:  MOVLW  08
00AD0:  MOVLB  2
00AD2:  MOVWF  x1E
00AD4:  MOVLB  0
00AD6:  RCALL  07A2
....................    spi_xfer(SPIPORT_3,adsress[2]);     
00AD8:  MOVFF  20D,21D
00ADC:  MOVLW  08
00ADE:  MOVLB  2
00AE0:  MOVWF  x1E
00AE2:  MOVLB  0
00AE4:  RCALL  07A2
....................    spi_xfer(SPIPORT_3,adsress[3]); 
00AE6:  MOVFF  20E,21D
00AEA:  MOVLW  08
00AEC:  MOVLB  2
00AEE:  MOVWF  x1E
00AF0:  MOVLB  0
00AF2:  RCALL  07A2
....................    ////////////////////////////////////////////////////////////////// 
....................     
....................    delay_us(2); 
00AF4:  MOVLW  02
00AF6:  MOVWF  00
00AF8:  DECFSZ 00,F
00AFA:  BRA    0AF8
00AFC:  NOP   
....................    output_high(CS_PIN_3);           //take CS PIN higher back 
00AFE:  BCF    F92.2
00B00:  BSF    F89.2
....................    delay_ms(1000);   
00B02:  MOVLW  04
00B04:  MOVLB  2
00B06:  MOVWF  x0F
00B08:  MOVLW  FA
00B0A:  MOVWF  x10
00B0C:  MOVLB  0
00B0E:  RCALL  072E
00B10:  MOVLB  2
00B12:  DECFSZ x0F,F
00B14:  BRA    0B08
....................     
....................    return; 
00B16:  MOVLB  0
00B18:  GOTO   1196 (RETURN)
.................... } 
....................  
....................  
.................... void ALL_SECTOR_ERASE_OF() 
.................... { 
....................    int32 ADDRESS = 0; 
....................    for(int16 i = 0; i < 2048; i++) 
....................    { 
....................       sector_erase_OF(ADDRESS); 
....................       ADDRESS = ADDRESS + 65536; 
....................    } 
.................... } 
....................  
....................  
.................... void ALL_SECTOR_ERASE_SCF() 
.................... { 
....................    int32 ADRESS = 0; 
....................    for(int16 i = 0; i < 2048; i++) 
....................    { 
....................       sector_erase_SCF(ADRESS); 
....................       ADRESS = ADRESS + 65536; 
....................    } 
.................... } 
....................  
....................  
.................... void ALL_SECTOR_ERASE_SMF() 
.................... { 
....................    int32 ADRESS = 0; 
....................    for(int16 i = 0; i < 2048; i++) 
....................    { 
....................       sector_erase_SMF(ADRESS); 
....................       ADRESS = ADRESS + 65536; 
....................    } 
.................... } 
....................  
....................  
.................... void WRITE_DATA_BYTE_OF(unsigned int32 page_address, int8 data)                  //Funcion que escribe un Byte en la Main Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((page_address>>24) & 0xFF);                     // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((page_address>>16) & 0xFF);                     // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((page_address>>8) & 0xFF);                      // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((page_address) & 0xFF);                         // 0x 00 00 00 _ _ 
....................     
....................    WRITE_ENABLE_OF(); 
....................    output_low(CS_PIN);                                                           //lower the CS PIN 
....................    //delay_us(2); 
....................     
....................    //////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT,WRITE_PAGE);                                                 //PAGE WRITE COMAND  (0x12) 
....................    
....................    spi_xfer(SPIPORT,adsress[0]);     
....................    spi_xfer(SPIPORT,adsress[1]);     
....................    spi_xfer(SPIPORT,adsress[2]);     
....................    spi_xfer(SPIPORT,adsress[3]); 
....................     
....................    spi_xfer(SPIPORT,data);  
....................    //////////////////////////////////////////////////////////////// 
....................     
....................    output_high(CS_PIN);                                                          //take CS PIN higher back 
....................  
....................    //delay_us(5);   
....................     
....................    return; 
.................... } 
....................  
....................  
.................... void WRITE_DATA_BYTE_SCF(unsigned int32 page_address, int8 data)                 //Funcion que escribe un Byte en la COM Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((page_address>>24) & 0xFF);                     // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((page_address>>16) & 0xFF);                     // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((page_address>>8) & 0xFF);                      // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((page_address) & 0xFF);                         // 0x 00 00 00 _ _ 
....................     
....................    WRITE_ENABLE_SCF(); 
....................    output_low(CS_PIN_2);                                                         //lower the CS PIN 
....................    //delay_us(2); 
....................     
....................    //////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_2,WRITE_PAGE);                                               //PAGE WRITE COMAND  (0x12) 
....................    
....................    spi_xfer(SPIPORT_2,adsress[0]);     
....................    spi_xfer(SPIPORT_2,adsress[1]);     
....................    spi_xfer(SPIPORT_2,adsress[2]);     
....................    spi_xfer(SPIPORT_2,adsress[3]); 
....................     
....................    spi_xfer(SPIPORT_2,data);  
....................    //////////////////////////////////////////////////////////////// 
....................     
....................    output_high(CS_PIN_2);                                                        //take CS PIN higher back 
....................  
....................    //delay_us(5);   
....................     
....................    return; 
.................... } 
....................  
....................  
.................... void WRITE_DATA_BYTE_SMF(unsigned int32 page_address, int8 data)                 //Funcion que escribe un Byte en la Mission Flash 
.................... { 
....................    unsigned int8 adsress[4]; 
....................     
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((page_address>>24) & 0xFF);                     // 0x _ _ 00 00 00 
*
00984:  MOVLB  2
00986:  MOVFF  20E,210
....................    adsress[1]  = (unsigned int8)((page_address>>16) & 0xFF);                     // 0x 00 _ _ 00 00 
0098A:  MOVFF  20D,211
....................    adsress[2]  = (unsigned int8)((page_address>>8) & 0xFF);                      // 0x 00 00 _ _ 00 
0098E:  MOVFF  20C,212
....................    adsress[3]  = (unsigned int8)((page_address) & 0xFF);                         // 0x 00 00 00 _ _ 
00992:  MOVFF  20B,213
....................     
....................    WRITE_ENABLE_SMF(); 
00996:  MOVLB  0
00998:  RCALL  08DA
....................    output_low(CS_PIN_3);                                                         //lower the CS PIN 
0099A:  BCF    F92.2
0099C:  BCF    F89.2
....................    //delay_us(2); 
....................     
....................    //////////////////////////////////////////////////////////////// 
....................    spi_xfer(SPIPORT_3,WRITE_PAGE);                                               //PAGE WRITE COMAND  (0x12) 
0099E:  MOVLW  12
009A0:  MOVLB  2
009A2:  MOVWF  x1D
009A4:  MOVLW  08
009A6:  MOVWF  x1E
009A8:  MOVLB  0
009AA:  RCALL  07A2
....................    
....................    spi_xfer(SPIPORT_3,adsress[0]);     
009AC:  MOVFF  210,21D
009B0:  MOVLW  08
009B2:  MOVLB  2
009B4:  MOVWF  x1E
009B6:  MOVLB  0
009B8:  RCALL  07A2
....................    spi_xfer(SPIPORT_3,adsress[1]);     
009BA:  MOVFF  211,21D
009BE:  MOVLW  08
009C0:  MOVLB  2
009C2:  MOVWF  x1E
009C4:  MOVLB  0
009C6:  RCALL  07A2
....................    spi_xfer(SPIPORT_3,adsress[2]);     
009C8:  MOVFF  212,21D
009CC:  MOVLW  08
009CE:  MOVLB  2
009D0:  MOVWF  x1E
009D2:  MOVLB  0
009D4:  RCALL  07A2
....................    spi_xfer(SPIPORT_3,adsress[3]); 
009D6:  MOVFF  213,21D
009DA:  MOVLW  08
009DC:  MOVLB  2
009DE:  MOVWF  x1E
009E0:  MOVLB  0
009E2:  RCALL  07A2
....................     
....................    spi_xfer(SPIPORT_3,data);  
009E4:  MOVFF  20F,21D
009E8:  MOVLW  08
009EA:  MOVLB  2
009EC:  MOVWF  x1E
009EE:  MOVLB  0
009F0:  RCALL  07A2
....................    //////////////////////////////////////////////////////////////// 
....................     
....................    output_high(CS_PIN_3);                                                        //take CS PIN higher back 
009F2:  BCF    F92.2
009F4:  BSF    F89.2
....................  
....................    //delay_us(10);   
....................     
....................    return; 
009F6:  RETURN 0
.................... } 
....................  
....................  
.................... int8 READ_CHIP_ID_OF() 
.................... { 
....................  output_low(CS_PIN);           //lower the CS PIN 
....................   
....................  //////////////////////////////////////////////////////////////// 
....................  int8 chip_id; 
....................  spi_xfer(SPIPORT,READ_ID);    //READ ID COMAND   (0x9F) 
....................  chip_id = spi_xfer(SPIPORT); 
....................  //////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN);         //take CS PIN higher back 
....................  return chip_id; 
.................... } 
....................  
....................  
.................... int8 READ_CHIP_ID_SCF() 
.................... { 
....................  output_low(CS_PIN_2);           //lower the CS PIN 
....................   
....................  //////////////////////////////////////////////////////////////// 
....................  int8 chip_id; 
....................  spi_xfer(SPIPORT_2,READ_ID);    //READ ID COMAND   (0x9F) 
....................  chip_id = spi_xfer(SPIPORT_2); 
....................  //////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_2);         //take CS PIN higher back 
....................  return chip_id; 
.................... } 
....................  
....................  
.................... int8 READ_CHIP_ID_SMF() 
.................... { 
....................  output_low(CS_PIN_3);           //lower the CS PIN 
....................   
....................  //////////////////////////////////////////////////////////////// 
....................  int8 chip_id; 
....................  spi_xfer(SPIPORT_3,READ_ID);    //READ ID COMAND   (0x9F) 
....................  chip_id = spi_xfer(SPIPORT_3); 
....................  //////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_3);         //take CS PIN higher back 
....................  return chip_id; 
.................... } 
....................  
....................  
.................... int8 READ_STATUS_REGISTER_OF() 
.................... { 
....................  output_low(CS_PIN);           //lower the CS PIN 
....................   
....................  ///////////////////////////////////////////////////////////////// 
....................  int8 status_reg; 
....................  spi_xfer(SPIPORT,READ_STATUS_REG); //READ STATUS REGISTER COMAND  (0x05) 
....................  status_reg = spi_xfer(SPIPORT); 
....................  ///////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN);         //take CS PIN higher back 
....................  return status_reg; 
.................... } 
....................  
....................  
.................... int8 READ_STATUS_REGISTER_SCF() 
.................... { 
....................  output_low(CS_PIN_2);           //lower the CS PIN 
....................   
....................  ///////////////////////////////////////////////////////////////// 
....................  int8 status_reg; 
....................  spi_xfer(SPIPORT_2,READ_STATUS_REG); //READ STATUS REGISTER COMAND  (0x05) 
....................  status_reg = spi_xfer(SPIPORT_2); 
....................  ///////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_2);         //take CS PIN higher back 
....................  return status_reg; 
.................... } 
.................... int8 READ_STATUS_REGISTER_SMF() 
.................... { 
....................  output_low(CS_PIN_3);           //lower the CS PIN 
....................   
....................  ///////////////////////////////////////////////////////////////// 
....................  int8 status_reg; 
....................  spi_xfer(SPIPORT_3,READ_STATUS_REG); //READ STATUS REGISTER COMAND  (0x05) 
....................  status_reg = spi_xfer(SPIPORT_3); 
....................  ///////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_3);         //take CS PIN higher back 
....................  return status_reg; 
.................... } 
....................  
....................  
.................... int8 READ_DATA_BYTE_OF(unsigned INT32 ADDRESS) 
.................... { 
....................  
....................  unsigned int8 address_OF[4]; 
....................    //Byte extraction 
....................    address_OF[0]  = (unsigned int8)((ADDRESS>>24) & 0xFF);                          // 0x _ _ 00 00 00 
....................    address_OF[1]  = (unsigned int8)((ADDRESS>>16) & 0xFF);                          // 0x 00 _ _ 00 00 
....................    address_OF[2]  = (unsigned int8)((ADDRESS>>8) & 0xFF);                           // 0x 00 00 _ _ 00 
....................    address_OF[3]  = (unsigned int8)((ADDRESS) & 0xFF);                              // 0x 00 00 00 _ _ 
....................     
....................  output_low(CS_PIN);                                                             //lower the CS PIN 
....................   
....................  ////////////////////////////////////////////////////////////////// 
....................  int8 data; 
....................  spi_xfer(SPIPORT,READ_DATA_BYTES);                                              //READ DATA COMAND   (0x13) 
....................   
....................  spi_xfer(SPIPORT,address_OF[0]); 
....................  spi_xfer(SPIPORT,address_OF[1]); 
....................  spi_xfer(SPIPORT,address_OF[2]); 
....................  spi_xfer(SPIPORT,address_OF[3]); 
....................  data = spi_xfer(SPIPORT); 
....................  ////////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN);                                                            //take CS PIN higher back 
....................  return data; 
....................   
.................... } 
....................  
....................  
.................... int8 READ_DATA_BYTE_SCF(unsigned INT32 ADDRESS) 
.................... { 
....................  
....................  unsigned int8 adsress[4]; 
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((ADDRESS>>24) & 0xFF);                          // 0x _ _ 00 00 00 
....................    adsress[1]  = (unsigned int8)((ADDRESS>>16) & 0xFF);                          // 0x 00 _ _ 00 00 
....................    adsress[2]  = (unsigned int8)((ADDRESS>>8) & 0xFF);                           // 0x 00 00 _ _ 00 
....................    adsress[3]  = (unsigned int8)((ADDRESS) & 0xFF);                              // 0x 00 00 00 _ _ 
....................     
....................  output_low(CS_PIN_2);                                                           //lower the CS PIN 
....................   
....................  ////////////////////////////////////////////////////////////////// 
....................  int8 data; 
....................  spi_xfer(SPIPORT_2,READ_DATA_BYTES);                                            //READ DATA COMAND   (0x13) 
....................   
....................  spi_xfer(SPIPORT_2,adsress[0]); 
....................  spi_xfer(SPIPORT_2,adsress[1]); 
....................  spi_xfer(SPIPORT_2,adsress[2]); 
....................  spi_xfer(SPIPORT_2,adsress[3]); 
....................  data = spi_xfer(SPIPORT_2); 
....................  ////////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_2);                                                          //take CS PIN higher back 
....................  return data; 
....................   
.................... } 
....................  
....................  
.................... int8 READ_DATA_BYTE_SMF(unsigned INT32 ADDRESS) 
.................... { 
....................  
....................  unsigned int8 adsress[4]; 
....................    //Byte extraction 
....................    adsress[0]  = (unsigned int8)((ADDRESS>>24) & 0xFF);                          // 0x _ _ 00 00 00 
*
007DE:  MOVLB  2
007E0:  MOVFF  217,218
....................    adsress[1]  = (unsigned int8)((ADDRESS>>16) & 0xFF);                          // 0x 00 _ _ 00 00 
007E4:  MOVFF  216,219
....................    adsress[2]  = (unsigned int8)((ADDRESS>>8) & 0xFF);                           // 0x 00 00 _ _ 00 
007E8:  MOVFF  215,21A
....................    adsress[3]  = (unsigned int8)((ADDRESS) & 0xFF);                              // 0x 00 00 00 _ _ 
007EC:  MOVFF  214,21B
....................     
....................  output_low(CS_PIN_3);                                                           //lower the CS PIN 
007F0:  BCF    F92.2
007F2:  BCF    F89.2
....................   
....................  ////////////////////////////////////////////////////////////////// 
....................  int8 data; 
....................  spi_xfer(SPIPORT_3,READ_DATA_BYTES);                                            //READ DATA COMAND   (0x13) 
007F4:  MOVLW  13
007F6:  MOVWF  x1D
007F8:  MOVLW  08
007FA:  MOVWF  x1E
007FC:  MOVLB  0
007FE:  RCALL  07A2
....................   
....................  spi_xfer(SPIPORT_3,adsress[0]); 
00800:  MOVFF  218,21D
00804:  MOVLW  08
00806:  MOVLB  2
00808:  MOVWF  x1E
0080A:  MOVLB  0
0080C:  RCALL  07A2
....................  spi_xfer(SPIPORT_3,adsress[1]); 
0080E:  MOVFF  219,21D
00812:  MOVLW  08
00814:  MOVLB  2
00816:  MOVWF  x1E
00818:  MOVLB  0
0081A:  RCALL  07A2
....................  spi_xfer(SPIPORT_3,adsress[2]); 
0081C:  MOVFF  21A,21D
00820:  MOVLW  08
00822:  MOVLB  2
00824:  MOVWF  x1E
00826:  MOVLB  0
00828:  RCALL  07A2
....................  spi_xfer(SPIPORT_3,adsress[3]); 
0082A:  MOVFF  21B,21D
0082E:  MOVLW  08
00830:  MOVLB  2
00832:  MOVWF  x1E
00834:  MOVLB  0
00836:  RCALL  07A2
....................  data = spi_xfer(SPIPORT_3); 
00838:  MOVLW  03
0083A:  MOVLB  2
0083C:  MOVWF  x1D
0083E:  MOVLW  08
00840:  MOVWF  x1E
00842:  MOVLB  0
00844:  RCALL  07A2
00846:  MOVF   01,W
00848:  MOVFF  01,21C
....................  ////////////////////////////////////////////////////////////////// 
....................   
....................  output_high(CS_PIN_3);                                                          //take CS PIN higher back 
0084C:  BCF    F92.2
0084E:  BSF    F89.2
....................  return data; 
00850:  MOVLB  2
00852:  MOVFF  21C,01
00856:  MOVLB  0
00858:  GOTO   08A4 (RETURN)
....................   
.................... } 
....................  
....................  
.................... /* 
.................... void TRANSFER_DATA_256byte_OF(unsigned INT32 ADRESS, int PORT_NUM) //read and send the specified data 
.................... { 
....................    unsigned long int i; 
....................     
....................    switch(PORT_NUM) 
....................    { 
....................       case 1: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_OF(ADRESS),PC); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................       case 2: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_OF(ADRESS),reset); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................       case 3: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_OF(ADRESS),com); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................    } 
....................    return;  
.................... } 
.................... void TRANSFER_DATA_256byte_SCF(unsigned INT32 ADRESS, int PORT_NUM) //read and send the specified data 
.................... { 
....................    unsigned long int i; 
....................     
....................    switch(PORT_NUM) 
....................    { 
....................       case 1: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_SCF(ADRESS),PC); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................       case 2: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_SCF(ADRESS),reset); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................       case 3: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_SCF(ADRESS),com); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................    } 
....................     return;   
.................... } 
.................... void TRANSFER_DATA_256byte_SMF(unsigned INT32 ADRESS, int PORT_NUM) //read and send the specified data 
.................... { 
....................    unsigned long int i; 
....................     
....................    switch(PORT_NUM) 
....................    { 
....................       case 1: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_SMF(ADRESS),PC); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................       case 2: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_SMF(ADRESS),reset); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................       case 3: 
....................          for (i=0 ; i < 256 ; i++) 
....................          { 
....................             fputc(READ_DATA_BYTE_SMF(ADRESS),com); 
....................             ADRESS++; 
....................          } 
....................          break; 
....................    } 
....................     return;   
.................... } 
....................  
.................... void WRITE_DATA_NBYTE_OF(unsigned INT32 ADDRES,int32 data_byte) //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(ADDRES,0x77); 
....................       ADDRES++; 
....................    } 
....................    return; 
.................... } 
.................... void WRITE_DATA_NBYTE_SCF(unsigned INT32 ADDRES,int32 data_byte) //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(ADDRES,0x69); 
....................       ADDRES++; 
....................    } 
....................    return; 
.................... } 
.................... void WRITE_DATA_NBYTE_SMF(unsigned INT32 ADDRES,int32 data_byte) //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(ADDRES,0x55); 
....................       ADDRES++; 
....................    } 
....................    return; 
.................... } 
.................... */ 
....................  
....................  
.................... void TRANSFER_DATA_NBYTE_TOPC_OF(unsigned INT32 ADDRESS,int32 data_byte)          //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       fputc(READ_DATA_BYTE_OF(ADDRESS),PC); 
....................       ADDRESS++; 
....................    } 
....................    return; 
.................... } 
....................  
....................  
.................... void TRANSFER_DATA_NBYTE_TOPC_SCF(unsigned INT32 ADRESS,int32 data_byte)         //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       fprintf(PC,"%x",READ_DATA_BYTE_SCF(ADRESS)); 
....................       ADRESS++; 
....................    } 
....................    return; 
.................... } 
....................  
....................  
.................... void TRANSFER_DATA_NBYTE_TOPC_SMF(unsigned INT32 ADRESS,int32 data_byte)         //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       fputc(READ_DATA_BYTE_SMF(ADRESS),PC); 
....................       ADRESS++; 
....................    } 
....................    return; 
.................... } 
....................  
.................... void TRANSFER_DATA_NBYTE_TOFAB_SMF(unsigned INT32 ADRESS,int32 data_byte)         //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
*
00868:  MOVLB  2
0086A:  CLRF   x13
0086C:  CLRF   x12
0086E:  CLRF   x11
00870:  CLRF   x10
00872:  MOVF   x13,W
00874:  SUBWF  x0F,W
00876:  BNC   08D4
00878:  BNZ   0890
0087A:  MOVF   x12,W
0087C:  SUBWF  x0E,W
0087E:  BNC   08D4
00880:  BNZ   0890
00882:  MOVF   x11,W
00884:  SUBWF  x0D,W
00886:  BNC   08D4
00888:  BNZ   0890
0088A:  MOVF   x0C,W
0088C:  SUBWF  x10,W
0088E:  BC    08D4
....................    { 
....................       fputc(READ_DATA_BYTE_SMF(ADRESS),fab); 
00890:  MOVFF  20B,217
00894:  MOVFF  20A,216
00898:  MOVFF  209,215
0089C:  MOVFF  208,214
008A0:  MOVLB  0
008A2:  BRA    07DE
008A4:  MOVFF  01,214
008A8:  MOVLB  2
008AA:  MOVF   x14,W
008AC:  MOVLB  0
008AE:  RCALL  085C
....................       ADRESS++; 
008B0:  MOVLW  01
008B2:  MOVLB  2
008B4:  ADDWF  x08,F
008B6:  BTFSC  FD8.0
008B8:  INCF   x09,F
008BA:  BTFSC  FD8.2
008BC:  INCF   x0A,F
008BE:  BTFSC  FD8.2
008C0:  INCF   x0B,F
008C2:  MOVLW  01
008C4:  ADDWF  x10,F
008C6:  BTFSC  FD8.0
008C8:  INCF   x11,F
008CA:  BTFSC  FD8.2
008CC:  INCF   x12,F
008CE:  BTFSC  FD8.2
008D0:  INCF   x13,F
008D2:  BRA    0872
....................    } 
....................    return; 
008D4:  MOVLB  0
008D6:  GOTO   0F04 (RETURN)
.................... } 
....................  
....................  
.................... /* 
.................... void TRANSFER_DATA_NBYTE_OFtoSCF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from MAIN FLASH to COM FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(TO_ADRESS,READ_DATA_BYTE_OF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... } 
.................... void TRANSFER_DATA_NBYTE_SCFtoOF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from COM FLASH to MAIN FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(TO_ADRESS,READ_DATA_BYTE_SCF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... } 
.................... void TRANSFER_DATA_NBYTE_OFtoSMF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from MAIN FLASH to MISSION FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(TO_ADRESS,READ_DATA_BYTE_OF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... }*/ 
....................  
....................  
.................... void TRANSFER_DATA_NBYTE_SMFtoOF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from MISSION FLASH to MAIN FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(TO_ADRESS,READ_DATA_BYTE_SMF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... } 
....................  
....................  
.................... void TRANSFER_DATA_NBYTE_SMFtoSCF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from MISSION FLASH to COM FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(TO_ADRESS,READ_DATA_BYTE_SMF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... }/* 
.................... void TRANSFER_DATA_NBYTE_SCFtoSMF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //transfer data from COM FLASH to MISSION FLASH 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(TO_ADRESS,READ_DATA_BYTE_SCF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... } 
.................... void TRANSFER_DATA_NBYTE_SCF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte) //read and send the specified data 
.................... { 
....................    for (int32 i=0 ; i < data_byte ; i++) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(TO_ADRESS,READ_DATA_BYTE_SCF(FROM_ADRESS)); 
....................       FROM_ADRESS++; 
....................       TO_ADRESS++; 
....................    } 
....................    return; 
.................... } 
.................... */ 
....................  
....................  
....................  
.................... #include<MEMORY_OPERATION.c> 
.................... //-------------------------ADDRESS (PREVIOUS)---------------------------------- 
.................... //!/////////////////previous////////////////////////////// 
.................... //!Static int32 ADCS_SENSOR_ADDRESS = 65536*500; 
.................... //!Static int32 FAB_HK_ADDRESS = 65536 * 200; 
.................... //!Static int32 FAB_CW_ADDRESS = 65536 * 50; 
.................... //!Static int32 FAB_CW_ADDRESS_FOR_MF = 65536; //sector1 
.................... //!Static int32 HIGH_SAMP_HK_ADDRESS = 65536 * 1800; 
.................... //!Static int32 CAM_ADDRESS = 65536; 
.................... //!Static int32 DC_STATUS_ADDRESS = 65536*300; 
.................... //!/////////////////////////////////////////////////////// 
.................... #define SECT 65536                                                               //1 Sector = 65536 Bytes 
....................  
.................... Static int32 ADD_INFO_ADDRESS = 4096;                                            //for keeping the address data to flash memory 
.................... Static int32 ADDRESS_WRITING_COUNTER = 0;                                        //if address writing more than 30000 times, change the store address 
....................  
.................... Static int32 FLAG_DATA_ADDRESS = SECT*4;                                         //1sector 
.................... Static int32 RSV_DATA_ADDRESS=SECT*5;                                            //1sector 
.................... Static int32 SAT_LOG = SECT*6;                                                   //2sector 
.................... Static int32 CAM_ADDRESS = SECT*8;                                               //90sector 
.................... Static int32 FAB_HK_ADDRESS = SECT*98;                                           //1000sector 
.................... Static int32 FAB_CW_ADDRESS = SECT*1098;                                         //40sector 
.................... Static int32 ADCS_SENSOR_ADDRESS = SECT*1138;                                    //500sector 
.................... Static int32 ADCS_TLE_ADDRESS = SECT*1637;                                       //1sector (el ultimo no utilizado por ADCS data) 
.................... Static int32 DC_STATUS_ADDRESS = SECT*1638;                                      //1sector 
.................... Static int32 HIGH_SAMP_HK_ADDRESS = SECT*1639;                                   //409sector 
.................... Static int32 FLAG_ADDRESS_EEPROM = 0x18000;                                      //from 75 percent of the programming memory 
.................... Static int32 FLASH_AD_ADDRESS_EEPROM = 0x18000 + 28;                             //after flag info 
....................                                                                                  //Definicion de direcciones de espacio de memoria (fin) 
.................... #define FLAG_DATA_ADDRESS_END  SECT*5-26                                         //considera la longitud de cada dato para determinar la direccion de finalizacion 
.................... #define RSV_DATA_ADDRESS_END  SECT*6-160 
.................... #define SAT_LOG_END  SECT*8-22 
.................... #define CAM_ADDRESS_END  SECT*98-SECT*2 
.................... #define FAB_HK_ADDRESS_END  SECT*1098-SECT-248 
.................... #define FAB_CW_ADDRESS_END  SECT*1138-10 
.................... #define FAB_CW_ADDRESS_FOR_MF_END FAB_CW_ADDRESS_END 
.................... #define ADCS_SENSOR_ADDRESS_END  SECT*1638-408000                                //408000 is for 2 hour data(85*3600*2/1.5) 
.................... #define ADCS_TLE_ADDRESS_END  SECT*1638-TLE_size 
.................... #define DC_STATUS_ADDRESS_END SECT*1639-415 
.................... #define HIGH_SAMP_HK_ADDRESS_END  SECT*2047-178560                               //178560 is for 2 hour data(124*3600*2/5) 
....................                                                                                  //Flags definition 
.................... int8 BC_ATTEMPT_FLAG = 0; 
.................... int16 PASSED_DAYS = 0; 
.................... int8 RESERVE_CHECK = 0; 
.................... int8 RESERVE_MIN_FLAG = 0; 
.................... int8 RESERVE_TARGET_FLAG = 0; 
.................... int8 MISSION_CONTENTS = 0; 
.................... int8 MISSION_DETAIL = 0; 
.................... int8 RESERVE_ADDRESS_1 = 0; 
.................... int8 RESERVE_ADDRESS_2 = 0; 
.................... int8 RESERVE_ADDRESS_3 = 0; 
.................... int8 RESERVE_ADDRESS_4 = 0; 
.................... int8 RESERVE_PACKET_NUM = 0; 
.................... int8 Kill_FLAG_MAIN = 0; 
.................... int8 Kill_FLAG_FAB = 0; 
.................... int8 FIRST_HSSC_DONE = 0; 
.................... int8 AUTO_CAM_DONE = 0; 
.................... int8 AUTO_MBP_DONE = 0; 
.................... int8 AUTO_ADCS_DONE = 0; 
.................... int8 ANT_DEP_STATUS = 0; 
.................... int8 UPLINK_SUCCESS = 0; 
....................  
.................... int8 RESERVE_SEC_FLAG = 0; 
....................  
.................... //--------MAIN PIC Buffer------------------------------------------------------ 
.................... int8 CMD_FROM_PC[8] = {}; 
.................... unsigned int8 in_bffr_main[16] = {}; 
.................... int8 COM_DATA= 0; 
.................... static int8 CW_IDENTIFIER = 0; 
.................... int8 OPERATION_MODE = 0x00; 
.................... int8 PC_DATA = 0;                                   
.................... int8 COM_ONEBYTE_COMMAND = 0;                                                    //for GS testing 
....................  
.................... #define buffer_from_com  (in_bffr_main[0]==0xAA) && (in_bffr_main[15]==0xBB) 
.................... #define buffer_flash  (in_bffr_main[7]==0x73) 
.................... #define START_ADCS_MISSION  (in_bffr_main[1]==0x73) 
.................... #define ADCS_SENSOR_SIZE 100                                                      //for testing additional 6byte for checking duty 
....................  
....................  
.................... int8 ADCS_SENSOR_DATA[ADCS_SENSOR_SIZE] = {}; 
.................... int8 ADCS_ACK = 0; 
.................... int8 ADCS_ACK_COMMING = 0;                                                       //for Checking ACK from ADCS 
.................... #define ATTEMPT_TIME 8 
....................  
....................  
.................... #define EX_PANEL_THRESHHOLD 0x14 
.................... #define HIGH_SAMP_TIMES 12                                                       //for 2 hours 
....................  
.................... //----------RESET-------------------------------------------------------------- 
.................... #define Reset_size 11                                                            //1byte ack, 4byte time, 10byte sensor 
.................... int8 RESET_DATA = 0; 
.................... int8 reset_bffr[Reset_size] = {}; 
.................... int8 reset_flag = 0; 
....................  
.................... //---------OTHER FUNCTION------------------------------------------------------ 
.................... #define FLASH_ADD_SIZE 41                                                        //10 kinds of address(40byte), 1 flag(1byte), 1 WRITING COUNTER(2byte) 
.................... #define FLAG_INFO_SIZE 16 
.................... unsigned int8 sec_add_bfr[FLASH_ADD_SIZE] = {};                                  //vector utilizado para almacenar las direcciones leidas de la flash 
.................... unsigned int8 flag_info_bffr[FLAG_INFO_SIZE] = {}; 
....................  
.................... void CURRENT_FLAG_STATUS()                                                      //Print on PC port current flag status 
.................... { 
....................    fprintf(PC,"\r\nPASSED DAYS:%x\r\n",PASSED_DAYS); 
....................    fprintf(PC,"RESERVE CHECK:%x\r\n",RESERVE_CHECK); 
....................    fprintf(PC,"Kill FLAG MAIN:%x\r\n",Kill_FLAG_MAIN); 
....................    fprintf(PC,"Kill FLAG FAB:%x\r\n",Kill_FLAG_FAB); 
....................    fprintf(PC,"AUTO HIGH SAMPLING:%x\r\n",FIRST_HSSC_DONE); 
....................    fprintf(PC,"AUTO CAM:%x\r\n",AUTO_CAM_DONE); 
....................    fprintf(PC,"AUTO MBP:%x\r\n",AUTO_MBP_DONE); 
....................    fprintf(PC,"AUTO ADCS:%x\r\n",AUTO_ADCS_DONE); 
....................    fprintf(PC,"ANTENNA DEPLOY:%x\r\n",ANT_DEP_STATUS); 
....................    fprintf(PC,"ANTENNA DEPLOY ATTEMPT:%x\r\n",BC_ATTEMPT_FLAG); 
....................    fprintf(PC,"UPLINK SUCCESS:%x\r\n\r\n",UPLINK_SUCCESS); 
....................    return; 
.................... } 
....................  
....................  
.................... void CURRENT_ADDRESS_OF_FLASH()                                                  //imprime la asignacion de direcciones de la Flash memory 
.................... {   
....................    fprintf(PC,"\r\nADD INFO ADDRESS:%lx\r\n\r\n",ADD_INFO_ADDRESS); 
....................    fprintf(PC,"FLAG DATA ADDRESS:%x%x%x%x\r\n",FLAG_DATA_ADDRESS>>24,FLAG_DATA_ADDRESS>>16,FLAG_DATA_ADDRESS>>8,FLAG_DATA_ADDRESS); 
....................    fprintf(PC,"RESERVATION TABLE ADDRESS:%x%x%x%x\r\n",RSV_DATA_ADDRESS>>24,RSV_DATA_ADDRESS>>16,RSV_DATA_ADDRESS>>8,RSV_DATA_ADDRESS); 
....................    fprintf(PC,"SATELLITE LOG ADDRESS:%x%x%x%x\r\n",SAT_LOG>>24,SAT_LOG>>16,SAT_LOG>>8,SAT_LOG); 
....................    fprintf(PC,"CAM ADDRESS:%x%x%x%x\r\n",CAM_ADDRESS>>24,CAM_ADDRESS>>16,CAM_ADDRESS>>8,CAM_ADDRESS); 
....................    fprintf(PC,"FAB HK ADDRESS:%x%x%x%x\r\n",FAB_HK_ADDRESS>>24,FAB_HK_ADDRESS>>16,FAB_HK_ADDRESS>>8,FAB_HK_ADDRESS); 
....................    fprintf(PC,"FAB CW ADDRESS:%x%x%x%x\r\n",FAB_CW_ADDRESS>>24,FAB_CW_ADDRESS>>16,FAB_CW_ADDRESS>>8,FAB_CW_ADDRESS); 
....................    fprintf(PC,"ADCS SENSOR ADDRESS:%x%x%x%x\r\n",ADCS_SENSOR_ADDRESS>>24,ADCS_SENSOR_ADDRESS>>16,ADCS_SENSOR_ADDRESS>>8,ADCS_SENSOR_ADDRESS); 
....................    fprintf(PC,"ADCS TLE ADDRESS:%x%x%x%x\r\n",ADCS_TLE_ADDRESS>>24,ADCS_TLE_ADDRESS>>16,ADCS_TLE_ADDRESS>>8,ADCS_TLE_ADDRESS); 
....................    fprintf(PC,"MISSION BOSS ADDRESS:%x%x%x%x\r\n",DC_STATUS_ADDRESS>>24,DC_STATUS_ADDRESS>>16,DC_STATUS_ADDRESS>>8,DC_STATUS_ADDRESS); 
....................    fprintf(PC,"HIGH SAMP HK ADDRESS:%x%x%x%x\r\n",HIGH_SAMP_HK_ADDRESS>>24,HIGH_SAMP_HK_ADDRESS>>16,HIGH_SAMP_HK_ADDRESS>>8,HIGH_SAMP_HK_ADDRESS); 
....................    fprintf(PC,"WRITE %lx TIMES\r\n",ADDRESS_WRITING_COUNTER); 
....................    return; 
.................... } 
....................  
.................... void ERASE_EEPROM_INFO() 
.................... { 
....................    erase_program_eeprom(FLAG_ADDRESS_EEPROM);//erase 512byte(from 0x18000 to 0x181ff) 
....................    return; 
.................... } 
....................  
.................... void WRITE_FLAG_to_EEPROM()                                                      //saves the flags in the EEPROM from the address 0x18000 (75%) 
.................... { 
.................... //total programming memory size is 128KB 
.................... //start writing the important flag from 75 percent of the programming memory(from the address of 96KB --> 0x18000) 
....................    int16 DATA; 
....................    DATA = (int16)BC_ATTEMPT_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM, DATA); 
....................    DATA = (int16)PASSED_DAYS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+2, DATA); 
....................    DATA = (int16)RESERVE_CHECK; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+4, DATA); 
....................    DATA = (int16)RESERVE_MIN_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+6, DATA); 
....................    DATA = (int16)RESERVE_TARGET_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+8, DATA); 
....................    DATA = (int16)MISSION_CONTENTS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+10, DATA); 
....................    DATA = (int16)MISSION_DETAIL; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+12, DATA); 
....................    DATA = (int16)Kill_FLAG_MAIN; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+14, DATA); 
....................    DATA = (int16)Kill_FLAG_FAB; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+16, DATA); 
....................    DATA = (int16)FIRST_HSSC_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+18, DATA); 
....................    DATA = (int16)AUTO_CAM_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+20, DATA); 
....................    DATA = (int16)AUTO_MBP_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+22, DATA); 
....................    DATA = (int16)AUTO_ADCS_DONE; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+24, DATA); 
....................    DATA = (int16)ANT_DEP_STATUS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26, DATA); 
....................    DATA = (int16)UPLINK_SUCCESS; 
....................    WRITE_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+28, DATA); 
....................    return; 
.................... } 
.................... /* 
.................... void WRITE_AD_INFO_to_EEPROM() 
.................... { 
....................    int16 DATA; 
....................    DATA = BC_ATTEMPT_FLAG >> 16; 
....................    WRITE_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM, DATA); 
....................    DATA = BC_ATTEMPT_FLAG; 
....................    WRITE_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM+2, DATA); 
....................    return; 
.................... } 
.................... */ 
.................... void MAKE_FLAG_from_EEPROM()                                                     //toma de la eeprom la info de los flags y los carga en sus variables respectivas 
.................... { 
....................    if((READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM)!=0xffff)&&(READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26)!=0xffff)) 
....................    { 
....................       BC_ATTEMPT_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM); 
....................       PASSED_DAYS = (int16)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+2); 
....................       RESERVE_CHECK = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+4); 
....................       RESERVE_MIN_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+6); 
....................       RESERVE_TARGET_FLAG = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+8); 
....................       MISSION_CONTENTS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+10); 
....................       MISSION_DETAIL = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+12); 
....................       Kill_FLAG_MAIN = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+14); 
....................       Kill_FLAG_FAB = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+16); 
....................       FIRST_HSSC_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+18); 
....................       AUTO_CAM_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+20); 
....................       AUTO_MBP_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+22); 
....................       AUTO_ADCS_DONE = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+24); 
....................       ANT_DEP_STATUS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+26); 
....................       UPLINK_SUCCESS = (int8)READ_PROGRAM_EEPROM(FLAG_ADDRESS_EEPROM+28); 
....................    } 
....................     
....................    fprintf(PC,"\r\nPASSED DAYS:%lx\r\n",PASSED_DAYS); 
....................    fprintf(PC,"RESERVE CHECK:%x\r\n",RESERVE_CHECK); 
....................    fprintf(PC,"Kill FLAG MAIN:%x\r\n",Kill_FLAG_MAIN); 
....................    fprintf(PC,"Kill FLAG FAB:%x\r\n",Kill_FLAG_FAB); 
....................    fprintf(PC,"AUTO HIGH SAMPLING:%x\r\n",FIRST_HSSC_DONE); 
....................    fprintf(PC,"AUTO CAM:%x\r\n",AUTO_CAM_DONE); 
....................    fprintf(PC,"AUTO MBP:%x\r\n",AUTO_MBP_DONE); 
....................    fprintf(PC,"AUTO ADCS:%x\r\n",AUTO_ADCS_DONE); 
....................    fprintf(PC,"ANTENNA DEPLOY:%x\r\n",ANT_DEP_STATUS); 
....................    fprintf(PC,"UPLINK SUCCESS:%x\r\n\r\n",UPLINK_SUCCESS); 
....................     
....................    return; 
.................... } 
....................  
.................... void TAKE_AD_INFO_from_EEPROM()                                                  //Reads address data from de program memory 
.................... { 
....................    int16 DATA_high = READ_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM);                
....................    int16 DATA_low = READ_PROGRAM_EEPROM(FLASH_AD_ADDRESS_EEPROM+2); 
....................    int32 DATA = (((int32)DATA_high<<16) | (int32)DATA_low); 
....................    if(DATA != 0xffffffff) 
....................    { 
....................       ADD_INFO_ADDRESS = DATA;                                                    
....................    } 
....................    return; 
.................... } 
....................  
.................... void STORE_FLAG_INFO()                                                           //save flag data to flash memory 
.................... { 
....................    flag_info_bffr[0] = BC_ATTEMPT_FLAG; 
....................    flag_info_bffr[1] = PASSED_DAYS >> 8; 
....................    flag_info_bffr[2] = PASSED_DAYS; 
....................    flag_info_bffr[3] = RESERVE_CHECK; 
....................    flag_info_bffr[4] = RESERVE_TARGET_FLAG; 
....................    flag_info_bffr[5] = RESERVE_MIN_FLAG; 
....................    flag_info_bffr[6] = MISSION_CONTENTS; 
....................    flag_info_bffr[7] = MISSION_DETAIL; 
....................    flag_info_bffr[8] = Kill_FLAG_MAIN; 
....................    flag_info_bffr[9] = Kill_FLAG_FAB; 
....................    flag_info_bffr[10] = FIRST_HSSC_DONE; 
....................    flag_info_bffr[11] = AUTO_CAM_DONE; 
....................    flag_info_bffr[12] = AUTO_MBP_DONE; 
....................    flag_info_bffr[13] = AUTO_ADCS_DONE; 
....................    flag_info_bffr[14] = ANT_DEP_STATUS; 
....................    flag_info_bffr[15] = UPLINK_SUCCESS; 
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
....................    SUBSECTOR_4KB_ERASE_OF(FLAG_DATA_ADDRESS); 
....................    delay_ms(200); 
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_OF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
....................       delay_us(10); 
....................    } 
....................    delay_ms(10); 
....................    SUBSECTOR_4KB_ERASE_SCF(FLAG_DATA_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_SCF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
....................       delay_us(10); 
....................    } 
....................    delay_ms(10); 
....................    SUBSECTOR_4KB_ERASE_SMF(FLAG_DATA_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       WRITE_DATA_BYTE_SMF(FLAG_DATA_ADDRESS + num,flag_info_bffr[num]); 
....................       delay_us(10); 
....................    } 
....................     
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
....................     
....................    fprintf(PC,"FLAG INFO STORED IN FLASH\r\n"); 
....................    return; 
....................     
.................... } 
....................  
.................... void RESET_FLAG_DATA() 
.................... { 
....................    //BC_ATTEMPT_FLAG = 0; 
....................    PASSED_DAYS = 0; 
....................    //RESERVE_CHECK = 0; 
....................    //RESERVE_MIN_FLAG = 0; 
....................    //RESERVE_TARGET_FLAG = 0; 
....................    //MISSION_CONTENTS = 0; 
....................    //MISSION_DETAIL = 0; 
....................    Kill_FLAG_MAIN = 0; 
....................    Kill_FLAG_FAB = 0; 
....................    FIRST_HSSC_DONE = 0; 
....................    AUTO_CAM_DONE = 0; 
....................    AUTO_MBP_DONE = 0; 
....................    AUTO_ADCS_DONE = 0; 
....................    ANT_DEP_STATUS = 0; 
....................    UPLINK_SUCCESS = 0; 
....................    STORE_FLAG_INFO(); 
....................    WRITE_FLAG_to_EEPROM(); 
....................    return; 
.................... } 
....................  
.................... void READ_WRTITING_ADDRESS_LOCATION()                                            //load the variable ADD_INFO_ADDRESS, look for the data in OF, SCF, SMF and EEPROM (carga la variable ADD_INFO_ADDRESS, busca el dato en OF, SCF, SMF y EEPROM) 
.................... {                                                                                //if you can't find it use the initial value (si no lo encuentra usa el valor inicial) 
....................    int i; 
....................    int8 ad_location_bfr[4]; 
....................    output_low(PIN_C4);                                                           //Main side 
....................    output_low(PIN_A5);                                                           //Main side 
....................    if(READ_DATA_BYTE_OF(0) == 0xff)                                              //this means there is no address data in OBC Flash 
....................    { 
....................       if(READ_DATA_BYTE_SCF(0) == 0xff)                                          //this means there is no address data in Shared COM Flash 
....................       { 
....................          if(READ_DATA_BYTE_SMF(0) == 0xff)                                       //if all memory was empty, location should be initial value 
....................          { 
....................             TAKE_AD_INFO_from_EEPROM();                                          //if inside of eeprom is also empty, use the initial value 
....................             ad_location_bfr[0] = ADD_INFO_ADDRESS >> 24; 
....................             ad_location_bfr[1] = ADD_INFO_ADDRESS >> 16; 
....................             ad_location_bfr[2] = ADD_INFO_ADDRESS >> 8; 
....................             ad_location_bfr[3] = ADD_INFO_ADDRESS; 
....................          }else{ 
....................             ad_location_bfr[0] = READ_DATA_BYTE_SMF(0); 
....................             ad_location_bfr[1] = READ_DATA_BYTE_SMF(1); 
....................             ad_location_bfr[2] = READ_DATA_BYTE_SMF(2); 
....................             ad_location_bfr[3] = READ_DATA_BYTE_SMF(3); 
....................             ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
....................          } 
....................       }else{ 
....................          ad_location_bfr[0] = READ_DATA_BYTE_SCF(0); 
....................          ad_location_bfr[1] = READ_DATA_BYTE_SCF(1); 
....................          ad_location_bfr[2] = READ_DATA_BYTE_SCF(2); 
....................          ad_location_bfr[3] = READ_DATA_BYTE_SCF(3); 
....................          ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
....................       } 
....................    }else{ 
....................       ad_location_bfr[0] = READ_DATA_BYTE_OF(0); 
....................       ad_location_bfr[1] = READ_DATA_BYTE_OF(1); 
....................       ad_location_bfr[2] = READ_DATA_BYTE_OF(2); 
....................       ad_location_bfr[3] = READ_DATA_BYTE_OF(3); 
....................       ADD_INFO_ADDRESS = make32(ad_location_bfr[0],ad_location_bfr[1],ad_location_bfr[2],ad_location_bfr[3]); 
....................    } 
....................     
....................    for(i = 0; i < 4; i++)                                                        //store the subsector(location) information 
....................    { 
....................       WRITE_DATA_BYTE_OF(i,ad_location_bfr[i]); 
....................       WRITE_DATA_BYTE_SCF(i,ad_location_bfr[i]); 
....................       WRITE_DATA_BYTE_SMF(i,ad_location_bfr[i]); 
....................    } 
....................    output_high(PIN_C4); 
....................    fprintf(PC,"\r\naddress info location:%lx\r\n",ADD_INFO_ADDRESS); 
....................    return; 
.................... } 
....................  
.................... void CHANGE_ADDRESS_WRITING_LOCATION()                                           //cambia la direccion de escritura de address locations cuando se superan los 95.000 ciclos 
.................... { 
....................    int32 AD_COUNTER = make32(READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+37),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+38),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+39),READ_DATA_BYTE_OF(ADD_INFO_ADDRESS+40));//check counter value 
....................    fprintf(PC,"AD COUNTER:%lx\r\n",AD_COUNTER); 
....................    if((AD_COUNTER > 95000) && (AD_COUNTER != 0xffffffff)) 
....................    { 
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_OF(0); 
....................       SUBSECTOR_4KB_ERASE_SCF(0); 
....................       SUBSECTOR_4KB_ERASE_SMF(0); 
....................       ADDRESS_WRITING_COUNTER = 0;                                               //reset counter 
....................       ADD_INFO_ADDRESS = ADD_INFO_ADDRESS + 0x00001000;                          //use next subsector 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       unsigned int8 address_place[4] = {}; 
....................       address_place[0] = ADD_INFO_ADDRESS >> 24; 
....................       address_place[1] = ADD_INFO_ADDRESS >> 16; 
....................       address_place[2] = ADD_INFO_ADDRESS >> 8; 
....................       address_place[3] = ADD_INFO_ADDRESS; 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       for(int i = 0; i < 4; i++)                                                 //store the new subsector(location) information 
....................       { 
....................          WRITE_DATA_BYTE_OF(i,address_place[i]);                                 //se le pasa direccion y dato 
....................          delay_us(10); 
....................          WRITE_DATA_BYTE_SCF(i,address_place[i]); 
....................          delay_us(10); 
....................          WRITE_DATA_BYTE_SMF(i,address_place[i]); 
....................          delay_us(10); 
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       fprintf(PC,"CHANGED MEMORY ADDRESS:"); 
....................       for(i = 0; i < 4; i++)                                                     //store the subsector(location) information 
....................       { 
....................          fprintf(PC,"%x",READ_DATA_BYTE_OF(i)); 
....................       } 
....................       fprintf(PC,"\r\n"); 
....................    } 
....................     
....................    return; 
.................... } 
....................  
.................... void TAKE_FLAG_INFO_FROM_OF()                                                    //Funcion que lee de memoria el dato de los FLAGS 
.................... { 
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       flag_info_bffr[num] = READ_DATA_BYTE_OF(FLAG_DATA_ADDRESS + num);          //guarda los datos en el vector flag_info_bffr[] 
....................       //delay_ms(1); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void STORE_ADRESS_DATA_TO_FLASH()                                                //save the address data in a new sector if the R / W cycle is reached 
.................... { 
....................    fprintf(PC,"\r\nStoreing Address Data in Flash\r\n"); 
....................    ADDRESS_WRITING_COUNTER++;                                                    //contador de escrituras en una direccion 
....................    CHANGE_ADDRESS_WRITING_LOCATION();                                            //cambia la direccion del lugar de escritura si se superan 95000 ciclos 
....................    sec_add_bfr[0] = FLAG_DATA_ADDRESS >> 24;                                     //se carga el array sec_add_bfr[] con los datos de las direcciones 
....................    sec_add_bfr[1] = FLAG_DATA_ADDRESS >> 16; 
....................    sec_add_bfr[2] = FLAG_DATA_ADDRESS >> 8; 
....................    sec_add_bfr[3] = FLAG_DATA_ADDRESS; 
....................        
....................    sec_add_bfr[4] = RSV_DATA_ADDRESS >> 24; 
....................    sec_add_bfr[5] = RSV_DATA_ADDRESS >> 16; 
....................    sec_add_bfr[6] = RSV_DATA_ADDRESS >> 8; 
....................    sec_add_bfr[7] = RSV_DATA_ADDRESS; 
....................     
....................    sec_add_bfr[8] = SAT_LOG >> 24; 
....................    sec_add_bfr[9] = SAT_LOG >> 16; 
....................    sec_add_bfr[10] = SAT_LOG >> 8; 
....................    sec_add_bfr[11] = SAT_LOG; 
....................     
....................    sec_add_bfr[12] = CAM_ADDRESS >> 24; 
....................    sec_add_bfr[13] = CAM_ADDRESS >> 16; 
....................    sec_add_bfr[14] = CAM_ADDRESS >> 8; 
....................    sec_add_bfr[15] = CAM_ADDRESS; 
....................     
....................    sec_add_bfr[16] = FAB_HK_ADDRESS >> 24; 
....................    sec_add_bfr[17] = FAB_HK_ADDRESS >> 16; 
....................    sec_add_bfr[18] = FAB_HK_ADDRESS >> 8; 
....................    sec_add_bfr[19] = FAB_HK_ADDRESS; 
....................     
....................    sec_add_bfr[20] = FAB_CW_ADDRESS >> 24; 
....................    sec_add_bfr[21] = FAB_CW_ADDRESS >> 16; 
....................    sec_add_bfr[22] = FAB_CW_ADDRESS >> 8; 
....................    sec_add_bfr[23] = FAB_CW_ADDRESS; 
....................     
....................    sec_add_bfr[24] = ADCS_SENSOR_ADDRESS >> 24; 
....................    sec_add_bfr[25] = ADCS_SENSOR_ADDRESS >> 16; 
....................    sec_add_bfr[26] = ADCS_SENSOR_ADDRESS >> 8; 
....................    sec_add_bfr[27] = ADCS_SENSOR_ADDRESS; 
....................     
....................    sec_add_bfr[28] = DC_STATUS_ADDRESS >> 24; 
....................    sec_add_bfr[29] = DC_STATUS_ADDRESS >> 16; 
....................    sec_add_bfr[30] = DC_STATUS_ADDRESS >> 8; 
....................    sec_add_bfr[31] = DC_STATUS_ADDRESS; 
....................     
....................    sec_add_bfr[32] = HIGH_SAMP_HK_ADDRESS >> 24; 
....................    sec_add_bfr[33] = HIGH_SAMP_HK_ADDRESS >> 16; 
....................    sec_add_bfr[34] = HIGH_SAMP_HK_ADDRESS >> 8; 
....................    sec_add_bfr[35] = HIGH_SAMP_HK_ADDRESS; 
....................     
....................    sec_add_bfr[36] = BC_ATTEMPT_FLAG; 
....................     
....................     
....................    sec_add_bfr[37] = ADDRESS_WRITING_COUNTER >> 24; 
....................    sec_add_bfr[38] = ADDRESS_WRITING_COUNTER >> 16; 
....................    sec_add_bfr[39] = ADDRESS_WRITING_COUNTER >> 8; 
....................    sec_add_bfr[40] = ADDRESS_WRITING_COUNTER; 
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
....................    int8 num = 0; 
....................    SUBSECTOR_4KB_ERASE_OF(ADD_INFO_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en OBC FLASH 
....................    { 
....................       WRITE_DATA_BYTE_OF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
....................       delay_us(10); 
....................    } 
....................    SUBSECTOR_4KB_ERASE_SCF(ADD_INFO_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en COM FLASH 
....................    { 
....................       WRITE_DATA_BYTE_SCF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
....................       delay_us(10); 
....................    } 
....................    SUBSECTOR_4KB_ERASE_SMF(ADD_INFO_ADDRESS); 
....................    delay_ms(200); 
....................    for(num = 0; num < FLASH_ADD_SIZE; num++)                                     //guarda todos los datos de direcciones en MISSION FLASH 
....................    { 
....................       WRITE_DATA_BYTE_SMF(ADD_INFO_ADDRESS + num,sec_add_bfr[num]); 
....................       delay_us(10); 
....................    } 
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
....................    
....................    fprintf(PC,"ADDRESS DATA STORE DONE:%lx\r\n",ADD_INFO_ADDRESS); 
....................    return; 
.................... } 
....................  
.................... void TAKE_ADDRESS_DATA_FROM_OF()                                                 //Funcion que toma de la memoria las direcciones almacenadas en los primeros lugares 
.................... {   
....................     
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_OF(ADD_INFO_ADDRESS + num); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void TAKE_ADDRESS_DATA_FROM_SCF() 
.................... {   
....................    output_low(PIN_C4);   
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_SCF(ADD_INFO_ADDRESS + num); 
....................    } 
....................    output_high(PIN_C4); 
....................    return; 
.................... } 
....................  
.................... void TAKE_ADDRESS_DATA_FROM_SMF() 
.................... {   
....................    output_low(PIN_A5);   
....................    for(int8 num = 0; num < FLASH_ADD_SIZE; num++) 
....................    { 
....................       sec_add_bfr[num] = READ_DATA_BYTE_SMF(ADD_INFO_ADDRESS + num); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void MAKE_FLAG_INFO()                                                            //Guarda en cada variable la informacion de flags recuperadas de memoria 
.................... { 
....................    BC_ATTEMPT_FLAG     = flag_info_bffr[0]; 
....................    PASSED_DAYS         = make16(flag_info_bffr[1],flag_info_bffr[2]); 
....................    RESERVE_CHECK       = flag_info_bffr[3]; 
....................    RESERVE_TARGET_FLAG = flag_info_bffr[4]; 
....................    RESERVE_MIN_FLAG    = flag_info_bffr[5]; 
....................    MISSION_CONTENTS    = flag_info_bffr[6]; 
....................    MISSION_DETAIL      = flag_info_bffr[7]; 
....................    Kill_FLAG_MAIN      = flag_info_bffr[8]; 
....................    Kill_FLAG_FAB       = flag_info_bffr[9]; 
....................    FIRST_HSSC_DONE     = flag_info_bffr[10]; 
....................    AUTO_CAM_DONE       = flag_info_bffr[11]; 
....................    AUTO_MBP_DONE       = flag_info_bffr[12]; 
....................    AUTO_ADCS_DONE      = flag_info_bffr[13]; 
....................    ANT_DEP_STATUS      = flag_info_bffr[14]; 
....................    UPLINK_SUCCESS      = flag_info_bffr[15]; 
....................    if(PASSED_DAYS == 0xffff) 
....................    { 
....................       COLLECT_RESET_DATA();                                                      //funcion que envia el comando 0x28 al reset PIC y carga reset_bffr[] 
....................       PASSED_DAYS = make16(reset_bffr[4],reset_bffr[5]); 
....................    } 
....................    return; 
.................... } 
....................                                                                              
.................... void MAKE_ADDRESS_DATA()                                                         //Funcion que separa los datos de direcciones en cada variable correspondiente 
.................... {                                                                                //sec_add_bfr[] vector que contiene los datos de direcciones 
....................  
....................  
....................    FLAG_DATA_ADDRESS = make32(sec_add_bfr[0],sec_add_bfr[1],sec_add_bfr[2],sec_add_bfr[3]);//FLAG_DATA_ADDRESS_1 | FLAG_DATA_ADDRESS_2 | FLAG_DATA_ADDRESS_3 | FLAG_DATA_ADDRESS_4; 
....................     
....................    RSV_DATA_ADDRESS = make32(sec_add_bfr[4],sec_add_bfr[5],sec_add_bfr[6],sec_add_bfr[7]);//RSV_DATA_ADDRESS_1| RSV_DATA_ADDRESS_2 | RSV_DATA_ADDRESS_3 | RSV_DATA_ADDRESS_4; 
....................     
....................    SAT_LOG = make32(sec_add_bfr[8],sec_add_bfr[9],sec_add_bfr[10],sec_add_bfr[11]);//SAT_LOG_1 | SAT_LOG_2 | SAT_LOG_3 | SAT_LOG_4; 
....................     
....................    CAM_ADDRESS = make32(sec_add_bfr[12],sec_add_bfr[13],sec_add_bfr[14],sec_add_bfr[15]);//CAM_ADDRESS_1 | CAM_ADDRESS_2 | CAM_ADDRESS_3 | CAM_ADDRESS_4; 
....................     
....................    FAB_HK_ADDRESS = make32(sec_add_bfr[16],sec_add_bfr[17],sec_add_bfr[18],sec_add_bfr[19]);//FAB_HK_ADDRESS_1 | FAB_HK_ADDRESS_2 | FAB_HK_ADDRESS_3 | FAB_HK_ADDRESS_4; 
....................  
....................    FAB_CW_ADDRESS = make32(sec_add_bfr[20],sec_add_bfr[21],sec_add_bfr[22],sec_add_bfr[23]);//FAB_CW_ADDRESS_1| FAB_CW_ADDRESS_2 | FAB_CW_ADDRESS_3 | FAB_CW_ADDRESS_4; 
....................     
....................    ADCS_SENSOR_ADDRESS = make32(sec_add_bfr[24],sec_add_bfr[25],sec_add_bfr[26],sec_add_bfr[27]);//ADCS_SENSOR_ADDRESS_1 | ADCS_SENSOR_ADDRESS_2 | ADCS_SENSOR_ADDRESS_3 | ADCS_SENSOR_ADDRESS_4; 
....................     
....................    DC_STATUS_ADDRESS = make32(sec_add_bfr[28],sec_add_bfr[29],sec_add_bfr[30],sec_add_bfr[31]);//DC_STATUS_ADDRESS_1 | DC_STATUS_ADDRESS_2 | DC_STATUS_ADDRESS_3 | DC_STATUS_ADDRESS_4; 
....................     
....................    HIGH_SAMP_HK_ADDRESS = make32(sec_add_bfr[32],sec_add_bfr[33],sec_add_bfr[34],sec_add_bfr[35]);//HIGH_SAMP_HK_ADDRESS = HIGH_SAMP_HK_ADDRESS_1 | HIGH_SAMP_HK_ADDRESS_2 | HIGH_SAMP_HK_ADDRESS_3 | HIGH_SAMP_HK_ADDRESS_4; 
....................     
....................    ADDRESS_WRITING_COUNTER = make32(sec_add_bfr[36],sec_add_bfr[37],sec_add_bfr[38],sec_add_bfr[39]);//ADDRESS_WRITING_COUNTER_1 | ADDRESS_WRITING_COUNTER_2 
....................     
....................    return; 
.................... } 
....................  
.................... void CHECK_FLAG_INFO()                                                           //funcion que imprime los datos de los flags y los separa en cada variable 
.................... { 
....................    int8 checksum = 0; 
....................    TAKE_FLAG_INFO_FROM_OF();                                                     //funcion que lee de la Main flash el estado de los flags y carga el array flag_info_bffr 
....................    for(int8 num = 0; num < FLAG_INFO_SIZE; num++) 
....................    { 
....................       if(flag_info_bffr[num] == 0xff)                                            //si la informacion recuperada es 0xff (no hay informacion) incrementa el checksum 
....................       { 
....................          checksum++; 
....................       } 
....................    } 
....................    //fprintf(PC,"%d",checksum); 
....................     
....................    if((flag_info_bffr[0]!=0xff)&&(flag_info_bffr[FLAG_INFO_SIZE-1]!=0xff))       //if something stored 
....................    { 
....................       for(num = 0; num < FLAG_INFO_SIZE; num++)                                  //imprime la informacion de los flags 
....................       { 
....................          fprintf(PC,"%x",flag_info_bffr[num]); 
....................       } 
....................       MAKE_FLAG_INFO();                                                          //separa el estado de los flags en cada variable 
....................    }else{                                                                        //if nothing stored 
....................       MAKE_FLAG_from_EEPROM();                                                   //lee de la eeprom el estado de los flags 
....................    } 
....................    checksum = 0; 
....................    return; 
.................... } 
....................  
.................... void CHECK_ADDRESS_DATA()                                                        //imprime los datos de direcciones y los separa en cada variable correspondiente 
.................... { 
....................    int8 checksum = 0; 
....................    TAKE_ADDRESS_DATA_FROM_OF();                                                  //craga el array sec_add_bfr[] con address location info y lo imprime                                                   
....................    for(int8 num = 37; num < 41; num++)                                           //check the data of last 4 byte 
....................    { 
....................       if(sec_add_bfr[num] == 0xff)                                               //if nothing, count checksum 
....................       { 
....................          checksum++; 
....................       } 
....................    } 
....................     
....................    if(checksum != 4)                                                             //if something stored (if last 4 byte were not 0xff) 
....................    { 
....................       for(num = 0; num < FLASH_ADD_SIZE; num++) 
....................       { 
....................          fprintf(PC,"%x",sec_add_bfr[num]);                                      //imprime el contenido de sec_add_bfr[] que contiene las direcciones 
....................       } 
....................       fprintf(PC,"\r\n"); 
....................       MAKE_ADDRESS_DATA();                                                       //los separa en las variables correspondientes a cada direccion 
....................    }else{                                                                        //if there is nothing, check from SCF 
....................       output_low(PIN_C4); 
....................       TAKE_ADDRESS_DATA_FROM_SCF(); 
....................       output_high(PIN_C4); 
....................       checksum = 0; 
....................       for(num = 37; num < 41; num++)                                             //check the data of last 4 byte 
....................       { 
....................          if(sec_add_bfr[num] == 0xff)                                            //if nothing, count checksum 
....................          { 
....................             checksum++; 
....................          } 
....................       } 
....................       if(checksum != 4) 
....................       { 
....................          for(num = 0; num < FLASH_ADD_SIZE; num++) 
....................          { 
....................             fprintf(PC,"%x",sec_add_bfr[num]); 
....................          } 
....................          fprintf(PC,"\r\n"); 
....................          MAKE_ADDRESS_DATA(); 
....................       }else{                                                                     //if there is nothing, check from SMF 
....................          output_low(PIN_A5); 
....................          TAKE_ADDRESS_DATA_FROM_SMF(); 
....................          checksum = 0; 
....................          for(num = 37; num < 41; num++)                                          //check the data of last 4 byte 
....................          { 
....................             if(sec_add_bfr[num] == 0xff)                                         //if nothing, count checksum 
....................             { 
....................                checksum++; 
....................             } 
....................          } 
....................          if(checksum != 4) 
....................          { 
....................             for(num = 0; num < FLASH_ADD_SIZE; num++) 
....................             { 
....................                fprintf(PC,"%x",sec_add_bfr[num]); 
....................             } 
....................             fprintf(PC,"\r\n"); 
....................             MAKE_ADDRESS_DATA(); 
....................          } 
....................       } 
....................    }   
....................    checksum = 0;   
....................    return; 
.................... } 
....................  
.................... ////////////////////////// 
.................... //FAB_HK_ADDRESS        // 
.................... //FAB_CW_ADDRESS        // 
.................... //ADCS_SENSOR_ADDRESS   // 
.................... //CAM_ADDRESS           // 
.................... //DC_STATUS_ADDRESS     // 
.................... ////////////////////////// 
.................... void MEMORY_ERASE() 
.................... { 
....................    fprintf(PC,"FLASH MEMORY ERASE START\r\n"); 
....................     
....................    output_low(PIN_A5);                                                           //CAM_MUX MAINSIDE 
....................    output_low(PIN_C4);                                                           //COM_MUX MAINSIDE 
....................     
....................    sector_erase_OF(0); 
....................    sector_erase_SCF(0); 
....................    sector_erase_SMF(0); 
....................     
....................    sector_erase_OF(FAB_CW_ADDRESS); 
....................    sector_erase_SCF(FAB_CW_ADDRESS); 
....................    sector_erase_SMF(FAB_CW_ADDRESS); 
....................     
....................     
....................    for(int8 num = 0; num < 5; num++) 
....................    { 
....................       sector_erase_OF(FLAG_DATA_ADDRESS + SECT*num);                             //65536*num 
....................       sector_erase_OF(CAM_ADDRESS + SECT*num);                                   //65536*num 
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT*num);                                //65536*num 
....................       sector_erase_OF(ADCS_SENSOR_ADDRESS + SECT*num);                           //65536*num 
....................       sector_erase_OF(DC_STATUS_ADDRESS + SECT*num);                             //65536*num 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*num);                          //65536*num 
....................        
....................       sector_erase_SCF(FLAG_DATA_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SCF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SCF(ADCS_SENSOR_ADDRESS + SECT*num);                          //65536*num 
....................       sector_erase_SCF(DC_STATUS_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................        
....................       sector_erase_SMF(FLAG_DATA_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SMF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SMF(ADCS_SENSOR_ADDRESS + SECT*num);                          //65536*num 
....................       sector_erase_SMF(DC_STATUS_ADDRESS + SECT*num);                            //65536*num 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................    } 
....................    for(num = 5; num < 10; num++) 
....................    { 
....................       sector_erase_OF(CAM_ADDRESS + SECT*num);                                   //65536*num 
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT*num);                                //65536*num 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*num);                          //65536*num 
....................        
....................       sector_erase_SCF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................        
....................       sector_erase_SMF(CAM_ADDRESS + SECT*num);                                  //65536*num 
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT*num);                               //65536*num 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*num);                         //65536*num 
....................    } 
....................     
....................    sector_erase_OF(0x06650000);                                                  //erase ADCS TLE address 
....................    sector_erase_SCF(0x06650000); 
....................    sector_erase_SMF(0x06650000); 
....................     
....................    output_high(PIN_C4);                                                          //COM_MUX COMSIDE 
....................    delay_ms(10000); 
....................    fprintf(PC,"FLASH MEMORY ERASE DONE\r\n"); 
....................    for(int t=60; t>0; t--){ 
....................    fprintf(PC,"Remaining time: %d  \r", t); 
....................    delay_ms(1000); 
....................    } 
....................    //delay_ms(60000); 
....................    return; 
.................... } 
.................... /* 
.................... //@@@@@@@@@@@@@@@@@@MISSION LOOP@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... void LOOP_FLAG_DATA_ADDRESS() 
.................... { 
....................     
....................    if(FLAG_DATA_ADDRESS > FLAG_DATA_ADDRESS_END) 
....................    { 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_RSV_DATA_ADDRESS() 
.................... { 
....................    if(RSV_DATA_ADDRESS > RSV_DATA_ADDRESS_END) 
....................    { 
....................        
....................    } 
....................    return; 
.................... } 
.................... */ 
.................... void LOOP_SAT_LOG()                                                              //hace un loop en las posiciones de memoria para almacenar SAT_LOG 
.................... { 
....................    if(SAT_LOG >= SAT_LOG_END)                                                    //si la posicion de escritura de SAT_LOG alcanza a SAT_LOG_END 
....................    { 
....................       sector_erase_OF(SECT*7);                                                   //borra un sector de la MAIN flash, 65536*7 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*7);                                                  //borra un sector de la COM flash,65536*7 
....................       output_high(PIN_C4);                                                       //CAM_MUX MAINSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*7);                                                  //borra un sector de la MISSION flash,65536*7 
....................       SAT_LOG = SECT*7;                                                          //Cambia la direccion de SAT_LOG y mantiene el primer sector,65536*7 
....................       STORE_ADRESS_DATA_TO_FLASH();                                              //guarda los datos de direcciones, sera en un nuevo sector si se cumple el ciclo de R/W 
....................    } 
....................    //output_high(PIN_C4);//COM_MUX COMSIDE 
....................    return; 
.................... } 
....................  
.................... void LOOP_CAM_ADDRESS()                                                          //hace un loop en las posiciones de memoria para almacenar CAM data 
.................... { 
....................    if(CAM_ADDRESS >= CAM_ADDRESS_END)                                            //si la posicion de escritura de CAM alcanza a CAM_ADDRESS_END 
....................    { 
....................       sector_erase_OF(SECT*9);                                                   //borra 1 sector de la MAIN flash, 65536*9 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*9);                                                  //borra 1 sector de la COM flash, 65536*9 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*9);                                                  //borra 1 sector de la MISSION flash, 65536*9 
....................        
....................       CAM_ADDRESS = SECT*9;                                                      //CAM address se ubica ahora en el comienzo del espacio designado a CAM 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_FAB_HK_ADDRESS()                                                       //Rota las posiciones de guardado de los datos si llega al final del espacio asignado                                                        
.................... { 
....................    int32 checksum = FAB_HK_ADDRESS && 0x0000ffff; 
....................    if(FAB_HK_ADDRESS >= FAB_HK_ADDRESS_END)                                       
....................    { 
....................       sector_erase_OF(SECT*98); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*98); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*98); 
....................        
....................       FAB_HK_ADDRESS = 65536*8;                                                  //la nueva direccion vuelve a ser el comienzo del espacio asignado 
....................       STORE_ADRESS_DATA_TO_FLASH();                                              //guarda los datos de direcciones y en un nuevo sector si se cumple el ciclo de R/W 
....................    }else if(65536 - checksum < 119){                                             //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       sector_erase_OF(FAB_HK_ADDRESS + SECT);                                    //erase next sector in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(FAB_HK_ADDRESS + SECT); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(FAB_HK_ADDRESS + SECT); 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_FAB_CW_ADDRESS()                                                       //Rota las posiciones de guardado de los datos si llega al final del espacio asignado  
.................... { 
....................    int32 checksum = FAB_CW_ADDRESS && 0x0000ffff; 
....................    if(FAB_CW_ADDRESS >= FAB_CW_ADDRESS_END) 
....................    {   
....................       sector_erase_OF(SECT*1098); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*1098); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*1098); 
....................        
....................       FAB_CW_ADDRESS = SECT*1098; 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    }else if(SECT - checksum < 5){                                                //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       sector_erase_OF(FAB_CW_ADDRESS + SECT);                                    //erase next sector in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(FAB_CW_ADDRESS + SECT);                                   //erase next sector in advance 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(FAB_CW_ADDRESS + SECT);                                   //erase next sector in advance 
....................        
....................    } 
....................    return; 
.................... } 
....................  
....................  
.................... void LOOP_ADCS_SENSOR_ADDRESS() 
.................... { 
....................    if(ADCS_SENSOR_ADDRESS >= ADCS_SENSOR_ADDRESS_END)                            //for 15min operation, data size will be more than 1sector 
....................    { 
....................       sector_erase_OF(SECT*1140); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*1140); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*1140); 
....................        
....................       ADCS_SENSOR_ADDRESS = SECT*1140;                                           //keep first 2 sector forever 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    }else{                                                                        //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       int i; 
....................       for(i = 1; i < 10; i++) 
....................       { 
....................          sector_erase_OF(ADCS_SENSOR_ADDRESS + SECT*i);                          //erase next sector in advance 
....................       } 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       for(i = 1; i < 10; i++) 
....................       { 
....................          sector_erase_SCF(ADCS_SENSOR_ADDRESS + SECT*i);                         //erase next sector in advance 
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       for(i = 1; i < 10; i++) 
....................       { 
....................          sector_erase_SMF(ADCS_SENSOR_ADDRESS + SECT*i);                         //erase next sector in advance 
....................       } 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_DC_STATUS_ADDRESS() 
.................... { 
....................    int32 checksum = DC_STATUS_ADDRESS && 0x00000fff; 
....................    if(DC_STATUS_ADDRESS >= DC_STATUS_ADDRESS_END) 
....................    { 
....................       SUBSECTOR_4KB_ERASE_OF(SECT*1639+4096); 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SCF(SECT*16394096); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SMF(SECT*1639+4096); 
....................        
....................       DC_STATUS_ADDRESS = SECT*1639+4096;                                        //keep first 1 SUBSECTOR forever 
....................       STORE_ADRESS_DATA_TO_FLASH(); 
....................    }else if(4096 - checksum < 800){                                              //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       SUBSECTOR_4KB_ERASE_OF(DC_STATUS_ADDRESS + 4096);                          //erase next SUBSECTOR in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SCF(DC_STATUS_ADDRESS + 4096);                         //erase next SUBSECTOR in advance 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       SUBSECTOR_4KB_ERASE_SMF(DC_STATUS_ADDRESS + 4096);                         //erase next SUBSECTOR in advance 
....................    } 
....................    return; 
.................... } 
....................  
.................... void LOOP_HIGH_SAMP_HK_ADDRESS() 
.................... { 
....................    if(HIGH_SAMP_HK_ADDRESS >= HIGH_SAMP_HK_ADDRESS_END)                          //for 15min operation, data size will be more than 2sector 
....................    { 
....................       sector_erase_OF(SECT*1642);                                                //delet from 066A0000 (keep first 3 sectors) 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(SECT*1642); 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(SECT*1642); 
....................        
....................       HIGH_SAMP_HK_ADDRESS = SECT*1642;                                          //keep first 3 sector forever 
....................    }else{                                                                        //if value will be close to the sector 
....................       fprintf(PC,"erasing next sector\r\n"); 
....................        
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT);                              //erase next sector in advance 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*2);                            //erase next sector in advance 
....................       sector_erase_OF(HIGH_SAMP_HK_ADDRESS + SECT*3);                            //erase next sector in advance 
....................        
....................       output_low(PIN_C4);                                                        //COM_MUX MAINSIDE 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT);                             //erase next sector in advance 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*2);                           //erase next sector in advance 
....................       sector_erase_SCF(HIGH_SAMP_HK_ADDRESS + SECT*3);                           //erase next sector in advance 
....................       output_high(PIN_C4);                                                       //COM_MUX COMSIDE 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX MAINSIDE 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT);                             //erase next sector in advance 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*2);                           //erase next sector in advance 
....................       sector_erase_SMF(HIGH_SAMP_HK_ADDRESS + SECT*3);                           //erase next sector in advance 
....................    } 
....................    return; 
.................... } 
....................  
....................  
....................  
.................... #include<mainpic_function.c> 
....................  
.................... int8 MISSION_STATUS = 0;                                                         //MISSION STATUS FLAGS 
.................... static int16 currenttime = 0; 
.................... BYTE command[9]; 
.................... int8 reset_time_data[11] = {}; 
.................... BYTE PINO_DATA[39] = {0x00}; 
.................... int8 test_data[11] = {0}; 
.................... unsigned int32 address_data[4]; 
.................... unsigned int32 address; 
.................... BYTE RTUC[8]; 
.................... BYTE Down[81]; 
.................... BYTE RTDC[9]; 
.................... BYTE dummy[1]; 
.................... BYTE Finish_sign[1]; 
.................... int i; 
.................... void Turn_On_CAM() 
.................... { 
....................    output_high (PIN_D7); 
....................    return; 
.................... } 
.................... void Turn_Off_CAM() 
.................... { 
....................    output_low (PIN_D7); 
....................    return; 
.................... } 
.................... void Flash_Memory_Access() 
.................... { 
....................    sector_erase_OF (0x00000000); 
....................    WRITE_DATA_BYTE_OF (0x00000000, 0x01) ; 
....................    TRANSFER_DATA_NBYTE_TOPC_OF (0x00000000, 1) ; 
....................    delay_ms (1000); 
....................     
....................    sector_erase_OF (0x00000000); 
....................    WRITE_DATA_BYTE_OF (0x00000000, 0x02) ; 
....................    TRANSFER_DATA_NBYTE_TOPC_OF (0x00000000, 1) ; 
....................    delay_ms (1000); 
....................     
....................    sector_erase_OF (0x00000000); 
....................    WRITE_DATA_BYTE_OF (0x00000000, 0x03) ; 
....................    TRANSFER_DATA_NBYTE_TOPC_OF (0x00000000, 1) ; 
....................    delay_ms (1000); 
.................... } 
.................... void PINO_Test() 
.................... { 
....................    dummy[0] = 0x01; 
*
00D7C:  MOVLW  01
00D7E:  MOVLB  1
00D80:  MOVWF  xF4
....................    int32 num; 
....................    while (TRUE) 
....................    { 
....................       command[0] = 0x00; 
00D82:  CLRF   x38
....................        
....................       for (num = 0; num < 100; num++) 
00D84:  MOVLB  2
00D86:  CLRF   x05
00D88:  CLRF   x04
00D8A:  CLRF   x03
00D8C:  CLRF   x02
00D8E:  MOVF   x05,F
00D90:  BNZ   0DFE
00D92:  MOVF   x04,F
00D94:  BNZ   0DFE
00D96:  MOVF   x03,F
00D98:  BNZ   0DFE
00D9A:  MOVF   x02,W
00D9C:  SUBLW  63
00D9E:  BNC   0DFE
....................       { 
....................          if (kbhit (fab))   //Devuelve verdadero si un caracter ha sido recibido 
00DA0:  BTFSS  FA6.5
00DA2:  BRA    0DEC
....................          { 
....................             //y espera en el buffer para ser leido 
....................             for (int i = 0; i < 9; i++) 
00DA4:  CLRF   x06
00DA6:  MOVF   x06,W
00DA8:  SUBLW  08
00DAA:  BNC   0DEA
....................             { 
....................                fprintf (fab, "Get command\r\n") ; 
00DAC:  MOVLW  22
00DAE:  MOVWF  FF6
00DB0:  MOVLW  05
00DB2:  MOVWF  FF7
00DB4:  MOVLW  00
00DB6:  MOVWF  FF8
00DB8:  MOVLB  0
00DBA:  RCALL  0758
....................                command[i] = fgetc (fab); 
00DBC:  CLRF   03
00DBE:  MOVLB  2
00DC0:  MOVF   x06,W
00DC2:  ADDLW  38
00DC4:  MOVWF  FE9
00DC6:  MOVLW  01
00DC8:  ADDWFC 03,W
00DCA:  MOVWF  FEA
00DCC:  MOVFF  FEA,20A
00DD0:  MOVFF  FE9,209
00DD4:  MOVLB  0
00DD6:  BRA    0786
00DD8:  MOVFF  20A,FEA
00DDC:  MOVFF  209,FE9
00DE0:  MOVFF  01,FEF
00DE4:  MOVLB  2
00DE6:  INCF   x06,F
00DE8:  BRA    0DA6
....................             }//Lee el caracter del buffer, UART receive from main pic 
....................             break; 
00DEA:  BRA    0DFE
....................          } 
00DEC:  MOVLW  01
00DEE:  ADDWF  x02,F
00DF0:  BTFSC  FD8.0
00DF2:  INCF   x03,F
00DF4:  BTFSC  FD8.2
00DF6:  INCF   x04,F
00DF8:  BTFSC  FD8.2
00DFA:  INCF   x05,F
00DFC:  BRA    0D8E
....................       } 
....................       switch (command[0]) 
00DFE:  MOVLB  1
00E00:  MOVF   x38,W
00E02:  XORLW  13
00E04:  MOVLB  0
00E06:  BZ    0E34
00E08:  XORLW  07
00E0A:  BTFSC  FD8.2
00E0C:  BRA    0F14
00E0E:  XORLW  02
00E10:  BTFSC  FD8.2
00E12:  BRA    10B6
00E14:  XORLW  87
00E16:  BTFSC  FD8.2
00E18:  BRA    1196
00E1A:  XORLW  03
00E1C:  BTFSC  FD8.2
00E1E:  BRA    1222
00E20:  XORLW  01
00E22:  BTFSC  FD8.2
00E24:  BRA    1316
00E26:  XORLW  08
00E28:  BTFSC  FD8.2
00E2A:  BRA    133E
00E2C:  XORLW  04
00E2E:  BTFSC  FD8.2
00E30:  BRA    136C
00E32:  BRA    138E
....................       { 
....................          case 0x13: 
....................          fprintf (fab, "Start 0x13\r\n") ; 
00E34:  MOVLW  30
00E36:  MOVWF  FF6
00E38:  MOVLW  05
00E3A:  MOVWF  FF7
00E3C:  MOVLW  00
00E3E:  MOVWF  FF8
00E40:  RCALL  0758
....................          output_low (PIN_A5); //Main side 
00E42:  BCF    F92.5
00E44:  BCF    F89.5
....................          address_data[0] = command[1]<<24; 
00E46:  MOVFF  139,181
00E4A:  MOVLB  1
00E4C:  CLRF   x7E
00E4E:  CLRF   x7F
00E50:  CLRF   x80
....................          address_data[1] = command[2]<<16; 
00E52:  MOVFF  13A,184
00E56:  CLRF   x82
00E58:  CLRF   x83
00E5A:  CLRF   x85
....................          address_data[2] = command[3]<<8; 
00E5C:  MOVFF  13B,187
00E60:  CLRF   x86
00E62:  CLRF   x88
00E64:  CLRF   x89
....................          address_data[3] = command[4]; 
00E66:  CLRF   x8D
00E68:  CLRF   x8C
00E6A:  CLRF   x8B
00E6C:  MOVFF  13C,18A
....................          address = address_data[0] + address_data[1] + address_data[2] + address_data[3]; 
00E70:  MOVF   x82,W
00E72:  ADDWF  x7E,W
00E74:  MOVLB  2
00E76:  MOVWF  x07
00E78:  MOVLB  1
00E7A:  MOVF   x83,W
00E7C:  ADDWFC x7F,W
00E7E:  MOVLB  2
00E80:  MOVWF  x08
00E82:  MOVLB  1
00E84:  MOVF   x84,W
00E86:  ADDWFC x80,W
00E88:  MOVLB  2
00E8A:  MOVWF  x09
00E8C:  MOVLB  1
00E8E:  MOVF   x85,W
00E90:  ADDWFC x81,W
00E92:  MOVLB  2
00E94:  MOVWF  x0A
00E96:  MOVLB  1
00E98:  MOVF   x86,W
00E9A:  MOVLB  2
00E9C:  ADDWF  x07,F
00E9E:  MOVLB  1
00EA0:  MOVF   x87,W
00EA2:  MOVLB  2
00EA4:  ADDWFC x08,F
00EA6:  MOVLB  1
00EA8:  MOVF   x88,W
00EAA:  MOVLB  2
00EAC:  ADDWFC x09,F
00EAE:  MOVLB  1
00EB0:  MOVF   x89,W
00EB2:  MOVLB  2
00EB4:  ADDWFC x0A,F
00EB6:  MOVLB  1
00EB8:  MOVF   x8A,W
00EBA:  MOVLB  2
00EBC:  ADDWF  x07,W
00EBE:  MOVLB  1
00EC0:  MOVWF  x8E
00EC2:  MOVF   x8B,W
00EC4:  MOVLB  2
00EC6:  ADDWFC x08,W
00EC8:  MOVLB  1
00ECA:  MOVWF  x8F
00ECC:  MOVF   x8C,W
00ECE:  MOVLB  2
00ED0:  ADDWFC x09,W
00ED2:  MOVLB  1
00ED4:  MOVWF  x90
00ED6:  MOVF   x8D,W
00ED8:  MOVLB  2
00EDA:  ADDWFC x0A,W
00EDC:  MOVLB  1
00EDE:  MOVWF  x91
....................          TRANSFER_DATA_NBYTE_TOFAB_SMF(address, command[5] + command[6]); 
00EE0:  MOVF   x3E,W
00EE2:  ADDWF  x3D,W
00EE4:  MOVLB  2
00EE6:  MOVWF  x07
00EE8:  MOVFF  191,20B
00EEC:  MOVFF  190,20A
00EF0:  MOVFF  18F,209
00EF4:  MOVFF  18E,208
00EF8:  CLRF   x0F
00EFA:  CLRF   x0E
00EFC:  CLRF   x0D
00EFE:  MOVWF  x0C
00F00:  MOVLB  0
00F02:  BRA    0868
....................          fprintf (fab, "Finish 0x13\r\n") ; 
00F04:  MOVLW  3E
00F06:  MOVWF  FF6
00F08:  MOVLW  05
00F0A:  MOVWF  FF7
00F0C:  MOVLW  00
00F0E:  MOVWF  FF8
00F10:  RCALL  0758
....................           
....................          break; 
00F12:  BRA    138E
....................           
....................          case 0x14://Main side 
....................          output_low (PIN_A5) ; 
00F14:  BCF    F92.5
00F16:  BCF    F89.5
....................          fprintf (fab, "Start 0x14\r\n") ; 
00F18:  MOVLW  4C
00F1A:  MOVWF  FF6
00F1C:  MOVLW  05
00F1E:  MOVWF  FF7
00F20:  MOVLW  00
00F22:  MOVWF  FF8
00F24:  RCALL  0758
....................          address_data[0] = command[1]<<24; 
00F26:  MOVFF  139,181
00F2A:  MOVLB  1
00F2C:  CLRF   x7E
00F2E:  CLRF   x7F
00F30:  CLRF   x80
....................          address_data[1] = command[2]<<16; 
00F32:  MOVFF  13A,184
00F36:  CLRF   x82
00F38:  CLRF   x83
00F3A:  CLRF   x85
....................          address_data[2] = command[3]<<8; 
00F3C:  MOVFF  13B,187
00F40:  CLRF   x86
00F42:  CLRF   x88
00F44:  CLRF   x89
....................          address_data[3] = command[4]; 
00F46:  CLRF   x8D
00F48:  CLRF   x8C
00F4A:  CLRF   x8B
00F4C:  MOVFF  13C,18A
....................          address = address_data[0] + address_data[1] + address_data[2] + address_data[3]; 
00F50:  MOVF   x82,W
00F52:  ADDWF  x7E,W
00F54:  MOVLB  2
00F56:  MOVWF  x07
00F58:  MOVLB  1
00F5A:  MOVF   x83,W
00F5C:  ADDWFC x7F,W
00F5E:  MOVLB  2
00F60:  MOVWF  x08
00F62:  MOVLB  1
00F64:  MOVF   x84,W
00F66:  ADDWFC x80,W
00F68:  MOVLB  2
00F6A:  MOVWF  x09
00F6C:  MOVLB  1
00F6E:  MOVF   x85,W
00F70:  ADDWFC x81,W
00F72:  MOVLB  2
00F74:  MOVWF  x0A
00F76:  MOVLB  1
00F78:  MOVF   x86,W
00F7A:  MOVLB  2
00F7C:  ADDWF  x07,F
00F7E:  MOVLB  1
00F80:  MOVF   x87,W
00F82:  MOVLB  2
00F84:  ADDWFC x08,F
00F86:  MOVLB  1
00F88:  MOVF   x88,W
00F8A:  MOVLB  2
00F8C:  ADDWFC x09,F
00F8E:  MOVLB  1
00F90:  MOVF   x89,W
00F92:  MOVLB  2
00F94:  ADDWFC x0A,F
00F96:  MOVLB  1
00F98:  MOVF   x8A,W
00F9A:  MOVLB  2
00F9C:  ADDWF  x07,W
00F9E:  MOVLB  1
00FA0:  MOVWF  x8E
00FA2:  MOVF   x8B,W
00FA4:  MOVLB  2
00FA6:  ADDWFC x08,W
00FA8:  MOVLB  1
00FAA:  MOVWF  x8F
00FAC:  MOVF   x8C,W
00FAE:  MOVLB  2
00FB0:  ADDWFC x09,W
00FB2:  MOVLB  1
00FB4:  MOVWF  x90
00FB6:  MOVF   x8D,W
00FB8:  MOVLB  2
00FBA:  ADDWFC x0A,W
00FBC:  MOVLB  1
00FBE:  MOVWF  x91
....................          sector_erase_SMF (address); 
00FC0:  MOVFF  191,20A
00FC4:  MOVFF  190,209
00FC8:  MOVFF  18F,208
00FCC:  MOVFF  18E,207
00FD0:  MOVLB  0
00FD2:  BRA    08F2
....................          WRITE_DATA_BYTE_SMF (address, command[5]) ; 
00FD4:  MOVFF  191,20E
00FD8:  MOVFF  190,20D
00FDC:  MOVFF  18F,20C
00FE0:  MOVFF  18E,20B
00FE4:  MOVFF  13D,20F
00FE8:  RCALL  0984
....................          WRITE_DATA_BYTE_SMF (address + 1, command[6]) ; 
00FEA:  MOVLW  01
00FEC:  MOVLB  1
00FEE:  ADDWF  x8E,W
00FF0:  MOVLB  2
00FF2:  MOVWF  x07
00FF4:  MOVLW  00
00FF6:  MOVLB  1
00FF8:  ADDWFC x8F,W
00FFA:  MOVLB  2
00FFC:  MOVWF  x08
00FFE:  MOVLW  00
01000:  MOVLB  1
01002:  ADDWFC x90,W
01004:  MOVLB  2
01006:  MOVWF  x09
01008:  MOVLW  00
0100A:  MOVLB  1
0100C:  ADDWFC x91,W
0100E:  MOVLB  2
01010:  MOVWF  x0A
01012:  MOVWF  x0E
01014:  MOVFF  209,20D
01018:  MOVFF  208,20C
0101C:  MOVFF  207,20B
01020:  MOVFF  13E,20F
01024:  MOVLB  0
01026:  RCALL  0984
....................          WRITE_DATA_BYTE_SMF (address + 2, command[7]) ; 
01028:  MOVLW  02
0102A:  MOVLB  1
0102C:  ADDWF  x8E,W
0102E:  MOVLB  2
01030:  MOVWF  x07
01032:  MOVLW  00
01034:  MOVLB  1
01036:  ADDWFC x8F,W
01038:  MOVLB  2
0103A:  MOVWF  x08
0103C:  MOVLW  00
0103E:  MOVLB  1
01040:  ADDWFC x90,W
01042:  MOVLB  2
01044:  MOVWF  x09
01046:  MOVLW  00
01048:  MOVLB  1
0104A:  ADDWFC x91,W
0104C:  MOVLB  2
0104E:  MOVWF  x0A
01050:  MOVWF  x0E
01052:  MOVFF  209,20D
01056:  MOVFF  208,20C
0105A:  MOVFF  207,20B
0105E:  MOVFF  13F,20F
01062:  MOVLB  0
01064:  RCALL  0984
....................          WRITE_DATA_BYTE_SMF (address + 3, command[8]) ; 
01066:  MOVLW  03
01068:  MOVLB  1
0106A:  ADDWF  x8E,W
0106C:  MOVLB  2
0106E:  MOVWF  x07
01070:  MOVLW  00
01072:  MOVLB  1
01074:  ADDWFC x8F,W
01076:  MOVLB  2
01078:  MOVWF  x08
0107A:  MOVLW  00
0107C:  MOVLB  1
0107E:  ADDWFC x90,W
01080:  MOVLB  2
01082:  MOVWF  x09
01084:  MOVLW  00
01086:  MOVLB  1
01088:  ADDWFC x91,W
0108A:  MOVLB  2
0108C:  MOVWF  x0A
0108E:  MOVWF  x0E
01090:  MOVFF  209,20D
01094:  MOVFF  208,20C
01098:  MOVFF  207,20B
0109C:  MOVFF  140,20F
010A0:  MOVLB  0
010A2:  RCALL  0984
....................          fprintf (fab, "Finish 0x14\r\n"); 
010A4:  MOVLW  5A
010A6:  MOVWF  FF6
010A8:  MOVLW  05
010AA:  MOVWF  FF7
010AC:  MOVLW  00
010AE:  MOVWF  FF8
010B0:  CALL   0758
....................          break; 
010B4:  BRA    138E
....................           
....................          case 0x16: 
....................          output_low (PIN_A5); 
010B6:  BCF    F92.5
010B8:  BCF    F89.5
....................          fprintf(fab, "Start 0x16\r\n"); 
010BA:  MOVLW  68
010BC:  MOVWF  FF6
010BE:  MOVLW  05
010C0:  MOVWF  FF7
010C2:  MOVLW  00
010C4:  MOVWF  FF8
010C6:  CALL   0758
....................          address_data[0] = command[1]<<24; 
010CA:  MOVFF  139,181
010CE:  MOVLB  1
010D0:  CLRF   x7E
010D2:  CLRF   x7F
010D4:  CLRF   x80
....................          address_data[1] = command[2]<<16; 
010D6:  MOVFF  13A,184
010DA:  CLRF   x82
010DC:  CLRF   x83
010DE:  CLRF   x85
....................          address_data[2] = command[3]<<8; 
010E0:  MOVFF  13B,187
010E4:  CLRF   x86
010E6:  CLRF   x88
010E8:  CLRF   x89
....................          address_data[3] = command[4]; 
010EA:  CLRF   x8D
010EC:  CLRF   x8C
010EE:  CLRF   x8B
010F0:  MOVFF  13C,18A
....................          address = address_data[0] + address_data[1] + address_data[2] + address_data[3]; 
010F4:  MOVF   x82,W
010F6:  ADDWF  x7E,W
010F8:  MOVLB  2
010FA:  MOVWF  x07
010FC:  MOVLB  1
010FE:  MOVF   x83,W
01100:  ADDWFC x7F,W
01102:  MOVLB  2
01104:  MOVWF  x08
01106:  MOVLB  1
01108:  MOVF   x84,W
0110A:  ADDWFC x80,W
0110C:  MOVLB  2
0110E:  MOVWF  x09
01110:  MOVLB  1
01112:  MOVF   x85,W
01114:  ADDWFC x81,W
01116:  MOVLB  2
01118:  MOVWF  x0A
0111A:  MOVLB  1
0111C:  MOVF   x86,W
0111E:  MOVLB  2
01120:  ADDWF  x07,F
01122:  MOVLB  1
01124:  MOVF   x87,W
01126:  MOVLB  2
01128:  ADDWFC x08,F
0112A:  MOVLB  1
0112C:  MOVF   x88,W
0112E:  MOVLB  2
01130:  ADDWFC x09,F
01132:  MOVLB  1
01134:  MOVF   x89,W
01136:  MOVLB  2
01138:  ADDWFC x0A,F
0113A:  MOVLB  1
0113C:  MOVF   x8A,W
0113E:  MOVLB  2
01140:  ADDWF  x07,W
01142:  MOVLB  1
01144:  MOVWF  x8E
01146:  MOVF   x8B,W
01148:  MOVLB  2
0114A:  ADDWFC x08,W
0114C:  MOVLB  1
0114E:  MOVWF  x8F
01150:  MOVF   x8C,W
01152:  MOVLB  2
01154:  ADDWFC x09,W
01156:  MOVLB  1
01158:  MOVWF  x90
0115A:  MOVF   x8D,W
0115C:  MOVLB  2
0115E:  ADDWFC x0A,W
01160:  MOVLB  1
01162:  MOVWF  x91
....................             switch(command[5]){ 
01164:  MOVF   x3D,W
01166:  XORLW  04
01168:  MOVLB  0
0116A:  BZ    1172
0116C:  XORLW  36
0116E:  BZ    1184
01170:  BRA    1196
....................                case 0x04: 
....................                   SUBSECTOR_4KB_ERASE_SMF(address); 
01172:  MOVFF  191,20A
01176:  MOVFF  190,209
0117A:  MOVFF  18F,208
0117E:  MOVFF  18E,207
01182:  BRA    09F8
....................                case 0x32: 
....................                   SUBSECTOR_32KB_ERASE_SMF(address); 
01184:  MOVFF  191,20A
01188:  MOVFF  190,209
0118C:  MOVFF  18F,208
01190:  MOVFF  18E,207
01194:  BRA    0A8A
....................             } 
....................           
....................          /* case 0x91: 
....................          reset_time_data[0] = 0x82; 
....................          //fprintf (PC, "Command 2 Recieved\r\n") ; 
....................          //fputc (reset_time_data[0], PC) ; 
....................          fputc (0x91, reset); 
....................          break; */ 
....................          case 0x91://Finish 
....................          fprintf (fab, "Start 0x91\r\n"); 
01196:  MOVLW  76
01198:  MOVWF  FF6
0119A:  MOVLW  05
0119C:  MOVWF  FF7
0119E:  MOVLW  00
011A0:  MOVWF  FF8
011A2:  CALL   0758
....................          for (i = 0; i < 9; i++) 
011A6:  MOVLB  1
011A8:  CLRF   xF6
011AA:  MOVF   xF6,W
011AC:  SUBLW  08
011AE:  BNC   11EA
....................          { 
....................             PINO_DATA[i] = command[i]; 
011B0:  CLRF   03
011B2:  MOVF   xF6,W
011B4:  ADDLW  4C
011B6:  MOVWF  01
011B8:  MOVLW  01
011BA:  ADDWFC 03,F
011BC:  MOVLB  2
011BE:  MOVFF  03,208
011C2:  CLRF   03
011C4:  MOVLB  1
011C6:  MOVF   xF6,W
011C8:  ADDLW  38
011CA:  MOVWF  FE9
011CC:  MOVLW  01
011CE:  ADDWFC 03,W
011D0:  MOVWF  FEA
011D2:  MOVFF  FEF,209
011D6:  MOVLB  2
011D8:  MOVFF  208,FEA
011DC:  MOVFF  01,FE9
011E0:  MOVFF  209,FEF
011E4:  MOVLB  1
011E6:  INCF   xF6,F
011E8:  BRA    11AA
....................          } 
....................           
....................          for (i = 0; i<24; i++) 
011EA:  CLRF   xF6
011EC:  MOVF   xF6,W
011EE:  SUBLW  17
011F0:  BNC   120E
....................          { 
....................             fputc (PINO_DATA[i], DC); 
011F2:  CLRF   03
011F4:  MOVF   xF6,W
011F6:  ADDLW  4C
011F8:  MOVWF  FE9
011FA:  MOVLW  01
011FC:  ADDWFC 03,W
011FE:  MOVWF  FEA
01200:  MOVFF  FEF,210
01204:  MOVLB  0
01206:  RCALL  0B1C
01208:  MOVLB  1
0120A:  INCF   xF6,F
0120C:  BRA    11EC
....................          } 
....................          fprintf (fab, "Finish 0x91\r\n") ; 
0120E:  MOVLW  84
01210:  MOVWF  FF6
01212:  MOVLW  05
01214:  MOVWF  FF7
01216:  MOVLW  00
01218:  MOVWF  FF8
0121A:  MOVLB  0
0121C:  CALL   0758
....................          break; 
01220:  BRA    138E
....................           
....................          case 0x92: 
....................          fprintf (fab, "Start 0x92\r\n") ; 
01222:  MOVLW  92
01224:  MOVWF  FF6
01226:  MOVLW  05
01228:  MOVWF  FF7
0122A:  MOVLW  00
0122C:  MOVWF  FF8
0122E:  CALL   0758
....................          for (i = 0; i < 9; i++) 
01232:  MOVLB  1
01234:  CLRF   xF6
01236:  MOVF   xF6,W
01238:  SUBLW  08
0123A:  BNC   1276
....................          { 
....................             PINO_data[i] = command[i]; 
0123C:  CLRF   03
0123E:  MOVF   xF6,W
01240:  ADDLW  4C
01242:  MOVWF  01
01244:  MOVLW  01
01246:  ADDWFC 03,F
01248:  MOVLB  2
0124A:  MOVFF  03,208
0124E:  CLRF   03
01250:  MOVLB  1
01252:  MOVF   xF6,W
01254:  ADDLW  38
01256:  MOVWF  FE9
01258:  MOVLW  01
0125A:  ADDWFC 03,W
0125C:  MOVWF  FEA
0125E:  MOVFF  FEF,209
01262:  MOVLB  2
01264:  MOVFF  208,FEA
01268:  MOVFF  01,FE9
0126C:  MOVFF  209,FEF
01270:  MOVLB  1
01272:  INCF   xF6,F
01274:  BRA    1236
....................          } 
....................           
....................          for (i = 0; i<24; i++) 
01276:  CLRF   xF6
01278:  MOVF   xF6,W
0127A:  SUBLW  17
0127C:  BNC   129A
....................          { 
....................             fputc (PINO_DATA[i], DC); 
0127E:  CLRF   03
01280:  MOVF   xF6,W
01282:  ADDLW  4C
01284:  MOVWF  FE9
01286:  MOVLW  01
01288:  ADDWFC 03,W
0128A:  MOVWF  FEA
0128C:  MOVFF  FEF,210
01290:  MOVLB  0
01292:  RCALL  0B1C
01294:  MOVLB  1
01296:  INCF   xF6,F
01298:  BRA    1278
....................          } 
....................           
....................          while (1) 
....................          { 
....................             if (kbhit (DC)) 
0129A:  BTFSC  F86.1
0129C:  BRA    1312
....................             { 
....................                for (i = 0; i < 10; i++) 
0129E:  CLRF   xF6
012A0:  MOVF   xF6,W
012A2:  SUBLW  09
012A4:  BNC   12D2
....................                { 
....................                   Down[i] = fgetc (DC); 
012A6:  CLRF   03
012A8:  MOVF   xF6,W
012AA:  ADDLW  9A
012AC:  MOVWF  FE9
012AE:  MOVLW  01
012B0:  ADDWFC 03,W
012B2:  MOVWF  FEA
012B4:  MOVFF  FEA,20A
012B8:  MOVFF  FE9,209
012BC:  MOVLB  0
012BE:  BRA    0B62
012C0:  MOVFF  20A,FEA
012C4:  MOVFF  209,FE9
012C8:  MOVFF  01,FEF
012CC:  MOVLB  1
012CE:  INCF   xF6,F
012D0:  BRA    12A0
....................                } 
....................                //fprintf (fab, "Finish transmitting\r\n") ; 
....................                for (i = 0; i < 10; i++) 
012D2:  CLRF   xF6
012D4:  MOVF   xF6,W
012D6:  SUBLW  09
012D8:  BNC   12FC
....................                { 
....................                   fputc (Down[i], fab); 
012DA:  CLRF   03
012DC:  MOVF   xF6,W
012DE:  ADDLW  9A
012E0:  MOVWF  FE9
012E2:  MOVLW  01
012E4:  ADDWFC 03,W
012E6:  MOVWF  FEA
012E8:  MOVFF  FEF,207
012EC:  MOVLB  2
012EE:  MOVF   x07,W
012F0:  MOVLB  0
012F2:  CALL   085C
012F6:  MOVLB  1
012F8:  INCF   xF6,F
012FA:  BRA    12D4
....................                } 
....................                fprintf (fab, "Finish 0x92\r\n") ; 
012FC:  MOVLW  A0
012FE:  MOVWF  FF6
01300:  MOVLW  05
01302:  MOVWF  FF7
01304:  MOVLW  00
01306:  MOVWF  FF8
01308:  MOVLB  0
0130A:  CALL   0758
....................                break; 
0130E:  BRA    1316
01310:  MOVLB  1
....................             } 
01312:  BRA    129A
01314:  MOVLB  0
....................          } 
....................           
....................          case 0x93: 
....................          fprintf(fab, "Start 0x93\r\n"); 
01316:  MOVLW  AE
01318:  MOVWF  FF6
0131A:  MOVLW  05
0131C:  MOVWF  FF7
0131E:  MOVLW  00
01320:  MOVWF  FF8
01322:  CALL   0758
....................          output_high (PINO_power); 
01326:  BCF    F95.5
01328:  BSF    F8C.5
....................          output_high (sel); 
0132A:  BCF    F95.6
0132C:  BSF    F8C.6
....................          fprintf(fab, "Finish 0x93\r\n"); 
0132E:  MOVLW  BC
01330:  MOVWF  FF6
01332:  MOVLW  05
01334:  MOVWF  FF7
01336:  MOVLW  00
01338:  MOVWF  FF8
0133A:  CALL   0758
....................           
....................           
....................          case 0x9B: 
....................          fprintf (fab, "Start 0x9B\r\n") ; 
0133E:  MOVLW  CA
01340:  MOVWF  FF6
01342:  MOVLW  05
01344:  MOVWF  FF7
01346:  MOVLW  00
01348:  MOVWF  FF8
0134A:  CALL   0758
....................          output_high (hvs); 
0134E:  BCF    F95.7
01350:  BSF    F8C.7
....................          fprintf (fab, "Finish 0x9B\r\n"); 
01352:  MOVLW  D8
01354:  MOVWF  FF6
01356:  MOVLW  05
01358:  MOVWF  FF7
0135A:  MOVLW  00
0135C:  MOVWF  FF8
0135E:  CALL   0758
....................          output_low (PINO_power); 
01362:  BCF    F95.5
01364:  BCF    F8C.5
....................          output_low (sel); 
01366:  BCF    F95.6
01368:  BCF    F8C.6
....................          break; 
0136A:  BRA    138E
....................           
....................          case 0x9F://Finish 
....................          fprintf (fab, "Start 0x9F\r\n") ; 
0136C:  MOVLW  E6
0136E:  MOVWF  FF6
01370:  MOVLW  05
01372:  MOVWF  FF7
01374:  MOVLW  00
01376:  MOVWF  FF8
01378:  CALL   0758
....................          GET_RESET_DATA (); 
0137C:  BRA    0C68
....................          fprintf (fab, "Finish 0x9F\r\n") ; 
0137E:  MOVLW  F4
01380:  MOVWF  FF6
01382:  MOVLW  05
01384:  MOVWF  FF7
01386:  MOVLW  00
01388:  MOVWF  FF8
0138A:  CALL   0758
....................          break; 
....................       } 
0138E:  MOVLB  1
01390:  BRA    0D82
....................    } 
01392:  MOVLB  0
01394:  GOTO   1610 (RETURN)
.................... } 
.................... void GET_RESET_DATA()                                                            //funcion que carga el array HKDATA con los datos del Reset PIC 
.................... { 
....................    dummy[0] = 0x11; 
*
00C68:  MOVLW  11
00C6A:  MOVLB  1
00C6C:  MOVWF  xF4
....................    Finish_sign[0] = 0xFF; 
00C6E:  SETF   xF5
....................    RESET_DATA = 0; 
00C70:  MOVLB  0
00C72:  CLRF   xED
....................    int8 dayh; 
....................    int8 dayl; 
....................    int8 hr; 
....................    int8 min; 
....................    int8 sec; 
....................    int8 j; 
....................    for (int i = 0; i < 6; i++) 
00C74:  MOVLB  2
00C76:  CLRF   x0D
00C78:  MOVF   x0D,W
00C7A:  SUBLW  05
00C7C:  BNC   0C94
....................    { 
....................       COLLECT_RESET_DATA (); 
00C7E:  MOVLB  0
00C80:  BRA    0C20
....................       if (reset_bffr[0] == 0x8e) 
00C82:  MOVF   xEE,W
00C84:  SUBLW  8E
00C86:  BNZ   0C8E
....................       { 
....................          break; 
00C88:  MOVLB  2
00C8A:  BRA    0C94
00C8C:  MOVLB  0
....................       } 
00C8E:  MOVLB  2
00C90:  INCF   x0D,F
00C92:  BRA    0C78
....................    } 
....................    if (RESET_bffr[0] == 0x8e)   //si el byte de cabecera es el correcto 
00C94:  MOVLB  0
00C96:  MOVF   xEE,W
00C98:  SUBLW  8E
00C9A:  BNZ   0D6A
....................    { 
....................       // fprintf (PC, "\r\nRESET DATA OBTAINED\r\n") ; 
....................       for (int num = 0; num < 5; num++)   //carga el array HKDATA con timedata en las posiciones 2 al 6 
00C9C:  MOVLB  2
00C9E:  CLRF   x0E
00CA0:  MOVF   x0E,W
00CA2:  SUBLW  04
00CA4:  BNC   0CDA
....................       { 
....................          reset_time_data[num] = reset_bffr[num + 1]; 
00CA6:  CLRF   03
00CA8:  MOVF   x0E,W
00CAA:  ADDLW  41
00CAC:  MOVWF  01
00CAE:  MOVLW  01
00CB0:  ADDWFC 03,F
00CB2:  MOVFF  03,210
00CB6:  MOVLW  01
00CB8:  ADDWF  x0E,W
00CBA:  CLRF   03
00CBC:  ADDLW  EE
00CBE:  MOVWF  FE9
00CC0:  MOVLW  00
00CC2:  ADDWFC 03,W
00CC4:  MOVWF  FEA
00CC6:  MOVFF  FEF,211
00CCA:  MOVFF  210,FEA
00CCE:  MOVFF  01,FE9
00CD2:  MOVFF  211,FEF
00CD6:  INCF   x0E,F
00CD8:  BRA    0CA0
....................          //fputc (reset_bffr[num + 1], DC); 
....................          //fprintf (PC, " % x, ", reset_bffr[num + 1]) ; 
....................       } 
....................       //fputc (dummy[0], DC); 
....................       sec = reset_time_data[0]; 
00CDA:  MOVFF  141,20B
....................       min = reset_time_data[1]; 
00CDE:  MOVFF  142,20A
....................       hr = reset_time_data[2]; 
00CE2:  MOVFF  143,209
....................       dayl = reset_time_data[3]; 
00CE6:  MOVFF  144,208
....................       dayh = reset_time_data[4]; 
00CEA:  MOVFF  145,207
....................       fprintf (fab, "\r\n") ; 
00CEE:  MOVLW  0D
00CF0:  BTFSS  FA6.4
00CF2:  BRA    0CF0
00CF4:  MOVLB  F
00CF6:  MOVWF  x29
00CF8:  MOVLW  0A
00CFA:  BTFSS  FA6.4
00CFC:  BRA    0CFA
00CFE:  MOVWF  x29
....................        
....................       PINO_DATA[0] = 0x81; 
00D00:  MOVLW  81
00D02:  MOVLB  1
00D04:  MOVWF  x4C
....................        
....................       PINO_DATA[1] = reset_time_data[0]; 
00D06:  MOVFF  141,14D
....................       PINO_DATA[2] = reset_time_data[1]; 
00D0A:  MOVFF  142,14E
....................       PINO_DATA[3] = reset_time_data[2]; 
00D0E:  MOVFF  143,14F
....................       PINO_DATA[4] = reset_time_data[3]; 
00D12:  MOVFF  144,150
....................       PINO_DATA[5] = reset_time_data[4]; 
00D16:  MOVFF  145,151
....................        
....................       for(i=6; i<39; i++) 
00D1A:  MOVLW  06
00D1C:  MOVLB  2
00D1E:  MOVWF  x0D
00D20:  MOVF   x0D,W
00D22:  SUBLW  26
00D24:  BNC   0D3C
....................       { 
....................          PINO_DATA[i] = 0x01; 
00D26:  CLRF   03
00D28:  MOVF   x0D,W
00D2A:  ADDLW  4C
00D2C:  MOVWF  FE9
00D2E:  MOVLW  01
00D30:  ADDWFC 03,W
00D32:  MOVWF  FEA
00D34:  MOVLW  01
00D36:  MOVWF  FEF
00D38:  INCF   x0D,F
00D3A:  BRA    0D20
....................          } 
....................        
....................        
....................        
....................       for (j = 0; j < 39; j++) 
00D3C:  CLRF   x0C
00D3E:  MOVF   x0C,W
00D40:  SUBLW  26
00D42:  BNC   0D60
....................       { 
....................          //fprintf (fab, " % x, ", PINO_DATA[j]) ; 
....................           
....................          fputc (PINO_DATA[j], DC); 
00D44:  CLRF   03
00D46:  MOVF   x0C,W
00D48:  ADDLW  4C
00D4A:  MOVWF  FE9
00D4C:  MOVLW  01
00D4E:  ADDWFC 03,W
00D50:  MOVWF  FEA
00D52:  MOVFF  FEF,210
00D56:  MOVLB  0
00D58:  RCALL  0B1C
00D5A:  MOVLB  2
00D5C:  INCF   x0C,F
00D5E:  BRA    0D3E
....................       } 
....................       fputc (Finish_sign[0], DC); 
00D60:  MOVFF  1F5,210
00D64:  MOVLB  0
00D66:  RCALL  0B1C
....................        
....................       //fprintf (fab, "\r\n") ; 
....................        
....................       }else{ 
00D68:  BRA    0D78
....................       fprintf (fab, "\r\nRESET DATA NO OBTAINED\r\n") ; 
00D6A:  MOVLW  02
00D6C:  MOVWF  FF6
00D6E:  MOVLW  06
00D70:  MOVWF  FF7
00D72:  MOVLW  00
00D74:  MOVWF  FF8
00D76:  RCALL  0758
....................    } 
....................    return; 
00D78:  GOTO   137E (RETURN)
.................... } 
....................  
....................  
.................... #include<SATELLITE_LOG.c> 
.................... void waiting(int32 counterval)                                                   //about 200000 : 1s 
.................... { 
....................    for(int32 num = 0; num < counterval; num++) 
*
00BE0:  MOVLB  2
00BE2:  CLRF   x17
00BE4:  CLRF   x16
00BE6:  CLRF   x15
00BE8:  CLRF   x14
00BEA:  MOVF   x17,W
00BEC:  SUBWF  x13,W
00BEE:  BNC   0C1A
00BF0:  BNZ   0C08
00BF2:  MOVF   x16,W
00BF4:  SUBWF  x12,W
00BF6:  BNC   0C1A
00BF8:  BNZ   0C08
00BFA:  MOVF   x15,W
00BFC:  SUBWF  x11,W
00BFE:  BNC   0C1A
00C00:  BNZ   0C08
00C02:  MOVF   x10,W
00C04:  SUBWF  x14,W
00C06:  BC    0C1A
....................    {} 
00C08:  MOVLW  01
00C0A:  ADDWF  x14,F
00C0C:  BTFSC  FD8.0
00C0E:  INCF   x15,F
00C10:  BTFSC  FD8.2
00C12:  INCF   x16,F
00C14:  BTFSC  FD8.2
00C16:  INCF   x17,F
00C18:  BRA    0BEA
....................    return; 
00C1A:  MOVLB  0
00C1C:  GOTO   0C50 (RETURN)
.................... } 
....................  
.................... //--------RESET Function--------------------------------------------- 
....................  
....................  
.................... void DELETE_RESET()                                                              //funcion que pone a cero el vector reset_bffr[] 
.................... { 
....................    for(int8 num = 0; num < Reset_size; num++) 
*
00BAE:  MOVLB  2
00BB0:  CLRF   x10
00BB2:  MOVF   x10,W
00BB4:  SUBLW  0A
00BB6:  BNC   0BCC
....................    { 
....................       reset_bffr[num] = 0; 
00BB8:  CLRF   03
00BBA:  MOVF   x10,W
00BBC:  ADDLW  EE
00BBE:  MOVWF  FE9
00BC0:  MOVLW  00
00BC2:  ADDWFC 03,W
00BC4:  MOVWF  FEA
00BC6:  CLRF   FEF
00BC8:  INCF   x10,F
00BCA:  BRA    0BB2
....................    } 
....................    return; 
00BCC:  MOVLB  0
00BCE:  GOTO   0C22 (RETURN)
.................... } 
....................  
.................... void SEND_CMD_FOR_RESET_SATELLITE() 
.................... {   
....................    STORE_FLAG_INFO();                                                            //save flag data to flash memory 
....................    //Save_RSV();                                                                   //save in flash memory reserve_table[] content 
....................    STORE_ADRESS_DATA_TO_FLASH(); 
.................... // while(true) 
.................... // { 
....................       //fputc(0x27,PC); 
....................       fprintf(PC,"%x,",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-122));                   //sec 
....................       fprintf(PC,"%x,",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-121));                   //min 
....................       fprintf(PC,"%x,",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-120));                   //hou 
....................       fprintf(PC,"%x",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-119));                    //day H 
....................       fprintf(PC,"%x\r\n",READ_DATA_BYTE_OF(FAB_HK_ADDRESS-118));                //day L 
....................         for(int i = 0; i<100; i++) 
....................         { 
....................          fputc(0x27,reset);                                                      //send command for satellite reset 
....................          delay_ms(10); 
....................         } 
....................       //delay_ms(100);//if it is needed 
.................... //!      fputc(READ_DATA_BYTE_OF(FAB_HK_ADDRESS-122),reset); 
.................... //!      fputc(READ_DATA_BYTE_OF(FAB_HK_ADDRESS-121),reset); 
.................... //!      fputc(READ_DATA_BYTE_OF(FAB_HK_ADDRESS-120),reset); 
.................... //!      fputc(READ_DATA_BYTE_OF(FAB_HK_ADDRESS-119),reset); 
.................... //!      fputc(READ_DATA_BYTE_OF(FAB_HK_ADDRESS-118),reset); 
....................       RESET_DATA = 0; 
....................       fprintf(PC,"Ready for reset"); 
....................       delay_ms(1000); 
.................... // } 
....................    return; 
.................... } 
....................  
.................... void RESET_SATELLITE()                                                           //if get reset command from reset, prepare for resetting 
.................... { 
....................    if(reset_flag == 1)                                                           //get ready for reset satellite 
....................    { 
....................       SEND_CMD_FOR_RESET_SATELLITE();                                            //store flag, save RSV, store Address, send command and wait for reset 
....................    } 
....................    DELETE_RESET();                                                               //load zero in reset_bffr[] 
....................    RESET_DATA = 0; 
....................    return; 
.................... } 
....................  
.................... void COLLECT_RESET_DATA()                                                        //funcion que envia el comando 0x28 al reset PIC y carga reset_bffr[] 
.................... { 
....................    DELETE_RESET();                                                               //pone a cero todas las posiciones del vector 
*
00C20:  BRA    0BAE
....................    RESET_DATA = 0; 
00C22:  CLRF   xED
....................    for(int m=0; m<10; m++) 
00C24:  MOVLB  2
00C26:  CLRF   x0F
00C28:  MOVF   x0F,W
00C2A:  SUBLW  09
00C2C:  BNC   0C62
....................    { 
....................       fputc(0x28,reset);                                                            //Envia el comando 0x28 en el puerto del reset PIC 
00C2E:  MOVLW  28
00C30:  MOVLB  0
00C32:  BRA    0BD2
....................       delay_ms(10); 
00C34:  MOVLW  0A
00C36:  MOVLB  2
00C38:  MOVWF  x10
00C3A:  MOVLB  0
00C3C:  RCALL  072E
....................       waiting(10000);                                                               //wait aprox 0.5s para que el RESET PIC envie los datos por el UART (interrupcion) 
00C3E:  MOVLB  2
00C40:  CLRF   x13
00C42:  CLRF   x12
00C44:  MOVLW  27
00C46:  MOVWF  x11
00C48:  MOVLW  10
00C4A:  MOVWF  x10
00C4C:  MOVLB  0
00C4E:  BRA    0BE0
....................          if(RESET_bffr[0] == 0x8e) 
00C50:  MOVF   xEE,W
00C52:  SUBLW  8E
00C54:  BNZ   0C5C
....................          { 
....................          break; 
00C56:  MOVLB  2
00C58:  BRA    0C62
00C5A:  MOVLB  0
....................          } 
00C5C:  MOVLB  2
00C5E:  INCF   x0F,F
00C60:  BRA    0C28
....................    } 
....................    return; 
00C62:  MOVLB  0
00C64:  GOTO   0C82 (RETURN)
.................... } 
....................  
....................  
.................... //@@@@@@@@@@@for satellite log@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... #define logdata_size 11 
.................... int8 satellitelog[logdata_size] = {}; 
....................  
.................... void SAVE_SAT_LOG(int8 data1, int8 data2, int8 data3) 
.................... { 
....................    LOOP_SAT_LOG();                                                               //hace un loop en las posiciones de memoria para almacenar SAT_LOG 
....................    RESET_DATA = 0; 
....................    COLLECT_RESET_DATA();                                                         //carga el RESET_bffr[] con los datos del reset PIC 
....................    if(RESET_bffr[0] == 0x8e) 
....................    { 
....................       satellitelog[0] = 0xda;                                                    //header of the satellite log 
....................       satellitelog[1] = 0xda;                                                    //header of the satellite log 
....................     
....................       satellitelog[2] = RESET_bffr[1]; 
....................       satellitelog[3] = RESET_bffr[2]; 
....................       satellitelog[4] = RESET_bffr[3]; 
....................       satellitelog[5] = RESET_bffr[4]; 
....................       satellitelog[6] = RESET_bffr[5]; 
....................        
....................       satellitelog[7] = data1; 
....................       satellitelog[8] = data2; 
....................       satellitelog[9] = data3; 
....................       satellitelog[10] = 0xef;                                                   //footer, fin del array 
....................        
....................       output_low(PIN_A5);                                                        //CAM_MUX main side 
....................       output_low(PIN_C4);                                                        //COM_MUX main side 
....................       for(int i = 0; i < logdata_size; i++)                                      //guarda el dato en las tres Flash en la posicion de memoria indicada por SAT_LOG  
....................       { 
....................          WRITE_DATA_BYTE_OF(SAT_LOG + i,satellitelog[i]); 
....................          WRITE_DATA_BYTE_SCF(SAT_LOG + i,satellitelog[i]); 
....................          WRITE_DATA_BYTE_SMF(SAT_LOG + i,satellitelog[i]); 
....................       } 
....................       output_high(PIN_C4);                                                       //COM_MUX COM side 
....................       SAT_LOG = SAT_LOG + logdata_size; 
....................       fprintf(PC,"LOG saving done\r\n"); 
....................    } 
....................     
....................    return; 
.................... } 
....................  
....................  
....................  
....................  
.................... //----------Flash_memory_MT25QL01GBBB_OF.c------------------------------------- 
....................  
.................... void WRITE_ENABLE_OF(); 
.................... void WRITE_ENABLE_SCF(); 
.................... void WRITE_ENABLE_SMF(); 
....................  
.................... void sector_erase_OF(unsigned int32 sector_address); 
.................... void sector_erase_SCF(unsigned int32 sector_address); 
.................... void sector_erase_SMF(unsigned int32 sector_address); 
....................  
.................... void SUBSECTOR_4KB_ERASE_OF(unsigned int32 sector_address); 
.................... void SUBSECTOR_4KB_ERASE_SCF(unsigned int32 sector_address); 
.................... void SUBSECTOR_4KB_ERASE_SMF(unsigned int32 sector_address); 
....................  
.................... void SUBSECTOR_32KB_ERASE_OF(unsigned int32 sector_address); 
.................... void SUBSECTOR_32KB_ERASE_SCF(unsigned int32 sector_address); 
.................... void SUBSECTOR_32KB_ERASE_SMF(unsigned int32 sector_address); 
....................  
.................... void WRITE_DATA_BYTE_OF(unsigned int32 page_address, int8 data); 
.................... void WRITE_DATA_BYTE_SCF(unsigned int32 page_address, int8 data); 
.................... void WRITE_DATA_BYTE_SMF(unsigned int32 page_address, int8 data); 
....................  
.................... int8 READ_CHIP_ID_OF(); 
.................... int8 READ_CHIP_ID_SCF(); 
.................... int8 READ_CHIP_ID_SMF(); 
....................  
.................... int8 READ_STATUS_REGISTER_OF(); 
.................... int8 READ_STATUS_REGISTER_SCF(); 
.................... int8 READ_STATUS_REGISTER_SMF(); 
....................  
.................... int8 READ_DATA_BYTE_OF(unsigned INT32 ADDRESS); 
.................... int8 READ_DATA_BYTE_SCF(unsigned INT32 ADDRESS); 
.................... int8 READ_DATA_BYTE_SMF(unsigned INT32 ADDRESS); 
....................  
.................... void TRANSFER_DATA_256byte_OF(unsigned INT32 ADRESS, int PORT_NUM); 
.................... void TRANSFER_DATA_256byte_SCF(unsigned INT32 ADRESS, int PORT_NUM); 
.................... void TRANSFER_DATA_256byte_SMF(unsigned INT32 ADRESS, int PORT_NUM); 
....................  
.................... void WRITE_DATA_NBYTE_OF(unsigned INT32 ADDRES,int32 data_byte); 
.................... void WRITE_DATA_NBYTE_SCF(unsigned INT32 ADDRES,int32 data_byte); 
.................... void WRITE_DATA_NBYTE_SMF(unsigned INT32 ADDRES,int32 data_byte); 
....................  
.................... void TRANSFER_DATA_NBYTE_TOPC_OF(unsigned INT32 ADRESS,int32 data_byte); //for testing 
.................... void TRANSFER_DATA_NBYTE_TOPC_SCF(unsigned INT32 ADRESS,int32 data_byte); //for testing 
.................... void TRANSFER_DATA_NBYTE_TOPC_SMF(unsigned INT32 ADRESS,int32 data_byte); //for testing 
....................  
.................... void TRANSFER_DATA_NBYTE_OFtoSCF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //transfer data from MAIN FLASH to COM FLASH 
.................... void TRANSFER_DATA_NBYTE_SCFtoOF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //transfer data from COM FLASH to MAIN FLASH 
.................... void TRANSFER_DATA_NBYTE_OFtoSMF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //transfer data from MAIN FLASH to MISSION FLASH 
.................... void TRANSFER_DATA_NBYTE_SMFtoOF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //transfer data from MISSION FLASH to MAIN FLASH 
.................... void TRANSFER_DATA_NBYTE_SMFtoSCF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //transfer data from MISSION FLASH to COM FLASH 
.................... void TRANSFER_DATA_NBYTE_SCFtoSMF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //transfer data from COM FLASH to MISSION FLASH 
....................  
.................... void TRANSFER_DATA_NBYTE_OF(unsigned INT32 FROM_ADRESS,unsigned INT32 TO_ADRESS,int32 data_byte); //for testing 
....................  
.................... //void sector_erase(unsigned int32 sector_address);  //this is for sector erase 
....................  
....................  
.................... //----------------------------------------------------------------------------- 
....................  
....................  
....................  
....................  
.................... #INT_rda4                                                                        //Reset PIC Interrupt, RS232 receive data available in buffer 4 
.................... void UART4_RXD(void) 
.................... { 
....................    reset_bffr[RESET_DATA] = fgetc(reset);                                        //loads the reset_bffr array with the data sent by the Reset PIC (carga el array reset_bffr con los datos enviados por el Reset PIC) 
*
0068A:  CLRF   03
0068C:  MOVF   xED,W
0068E:  ADDLW  EE
00690:  MOVWF  FE9
00692:  MOVLW  00
00694:  ADDWFC 03,W
00696:  MOVWF  FEA
00698:  MOVFF  FEA,225
0069C:  MOVFF  FE9,224
006A0:  BRA    0640
006A2:  MOVFF  225,FEA
006A6:  MOVFF  224,FE9
006AA:  MOVFF  01,FEF
....................    RESET_DATA = ((RESET_DATA + 1) % RESET_size);                                 //when the data is obtained in position 11 RESET_DATA = 0 (cuando se obtenga el dato en la posicion 11 RESET_DATA=0) 
006AE:  MOVLW  01
006B0:  ADDWF  xED,W
006B2:  MOVLB  2
006B4:  MOVWF  x23
006B6:  MOVWF  x24
006B8:  MOVLW  0B
006BA:  MOVWF  x25
006BC:  MOVLB  0
006BE:  BRA    065C
006C0:  MOVFF  00,ED
....................    if(reset_bffr[0] == 0xaa)                                                     //get ready for reset satellite 
006C4:  MOVF   xEE,W
006C6:  SUBLW  AA
006C8:  BNZ   06D0
....................    { 
....................       reset_flag = 1;                                                            //raise flag to reset (pone a alto bandera para reseteo) 
006CA:  MOVLW  01
006CC:  MOVWF  xF9
....................       RESET_DATA = 0;                                                            //position indicator within reset_data vector (indicador de posicion dentro del vector reset_data) 
006CE:  CLRF   xED
....................    } 
....................     
006D0:  BCF    FA6.7
006D2:  GOTO   0078
.................... }  
....................  
.................... void main() 
*
01398:  CLRF   FF8
0139A:  BCF    FA9.7
0139C:  BSF    FD0.7
0139E:  BSF    07.7
013A0:  MOVLB  E
013A2:  MOVLW  55
013A4:  MOVWF  F7E
013A6:  MOVLW  AA
013A8:  MOVWF  F7E
013AA:  BCF    F66.6
013AC:  MOVLW  F4
013AE:  MOVWF  x2A
013B0:  MOVLW  F5
013B2:  MOVWF  x2B
013B4:  MOVLW  F8
013B6:  MOVWF  x2C
013B8:  MOVLW  F9
013BA:  MOVWF  x2D
013BC:  MOVLW  01
013BE:  MOVWF  x1B
013C0:  MOVLW  20
013C2:  MOVWF  x1D
013C4:  MOVLW  30
013C6:  MOVWF  x22
013C8:  MOVLW  20
013CA:  MOVWF  x24
013CC:  MOVLW  55
013CE:  MOVWF  F7E
013D0:  MOVLW  AA
013D2:  MOVWF  F7E
013D4:  BSF    F66.6
013D6:  CLRF   F9B
013D8:  CLRF   F64
013DA:  CLRF   F65
013DC:  CLRF   F66
013DE:  MOVLW  02
013E0:  MOVWF  FD3
013E2:  BSF    F67.3
013E4:  MOVLW  22
013E6:  MOVWF  FAF
013E8:  MOVLW  00
013EA:  MOVLB  F
013EC:  MOVWF  x30
013EE:  MOVLW  A6
013F0:  MOVWF  FAC
013F2:  MOVLW  90
013F4:  MOVWF  FAB
013F6:  CLRF   1B
013F8:  BSF    x31.3
013FA:  MOVLW  A0
013FC:  MOVWF  x1F
013FE:  MOVLW  01
01400:  MOVWF  x20
01402:  MOVLW  A6
01404:  MOVWF  x32
01406:  MOVLW  90
01408:  MOVWF  x33
0140A:  MOVLB  E
0140C:  BSF    xFD.3
0140E:  MOVLW  A0
01410:  MOVWF  xFB
01412:  MOVLW  01
01414:  MOVWF  xFC
01416:  MOVLW  A6
01418:  MOVWF  xFE
0141A:  MOVLW  90
0141C:  MOVWF  xFF
0141E:  MOVLB  F
01420:  BSF    x2D.3
01422:  MOVLW  A0
01424:  MOVWF  x2B
01426:  MOVLW  01
01428:  MOVWF  x2C
0142A:  MOVLW  A6
0142C:  MOVWF  x2E
0142E:  MOVLW  90
01430:  MOVWF  x2F
01432:  BCF    F98.2
01434:  BSF    F8F.2
01436:  BCF    F98.0
01438:  BSF    F8F.0
0143A:  BSF    F96.0
0143C:  BCF    F96.6
0143E:  BCF    F96.1
01440:  BCF    F8D.1
01442:  BSF    F93.5
01444:  BCF    F93.4
01446:  BCF    F93.2
01448:  BCF    F8A.2
0144A:  BSF    F92.0
0144C:  BCF    F92.1
0144E:  BCF    F92.3
01450:  BCF    F89.3
01452:  CLRF   1F
01454:  CLRF   1E
01456:  MOVLW  10
01458:  MOVWF  1D
0145A:  CLRF   1C
0145C:  CLRF   23
0145E:  CLRF   22
01460:  CLRF   21
01462:  CLRF   20
01464:  CLRF   27
01466:  MOVLW  04
01468:  MOVWF  26
0146A:  CLRF   25
0146C:  CLRF   24
0146E:  CLRF   2B
01470:  MOVLW  05
01472:  MOVWF  2A
01474:  CLRF   29
01476:  CLRF   28
01478:  CLRF   2F
0147A:  MOVLW  06
0147C:  MOVWF  2E
0147E:  CLRF   2D
01480:  CLRF   2C
01482:  CLRF   33
01484:  MOVLW  08
01486:  MOVWF  32
01488:  CLRF   31
0148A:  CLRF   30
0148C:  CLRF   37
0148E:  MOVLW  62
01490:  MOVWF  36
01492:  CLRF   35
01494:  CLRF   34
01496:  MOVLW  04
01498:  MOVWF  3B
0149A:  MOVLW  4A
0149C:  MOVWF  3A
0149E:  CLRF   39
014A0:  CLRF   38
014A2:  MOVLW  04
014A4:  MOVWF  3F
014A6:  MOVLW  72
014A8:  MOVWF  3E
014AA:  CLRF   3D
014AC:  CLRF   3C
014AE:  MOVLW  06
014B0:  MOVWF  43
014B2:  MOVLW  65
014B4:  MOVWF  42
014B6:  CLRF   41
014B8:  CLRF   40
014BA:  MOVLW  06
014BC:  MOVWF  47
014BE:  MOVLW  66
014C0:  MOVWF  46
014C2:  CLRF   45
014C4:  CLRF   44
014C6:  MOVLW  06
014C8:  MOVWF  4B
014CA:  MOVLW  67
014CC:  MOVWF  4A
014CE:  CLRF   49
014D0:  CLRF   48
014D2:  CLRF   4F
014D4:  MOVLW  01
014D6:  MOVWF  4E
014D8:  MOVLW  80
014DA:  MOVWF  4D
014DC:  CLRF   4C
014DE:  CLRF   53
014E0:  MOVLW  01
014E2:  MOVWF  52
014E4:  MOVLW  80
014E6:  MOVWF  51
014E8:  MOVLW  1C
014EA:  MOVWF  50
014EC:  CLRF   54
014EE:  CLRF   56
014F0:  CLRF   55
014F2:  CLRF   57
014F4:  CLRF   58
014F6:  CLRF   59
014F8:  CLRF   5A
014FA:  CLRF   5B
014FC:  CLRF   5C
014FE:  CLRF   5D
01500:  CLRF   5E
01502:  CLRF   5F
01504:  MOVLB  0
01506:  CLRF   x60
01508:  CLRF   x61
0150A:  CLRF   x62
0150C:  CLRF   x63
0150E:  CLRF   x64
01510:  CLRF   x65
01512:  CLRF   x66
01514:  CLRF   x67
01516:  CLRF   x68
01518:  CLRF   x69
0151A:  CLRF   x82
0151C:  CLRF   x83
0151E:  CLRF   x84
01520:  CLRF   x85
01522:  CLRF   x86
01524:  CLRF   xEB
01526:  CLRF   xEC
01528:  CLRF   xED
0152A:  CLRF   xF9
0152C:  MOVLB  1
0152E:  CLRF   x34
01530:  CLRF   x33
01532:  CLRF   x35
01534:  CLRF   x37
01536:  CLRF   x36
01538:  MOVLB  E
0153A:  CLRF   xD9
0153C:  CLRF   xDA
0153E:  CLRF   x45
01540:  CLRF   x46
01542:  CLRF   x47
01544:  BCF    x8D.7
01546:  BCF    x8D.6
01548:  BCF    x8D.5
0154A:  MOVLB  1
0154C:  CLRF   x88
0154E:  MOVLB  F
01550:  CLRF   x53
01552:  CLRF   x38
01554:  CLRF   x37
01556:  BRA    1572
01558:  DATA 18,40
0155A:  DATA 6A,00
0155C:  DATA 64,40
0155E:  DATA 87,00
01560:  DATA 0B,40
01562:  DATA EE,00
01564:  DATA 39,40
01566:  DATA FA,00
01568:  DATA 3D,41
0156A:  DATA 41,00
0156C:  DATA 0B,41
0156E:  DATA F7,00
01570:  DATA 00,00
01572:  MOVLW  00
01574:  MOVWF  FF8
01576:  MOVLW  15
01578:  MOVWF  FF7
0157A:  MOVLW  58
0157C:  MOVWF  FF6
0157E:  TBLRD*+
01580:  MOVF   FF5,W
01582:  MOVWF  00
01584:  XORLW  00
01586:  BZ    15AE
01588:  TBLRD*+
0158A:  MOVF   FF5,W
0158C:  MOVWF  01
0158E:  BTFSC  FE8.7
01590:  BRA    159C
01592:  ANDLW  0F
01594:  MOVWF  FEA
01596:  TBLRD*+
01598:  MOVFF  FF5,FE9
0159C:  BTFSC  01.6
0159E:  TBLRD*+
015A0:  BTFSS  01.6
015A2:  TBLRD*+
015A4:  MOVFF  FF5,FEE
015A8:  DCFSNZ 00,F
015AA:  BRA    157E
015AC:  BRA    15A0
015AE:  CLRF   FF8
.................... { 
....................    //settings(); 
....................    set_tris_b(0b11010000); 
015B0:  MOVLW  D0
015B2:  MOVWF  F93
....................    enable_interrupts(global); 
015B4:  MOVLW  C0
015B6:  IORWF  FF2,F
....................    enable_interrupts(INT_rda4); 
015B8:  BSF    F61.7
....................    fprintf(PC,"Start Operating\r\n"); 
015BA:  MOVLW  D6
015BC:  MOVWF  FF6
015BE:  MOVLW  06
015C0:  MOVWF  FF7
015C2:  MOVLW  00
015C4:  MOVWF  FF8
015C6:  MOVLB  0
015C8:  CALL   0704
....................    output_high(PIN_A5);  //MUX MISSION SIDE 
015CC:  BCF    F92.5
015CE:  BSF    F89.5
....................    output_low(PIN_A5); //MUX MAIN SIDE 
015D0:  BCF    F92.5
015D2:  BCF    F89.5
....................     
....................    while(TRUE) 
....................    { 
....................       fprintf(PC,"\r\nHello World\r\n"); 
015D4:  MOVLW  E8
015D6:  MOVWF  FF6
015D8:  MOVLW  06
015DA:  MOVWF  FF7
015DC:  MOVLW  00
015DE:  MOVWF  FF8
015E0:  CALL   0704
....................       fprintf(PC,"Operating\r\n"); 
015E4:  MOVLW  F8
015E6:  MOVWF  FF6
015E8:  MOVLW  06
015EA:  MOVWF  FF7
015EC:  MOVLW  00
015EE:  MOVWF  FF8
015F0:  CALL   0704
....................       delay_ms(2500); 
015F4:  MOVLW  0A
015F6:  MOVLB  2
015F8:  MOVWF  x02
015FA:  MOVLW  FA
015FC:  MOVWF  x10
015FE:  MOVLB  0
01600:  CALL   072E
01604:  MOVLB  2
01606:  DECFSZ x02,F
01608:  BRA    15FA
....................       PINO_Test(); 
0160A:  MOVLB  0
0160C:  GOTO   0D7C
01610:  BRA    15D4
....................    } 
....................  
.................... } 
01612:  SLEEP 

Configuration Fuses:
   Word  1: F6A0   STVREN NOXINST NODEBUG NOBROWNOUT BORV18 NOPROTECT
   Word  2: FFA2   PR SOSC_DIG CLOCKOUT IESO NOPLL
   Word  3: F032   HS
   Word  4: F7FF   WPFP WPDIS WPEND NOWPCFG
   Word  5: FF03   T5G_IS_T5G CINA_DEFAULT IOL1WAY LS48MHZ MSSP2MSK7 MSSPMSK7
   Word  6: FCFF   WDTWIN_25% WDTCLK_FRC WDT32768 NOWDT WINDIS WPRES128
   Word  7: F01D   NOVREGSLEEP VBATBOR DSBOR DS_SW
   Word  8: F3F8   DSWDT_25DAYS DSWDT DSWDTOSC_INT
